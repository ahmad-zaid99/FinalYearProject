{"id": "S002200001600026X", "article": "MAIN-TITLE HEX: Scaling honeycombs is easier than scaling clock trees   HIGHLIGHTS          The HEX grid is a Byzantine fault-tolerant and self-stabilizing clock distribution.      We argue that HEX is a robust alternative to buffered clock trees.      HEX guarantees a small clock skew between neighbors with moderately balanced delays.      HEX seamlessly integrates with multiple synchronized clock sources.      We provide both theoretical analysis and simulations of the worst-case/average skew.          KEYPHRASES   Clock distribution  Byzantine fault-tolerance  Self-stabilization  Skew analysis  Simulations   Being able to distribute a synchronized clock signal to a large number of spatially distributed functional units is crucial for the synchronous design paradigm. In Very Large Scale Integration (VLSI) circuits, multi-core processors, and other hardware devices (as well as in master-slave-type network clock synchronization approaches like IEEE1588 [1]), this is accomplished by means of a clock tree, which distributes the clock signal supplied by a single clock source to all functional units attached as leaf nodes. Topologies that guarantee equal wire lengths from the root to the leaves are used to ensure that clock pulses arrive at all functional units (i.e., those making up a synchronous sub-system) simultaneously. Such topologies are, for example, H-trees, 3   3 H-trees are recursively constructed from a H-shaped wiring topology by attaching four smaller H-shapes to the four open ends. combined with carefully engineered wire geometries, clock signal regeneration buffers, etc. This must be achieved with a clock skew, i.e., maximum difference of the occurrence real-times of corresponding clock pulses at different functional units, well below half the clock cycle time: When a functional unit sends some data, say, on local clock count 1000, the receiver is expected to receive and process the data when clock 1001 occurs according to its clock count.  Clock trees are attractive for several reasons. Besides conceptual simplicity, their height is only logarithmic in the number of the leaves (which is proportional to the die area), and the number of internal clock wires is linear in this number. As trees are planar graphs, it would (in principle) even be possible to route these links on a single interconnect layer.  These advantages come at a price, though: Elaborate clock tree engineering must ensure that the maximum delay discrepancy remains below the acceptable clock skew, which is very difficult for clock speeds in the GHz range [2\u20135]. Modern clock trees thus incorporate complex wire geometries and strong clock buffers, implying large area and power consumption [6]. Moreover, mitigating the inevitable skews from disjoint root-leaf paths requires extended topologies, such as trees with cross-links, meshes and multi-level trees [5,7].  An even more serious issue with clock trees is lacking robustness, which also arises in applications where there are no severe skew requirements. First of all, at the top level, a single clock source obviously constitutes a single point of failure. This is avoided by Globally Asynchronous Locally Synchronous (GALS) [8] architectures, where different parts of a chip are clocked by different clock sources and clock trees. However, using independent and hence unsynchronized clock domains gives away the advantages of global synchrony and thus requires non-synchronous cross-domain communication mechanisms or synchronizers [9\u201312]. Multi-synchronous clocking [13,14] (also called mesochronous clocking [15]), which guarantees some upper bound on the skew between clock domains, has been invented to avoid this. The resulting architectures can rely on a common time base, which is attractive not only for application programmers, but also for metastability-free high-speed communication between different clock domains [16].  Still, the problem of limited robustness of clock trees persists even in GALS architectures: If just one internal wire or clock buffer in a clock tree breaks, e.g., due to some manufacturing defect or breakdown [17], all the functional units supplied via the affected subtree will stop working correctly. Therefore, it is desirable to have fairly small clock trees in a GALS system, necessitating a large number of synchronized clock domains. Overcoming the fundamental scalability and robustness issues of clock trees hence introduces the new challenge of robustly establishing tight synchronization among a large number of clock domains.   Contribution   In this paper, we tackle this problem by proposing an alternative way for distributing a synchronized clock signal throughout an integrated circuit. Our approach, termed HEX, is based on a sufficiently connected wiring topology, namely, a hexagonal grid. 4   4 Note that clock distribution by means of our HEX grid is fundamentally different from using a clock mesh [5] for averaging out large clock skews among nearby leaf nodes. At each grid point, we place an (intermediate) node that controls when the clock pulses are forwarded to adjacent nodes and supplies the clock to nearby functional units, typically using a small local clock tree. It will turn out that HEX compares favorably to clock trees in most aspects.  In particular, with respect to robustness, our approach supports multiple synchronized clock sources, and tolerates Byzantine failures of both clock sources and nodes. Its resilience to failures scales with the size of the grid, in the sense that it supports a constant density of isolated Byzantine nodes, and it can handle a larger number of more benign failures like broken wires, or mute clock sources and nodes. It is self-stabilizing [18], in the sense that it recovers from an arbitrary number of transient faults, despite persisting isolated Byzantine failures.  Furthermore, HEX has enticing properties with respect to the achievable skew between neighbors in the grid, which are typically the ones who need to communicate synchronously with each other. First, wires between HEX nodes are much shorter than in a clock tree: Assuming a constant spatial node density, the total number of nodes n = \u0398 (   s   2   ) is proportional to the square of the width and height s of a quadratic grid.  As s = \u0398 (  n  ) , the wire length between neighbors in HEX is, with optimal layout (cf. Section 5), only \u0398 ( 1 ) . By contrast, the height of a clock tree is \u0398 ( log \u2061 n ) thus, even with optimal layout, their will be neighbors which are separated by a wire length of \u03a9 (  n  ) . HEX hence neither requires strong clock buffers nor special wire geometries, so that the maximal difference \u03b5 of the end-to-end delays between neighbors in the grid could easily be kept small even by moderate engineering efforts.  Second, for a proper embedding of the HEX topology, physically close nodes are reasonably well-synchronized. It is well-known, e.g., from [19], that no deterministic clock synchronization algorithm can guarantee a worst-case skew between all pairs of nodes that is better than D \u03b5 / 2 , where D is the diameter of the underlying communication graph. Moreover, the gradient clock synchronization lower bounds established in [20] reveal that the skew between neighbors cannot be better than \u03a9 ( \u03b5 log \u2061 D ) . We will show that the neighbor skew provided by HEX is at most O ( D   \u03b5   2   ) , where D is in fact the width of the grid. Depending on the number and severity of faults, this skew bound gracefully degrades.   Paper organization   After a short description of related work, the HEX topology and algorithm as well as the system model are introduced in Section 2. In Section 3, we provide a detailed analysis of the worst-case neighbor skew of HEX (Section 3.1), discuss the effect of faulty nodes on the skew (Section 3.2), and analyze the self-stabilizing properties of HEX (Section 3.3). As the complexity of the skew analysis explodes for an increasing number of faults, the detailed analysis in the case of a single Byzantine faulty node is provided in Appendix A. In Section 4, we provide the corresponding results of our extensive simulation experiments, which have been obtained via a custom Modelsim-based simulation and analysis framework. In Section 5, we discuss practical extensions of HEX, in particular, frequency multiplication and alternative grid topologies. Some conclusions and directions of future work in Section 6 complete the paper. A glossary of the notations used can be found on the last page of this paper.   Related work   Apart from the rich literature on clock tree engineering and extended topologies for skew reduction, see for example [2\u20137,17,21,22], we are not aware of much research on alternative clock distribution techniques. An exception is the work on distributed clock generation without local oscillators, which inherently also solves the problem of clock distribution. These approaches are essentially based on (distributed) ring oscillators, which are formed by gates arranged in a feedback loop. In [23], a regular structure of closed loops of an odd number of inverters is used for distributed clock generation. Similarly, [24,25] employ local pulse generation cells, arranged in a two-dimensional grid, with each cell inverting its output signal when its four inputs (from the up, down, left, and right neighbor) match the current clock output value. A more elaborate approach along the same lines uses an array of PLLs that are mutually synchronized among each other, using digital feedback exchanged across some (sparse) communication topology, like a grid [26\u201328]. To the best of our knowledge, none of these approaches has been analyzed for its fault-tolerance properties, not to speak of self-stabilization.  The only fault-tolerant clock generation approaches for multi-synchronous GALS systems known to us are the Byzantine fault-tolerant DARTS approach [29,30] and our self-stabilizing Byzantine fault-tolerant FATAL algorithm proposed in [31]. However, both approaches are complex and require a fully connected topology. Consequently, they are not useful for distributing a synchronized clock to a large number of functional units, but are rather suitable candidates for the clock sources required by our HEX grid.  We consider a set of nodes executing a pulse generation and forwarding algorithm, which communicate by message passing over a communication network whose underlying undirected communication graph is a cylindric hexagonal grid.  Formally, the directed communication graph ( V , E ) of our HEX grid is defined as follows (see Fig. 1 ): Letting L \u2208 N denote its length and W \u2208 N its width, the set of nodes V is the set of tuples ( \u2113 , i ) \u2208 [ L + 1 ] \u00d7 [ W ] . Here, [ L + 1 ] : = { 0 , \u2026 , L } denotes the row index set, referred to as layers, and [ W ] : = { 0 , \u2026 , W \u2212 1 } the column index set of the nodes in the grid. For each node ( \u2113 , i ) \u2208 V , 0 < \u2113 \u2208 [ L + 1 ] , i \u2208 [ W ] , the following links are in E: Incoming and outgoing links to neighboring nodes of the same layer, namely from ( \u2113 , i ) to ( \u2113 , i \u2212 1 mod  W ) , called the left neighbor of ( \u2113 , i ) , and to ( \u2113 , i + 1 mod  W ) , called the right neighbor (and vice versa from the left and the right neighbor to ( \u2113 , i ) ); ( \u2113 , i ) also has incoming links from ( \u2113 \u2212 1 , i ) , called its lower left neighbor, and ( \u2113 \u2212 1 , i + 1 mod  W ) , called its lower right neighbor. Hence, if ( \u2113 , i ) is in a layer \u2113 \u2208 [ L ] , then it has outgoing links to ( \u2113 + 1 , i \u2212 1 mod  W ) , its upper left neighbor, and ( \u2113 + 1 , i ) , its upper right neighbor. Fig. 1 depicts the structure of the resulting HEX grid and shows a node's communication channels within the grid. The neighboring nodes of node ( \u2113 , i ) form a hexagon, hence the name HEX grid. Due to the fact that column coordinates are modulo W, the HEX grid has a cylindric shape; we will discuss the issue of embedding a HEX grid on a chip in Section 5.  Each node of the grid runs an algorithm that can broadcast trigger messages (representing clock pulses) over its outgoing links, as well as receive trigger messages over its incoming links. Each fault-free link guarantees a communication delay (i.e., the time between sending and receiving a trigger message) within [   d   \u2212   ,   d   +   ] \u2282 ( 0 , \u221e ) , where \u03b5 : =   d   +   \u2212   d   \u2212   . Having \u03b5 without any constraint, however, could render a few worst-case constructions (based on Definition 2) overly conservative. This can be avoided by the additional constraint \u03b5 \u2264   d   +   / 2 , which guarantees a property similar to the triangle inequality. Each node further has access to a (possibly inaccurate) clock to measure timeouts.  Nodes at layer 0 are special as they act as primary clock sources, i.e., they execute a pulse generation algorithm like the one of [30,31] that generates synchronized and well-separated consecutive initial trigger messages. For each pulse number k \u2208 N , the time between any (non-faulty) node in layer 0 generating its   k   th   trigger message and another node in layer 0 generating its   ( k + 1 )   th   trigger message is sufficiently large. The precise meaning of \u201csufficiently large\u201d depends on the desired fault-tolerance properties; we will elaborate on this in Section 3.3. Note that it is desirable to keep the maximal time between pulses small in order to guarantee a high operating frequency.  Nodes at layers larger than 0 run the HEX pulse forwarding algorithm specified in Algorithm 1 . Basically, nodes forward pulse k once they received trigger messages for pulse k from two adjacent neighbors. Since clock pulses and trigger messages carry no information beside their occurrence, care must be taken in order not to generate multiple trigger messages for a single pulse. The simple solution we use here relies on a sufficiently large separation between the   k   th   and   ( k + 1 )   th   pulse (for each k), which relieves us from locally keeping track of pulse counts. For each link, a node memorizes a received trigger message only for some time between   T   link   \u2212   and   T   link   +   ,   T   link   +   \u2265   T   link   \u2212   , where the slack   T   link   +   \u2212   T   link   \u2212   accounts for inaccurate local timers, and then forgets the reception of the message by clearing the memory flag associated with the link. After having forwarded its pulse, a node goes to sleep (i.e., will not locally trigger further pulses) for some time between   T   sleep   \u2212   and   T   sleep   +   \u2265   T   sleep   \u2212   . Upon waking up, it clears all its memory flags. Note that there would be no need for the individual link timeout mechanism ( [   T   link   \u2212   ,   T   link   +   ] ) described above if the algorithm always started from a properly initialized state. It is required, however, for also guaranteeing self-stabilization from arbitrary states in the presence of persistent Byzantine faults.  The precise conditions for   T   link   \u2212   and   T   sleep   \u2212   follow from the analysis and are discussed in Section 3.3. Due to its simplicity, Algorithm 1 can easily be implemented by means of an asynchronous state machine, see Fig. 7a in Section 4.  In this section, we analyze skew and fault-tolerance properties of the HEX algorithm in the topology presented in the previous section. Recall that nodes in layer 0 generate synchronized pulses, which the nodes in higher layers just propagate upwards; this results in a \u201cpulse wave\u201d as depicted in Fig. 8. By   t   \u2113 , i   ( k )   , we denote the triggering time of node ( \u2113 , i ) , i.e., the time when it forwards the   k   th   pulse of the grid. Generally, we will use superscript    ( k )   to denote variables associated with the   k   th   pulse.  We will now analyze the propagation of a single pulse wave, 5   5 To keep the notation simple, we will drop the superscript    ( k )   indicating the pulse number during this section. assuming that the constraints (C1) and (C2) below are satisfied and no nodes are faulty. In a nutshell, our constraints ensure that, initially, all nodes have cleared their memory flags and are waiting for the next pulse generated by the nodes in layer 0.  (C1)     T   link   \u2212   is sufficiently large so that no trigger message from a neighbor is \u201cforgotten\u201d before the corresponding message from another neighbor arrives. Thus we can be sure that a node which is not sleeping will be triggered by a wave.      T   sleep   \u2212   ,   T   sleep   +   , and the time between pulses (controlled by the layer 0 nodes) are large enough so that (i) every node will be triggered at most once per wave and (ii) no node sleeps when the next wave arrives.  We first introduce the concept of \u201cleft zig-zag paths\u201d, which will play an essential role in bounding the worst-case triggering times of adjacent nodes in a single pulse wave.    Definition 1 Causal links and paths   A node is left-triggered/centrally triggered/right-triggered in a given execution, if the satisfied guard from Algorithm 1 causing the node to trigger is having received trigger messages from the left and lower left/lower left and lower right/lower right and right neighbors, respectively. In each case both of the respective links are causal. A causal path consists of causal links only.  Note that a link being causal implies that its endpoint is triggered at least   d   \u2212   time after its origin. For instance, if ( \u2113 , i ) is left-triggered, the links ( ( \u2113 , i \u2212 1 ) , ( \u2113 , i ) ) and ( ( \u2113 \u2212 1 , i ) , ( \u2113 , i ) ) are causal, while ( ( \u2113 , i + 1 ) , ( \u2113 , i ) ) , ( ( \u2113 \u2212 1 , i + 1 ) , ( \u2113 , i ) ) are not.  The following definition backtraces a sequence of causal links from a given destination node, either to the node in layer 0 starting the causal chain or to some specific column of interest. Note that this can be done for any destination node in a given execution.    Definition 2 Left zig-zag paths   Given are a layer 0 < \u2113 \u2208 [ L + 1 ] and column indices i ,   i   \u2032   \u2208 [ W ] , i <   i   \u2032   . 6   6 Recall that column indices are implicitly taken mod W, so in principle we would have to account for this in the definition. However, in our proofs we will exploit the translation and mirror symmetry of the grid w.r.t. column indices so that we can always assume that i <   i   \u2032   , avoiding more involved notations. For example, if i = W \u2212 1 , then some node in the column to the right (which has column index 0) is considered as having index   i   \u2032   = W . The causal left zig-zag path    p   left     i   \u2032   \u2192 ( \u2113 , i )   is composed of rightward links ( (   \u2113   \u2032   , j \u2212 1 ) , (   \u2113   \u2032   , j ) ) and up-left links ( (   \u2113   \u2032   \u2212 1 , j + 1 ) , (   \u2113   \u2032   , j ) ) . It is inductively defined as follows. We start with the 0-length path ( ( \u2113 , i ) ) . Suppose that in some step of the construction the current path originates at node (   \u2113   \u2032   , j ) with   \u2113   \u2032   > 0 . If (   \u2113   \u2032   , j ) is left-triggered, we extend the path by adding the rightward link ( (   \u2113   \u2032   , j \u2212 1 ) , (   \u2113   \u2032   , j ) ) as first link (and (   \u2113   \u2032   , j \u2212 1 ) as its origin). Otherwise, the up-left link ( (   \u2113   \u2032   \u2212 1 , j + 1 ) , (   \u2113   \u2032   , j ) ) is causal and can be added as prefix to the path (and (   \u2113   \u2032   \u2212 1 , j + 1 ) as its origin). In the case of adding an up-left link the construction terminates if either (i) j + 1 =   i   \u2032   and the path now contains more up-left than rightward links (we will call   p   left     i   \u2032   \u2192 ( \u2113 , i )   a triangular path in this case) or (ii)   \u2113   \u2032   \u2212 1 = 0 and j + 1 arbitrary (a non-triangular path).  The following simple facts about left zig-zag paths follow almost immediately from their definition.    Lemma 1  Every left zig-zag path    p   left     i   \u2032   \u2192 ( \u2113 , i )    constructed according to  Definition 2  is finite. If    p   left     i   \u2032   \u2192 ( \u2113 , i )    is a triangular path and starts at  (   \u2113   \u2032   ,   i   \u2032   )  , for some  0 \u2264   \u2113   \u2032   < \u2113  , then each of its prefixes \u03c0 is also a triangular path.     Proof Since causal paths are acyclic, there must be fewer than W left links before the construction goes down one layer; the finiteness of \u2113 hence implies the finiteness of   p   left     i   \u2032   \u2192 ( \u2113 , i )   . Now assume that some prefix \u03c0 of a triangular path   p   left     i   \u2032   \u2192 ( \u2113 , i )   starting at (   \u2113   \u2032   ,   i   \u2032   ) is not a triangular path, i.e., has at least as many rightward links than up-left ones. Then, the suffix of \u03c0 must start in (   \u2113   \u2033   ,   i   \u2033   ) with   i   \u2033   \u2265   i   \u2032   , and must have more up-left links than rightward ones. Since the suffix must hence cross column   i   \u2032   from right to left, the construction of Definition 2 would already have terminated here. \u2003\u25a1  We now provide a very important technical lemma, which reveals a connection between the triggering times of two nodes ( \u2113 , i ) and ( \u2113 , i + 1 ) at the same layer \u2113: If the left node is the end of a left zig-zag triangular path starting at node (   \u2113   \u2032   ,   i   \u2032   ) and has a distance of r > 0 columns to the right node, the latter cannot trigger later than the left node plus a time offset of at most r   d   \u2212   + ( \u2113 \u2212   \u2113   \u2032   ) \u03b5 . Note that we assume here that   i   \u2032   \u2212 \u2113 \u2265 0 , i.e., that W is large enough such that no wrap-around occurs. The bound provided by Lemma 2 also holds in the general case, but then it may not be tight.    Lemma 2  Suppose that path \u03c0 is a prefix of some left zig-zag triangular path    p   left     i   \u2032   \u2192 (   \u2113   \u2033   ,   i   \u2033   )    , and that \u03c0 starts at node  (   \u2113   \u2032   ,   i   \u2032   )  and ends at node  ( \u2113 , i )  with  \u2113 > 0  . Let  r > 0  be the number of up-left links minus the number of rightward links along \u03c0. Then    t   \u2113 ,   i   \u2032     \u2264   t   \u2113 , i   + r   d   \u2212   + ( \u2113 \u2212   \u2113   \u2032   ) \u03b5  .     Proof By Lemma 1, \u03c0 is a triangular path and hence indeed r > 0 . For simplicity of our arguments, we set   \u2113   \u2032   = 0 (i.e., we shift all layer indices by   \u2113   \u2032   and the new value of \u2113 now represents \u2113 \u2212   \u2113   \u2032   ) and assume that   i   \u2032   \u2212 \u2113 \u2265 0 , i.e., that W is large enough such that no wrap-around occurs within the triangle. 7   7 Our proof also holds for the general case, though, provided (i) one just neglects the fact that some of the index pairs may actually refer to the same node (which does not affect our argument) and that (ii) certain left zig-zag paths in our construction cannot occur (which may lead to an overly conservative bound). Consequently, we only need to consider the set S of nodes in the triangle with corners ( 0 ,   i   \u2032   ) , ( \u2113 ,   i   \u2032   \u2212 \u2113 ) , and ( \u2113 ,   i   \u2032   ) shown in Fig. 2 .  Observe that   p   left     i   \u2032   \u2192 (   \u2113   \u2033   ,   i   \u2033   )   starts at the lower corner of the triangle and the prefix \u03c0 never leaves it. By induction on the   k   th   left-diagonal ( k ,   i   \u2032   ) , \u2026 , ( \u2113 ,   i   \u2032   \u2212 ( \u2113 \u2212 k ) ) (for k \u2208 [ \u2113 + 1 ] ) of the triangle, we will prove that each node p that is both on the diagonal k and either on \u03c0 or to the right of \u03c0 is triggered at the latest at time  (1)    t   p   \u2264   t   \u2113 , i   \u2212 ( \u2113 \u2212 r )   d   \u2212   + k   d   +   .   Since ( \u2113 ,   i   \u2032   ) is on diagonal \u2113, this implies   t   \u2113 ,   i   \u2032     \u2264   t   \u2113 , i   + r   d   \u2212   + \u2113 \u03b5 . Undoing the initial index shift (i.e., replacing \u2113 by \u2113 \u2212   \u2113   \u2032   ), the claim of the lemma follows.  First, we show directly that Eq. (1) holds for each node p on \u03c0: Observe that node ( \u2113 , i ) is on diagonal ( \u2113 \u2212 r ) . Hence, a node p that is h hops from ( \u2113 , i ) on \u03c0 must be on a diagonal k \u2265 ( \u2113 \u2212 r ) \u2212 h . Since   p   left     i   \u2032   \u2192 (   \u2113   \u2033   ,   i   \u2033   )   is causal, it follows that  (2)    t   p   \u2264   t   \u2113 , i   \u2212 h   d   \u2212   \u2264   t   \u2113 , i   \u2212 ( \u2113 \u2212 r )   d   \u2212   + k   d   \u2212   \u2264   t   \u2113 , i   \u2212 ( \u2113 \u2212 r )   d   \u2212   + k   d   +   ,   showing the statement for nodes on \u03c0.  Note that all nodes on diagonal 0 are either on or to the left of \u03c0, hence we already covered the induction anchor at k = 0 . For the induction step from k to k + 1 , observe that any node will be left-triggered within at most   d   +   time once both its left and lower-left neighbors are triggered. For any node p on the   ( k + 1 )   th   diagonal that is strictly to the right of \u03c0, its left and lower-left neighbor are on the diagonal k of S and either on \u03c0 or to the right of \u03c0. The statement for diagonal k thus implies   t   p   \u2264   t   \u2113 , i   \u2212 ( \u2113 \u2212 r )   d   \u2212   + k   d   +   +   d   +   as required. On the other hand, nodes lying on \u03c0 are covered by Eq. (2), which completes the induction step. \u2003\u25a1  In the following definition, we will introduce the different notions related to the skew between nodes. Besides the maximum (unsigned) intra-layer skew of neighboring nodes at the same layer and the (signed) maximum inter-layer skew w.r.t. the layer below, we also define the skew potential of layer \u2113. Informally, the latter provides a measure for the adversary's ability to exploit the existing skew of the nodes in layer \u2113 to increase the skew of neighboring nodes in layer \u2113 + 1 . By this, we mean that the adversary can, in the worst case, force a node at layer \u2113 + 1 to left-trigger strictly before it is centrally triggered by its layer-\u2113 neighbors. It is not too difficult to prove 8   8 In fact, this proof is embedded in the proof of Lemma 4. In a nutshell, it shows that such an early left-triggering would only be possible if the left neighbor itself was early left-triggered as well. By continuing this argument inductively over the entire layer, a left neighbor will eventually be reached that cannot be left-triggered, which provides the required contradiction. that this is only possible if the skew between neighbors at layer \u2113 is strictly larger than   d   \u2212   . Hence, we define the skew potential below in a way that results in a positive value only in the latter case.    Definition 3 Distance, skew, and skew potential   For i , j \u2208 Z , let d : = i \u2212 j mod  W and define the cyclic distance as | i \u2212 j   |   W   : = min \u2061 { d , W \u2212 d } . For \u2113 \u2208 [ L + 1 ] , we define  (i) the intra-layer skew of layer \u2113 as   \u03c3   \u2113   : =   max   i \u2208 [ W ]   \u2061 { |   t   \u2113 , i   \u2212   t   \u2113 , i + 1   | } ,  the skew potential on layer \u2113 as   \u0394   \u2113   : =   max   i , j \u2208 [ W ]   \u2061 {   t   \u2113 , i   \u2212   t   \u2113 , j   \u2212 | i \u2212 j   |   W     d   \u2212   } .  the inter-layer skew of layer \u2113 as     \u03c3   \u02c6     \u2113   : =   max   i \u2208 [ W ]   \u2061 {   t   \u2113 , i   \u2212   t   \u2113 \u2212 1 , i   ,   t   \u2113 , i   \u2212   t   \u2113 \u2212 1 , i + 1   } .  Note that every pair of nodes i , j occurs twice (as i , j and j , i ) in the max-term of the skew potential in (ii) above, which implies that only a non-negative time difference can determine   \u0394   \u2113   . Moreover, as j = i is not excluded, we always have   \u0394   \u2113   \u2265 0 .  We first prove a weak bound on the maximal skew at the upper layers that holds independently of the initial skew potential   \u0394   0   . Note that this result implies tolerance of HEX against arbitrary layer 0 skews, at the expense of \u201closing\u201d layers \u2113 \u2208 [ W \u2212 2 ] . This behavior is also clearly visible in the simulation results shown in Figs. 9 and 12.    Lemma 3  For  W > 2  and all  \u2113 \u2208 { W \u2212 2 , \u2026 , L }  ,    \u0394   \u2113   \u2264 2 ( W \u2212 2 ) \u03b5  .     Proof Consider any fixed i ,   i   \u2032   \u2208 [ W ] , i <   i   \u2032   (wrap-around cases are symmetrical) and assume that \u2113 = W \u2212 2 ; we will argue later on why the proof below also covers \u2113 > W \u2212 2 . We distinguish two cases.    Case 1     p   left     i   \u2032   \u2192 ( \u2113 , i )   starts at node (   \u2113   \u2032   ,   i   \u2032   ) for some   \u2113   \u2032   \u2208 { 1 , \u2026 , \u2113 \u2212 1 } . Then, by Lemma 2,     t   \u2113 ,   i   \u2032     \u2264   t   \u2113 , i   + (   i   \u2032   \u2212 i )   d   \u2212   + ( \u2113 \u2212   \u2113   \u2032   ) \u03b5 \u2264   t   \u2113 , i   + (   i   \u2032   \u2212 i )   d   \u2212   + \u2113 \u03b5 .        Case 2     p   left     i   \u2032   \u2192 ( \u2113 , i )   starts at node ( 0 , j ) , j \u2208 [ W ] . Then the path has length at least 2 \u2113 \u2212 (   i   \u2032   \u2212 i ) , since at least \u2113 up-left and \u2113 \u2212 (   i   \u2032   \u2212 i ) right links are required for the path to originate at layer 0. Denote by   t   0   the earliest time when a pair of two adjacent nodes in layer 0 are both triggered. Clearly, the   k   th   node on   p   left     i   \u2032   \u2192 ( \u2113 , i )   , k \u2265 2 , cannot be triggered before time   t   0   + ( k \u2212 1 )   d   \u2212   because it is connected by a causal path of length k \u2212 1 to a layer-0 node that is triggered at or after time   t   0   . Hence,   t   \u2113 , i   \u2265   t   0   + ( 2 \u2113 \u2212 (   i   \u2032   \u2212 i ) )   d   \u2212   and thus  (3)    t   \u2113 , i   \u2265   t   0   + ( 2 ( W \u2212 2 ) \u2212 (   i   \u2032   \u2212 i ) )   d   \u2212   .      Denote by ( 0 , j ) a node with max \u2061 {   t   0 , j   ,   t   0 , j + 1   } =   t   0   ; by the definition of   t   0   , such a node exists. We claim that all nodes in layer W \u2212 2 are triggered no later than time   t   0   + 2 ( W \u2212 2 )   d   +   . This follows by induction on the layers \u03bb \u2208 [ W \u2212 1 ] , where the hypothesis is that all nodes ( \u03bb , j \u2212 \u03bb ) , ( \u03bb , j \u2212 \u03bb + 1 ) , \u2026 , ( \u03bb , j + 1 ) are triggered until time   t   0   + 2 \u03bb   d   +   ; an illustration of the first layers is shown in Fig. 3 . Since in layer \u03bb these are 2 + \u03bb nodes, i.e., all W nodes in layer W \u2212 2 , this will prove the claim of our lemma.  By the definition of   t   0   , the induction hypothesis holds for \u03bb = 0 . To perform the step from \u03bb to \u03bb + 1 , observe that all nodes ( \u03bb + 1 , j \u2212 \u03bb ) , ( \u03bb + 1 , j \u2212 \u03bb + 1 ) , \u2026 , ( \u03bb + 1 , j ) are triggered no later than time   t   0   + ( 2 \u03bb + 1 )   d   +   , since by the hypothesis their lower left and lower right neighbors are triggered at least   d   +   before that time. Until time   t   0   + 2 ( \u03bb + 1 )   d   +   , nodes ( \u03bb + 1 , j \u2212 ( \u03bb + 1 ) ) resp. ( \u03bb + 1 , j + 1 ) must also follow since they are right- resp. left-triggered (if not triggered differently before), which completes the induction.  The result of our induction proof implies   t   \u2113 ,   i   \u2032     \u2264   t   0   + 2 ( W \u2212 2 )   d   +   and hence, by using Eq. (3),     t   \u2113 ,   i   \u2032     \u2212   t   \u2113 , i   \u2264 (   i   \u2032   \u2212 i )   d   \u2212   + 2 ( W \u2212 2 ) \u03b5 .   Overall, since i and   i   \u2032   > i were arbitrary, from the two cases and the symmetry properties of the grid, we conclude that   \u0394   \u2113   =   max   i ,   i   \u2032   \u2208 [ W ]   \u2061 {   t   \u2113 ,   i   \u2032     \u2212   t   \u2113 , i   \u2212 |   i   \u2032   \u2212 i   |   W     d   \u2212   } \u2264 2 ( W \u2212 2 ) \u03b5 , as claimed.  Finally, since the above proof did not require any specific property to be respected by layer 0 nodes, it also applies literally if we replace layer W \u2212 2 by \u2113 and layer 0 by layer \u2113 \u2212 W + 2 . This concludes the proof of Lemma 3. \u2003\u25a1  Next, we derive more refined bounds on the intra-layer skew between two neighboring nodes at the same layer \u2113 > 0 : In contrast to Lemma 3, we now take the maximal skew in previous layers into account. Unfortunately, its proof is complicated by the fact that we need to distinguish three different cases that might lead to the worst-cast skew   s   \u2113 , i   between nodes ( \u2113 , i ) and ( \u2113 , i + 1 ) . They depend on whether the skew   s   \u03bb , i   of the corresponding nodes ( \u03bb , i ) and ( \u03bb , i + 1 ) at some (suitably chosen) layer \u03bb is   s   \u03bb , i   \u2264   d   +   (Case 1) or else   s   \u03bb , i   >   d   +   (Cases 2 and 3).  Informally, Case 1 is characterized by a V-shaped growth of the worst-case skew: Our detailed proof will show that   s   \u03bb , i   increases a most by \u03b5 with every layer. By contrast, in the other cases, the nodes ( \u03bb , i ) and ( \u03bb , i + 1 ) at layer \u03bb are already \u201ctorn apart\u201d. The worst-case skew in this case is determined by a left zig-zag path   p   left   i + 1 \u2192 ( \u2113 , i )   that causes   t   \u2113 , i   to be as small as possible on the one hand, and a \u201cslow\u201d causal path ending at ( \u03bb , i + 1 ) that makes   t   \u2113 , i + 1   as large as possible on the other hand. Cases 2 and 3 are distinguished according to the two possibilities where   p   left   i + 1 \u2192 ( \u2113 , i )   can start here: Case 2 applies when it originates at some node ( 0 ,   j   0   ) with   j   0   \u2260 i + 1 , whereas Case 3 is characterized by a triangular path starting at (   \u2113   \u2032   , i + 1 ) .    Lemma 4  For all    \u2113   0   \u2208 [ L ]  and  \u2113 \u2208 {   \u2113   0   + 1 , \u2026 , L }  , it holds for each  i \u2208 [ W ]  that    |   t   \u2113 , i   \u2212   t   \u2113 , i + 1   | \u2264   d   +   +  \u2308   ( \u2113 \u2212   \u2113   0   ) \u03b5    d   +    \u2309  \u03b5 +   \u0394     \u2113   0     .        Proof Fix some value of \u2113 \u2265 1 and assume, without loss of generality, that   \u2113   0   = 0 . To simplify our arguments, we also assume   t   \u2113 , i   <   t   \u2113 , i + 1   (as the other cases are symmetric, this is sufficient).  Define   \u03bb   0   : = \u230a \u2113   d   \u2212   /   d   +   \u230b , which maximizes   \u03bb   0   under the constraint that   \u03bb   0     d   +   \u2264 \u2113   d   \u2212   . Thus, a \u201cslow\u201d chain of trigger messages will complete   \u03bb   0   hops within the time a \u201cfast\u201d chain requires for \u2113 hops. We obtain  (4)  \u2113 \u2212   \u03bb   0   = \u2113 \u2212  \u230a   \u2113   d   \u2212      d   +    \u230b  =  \u2308   \u2113 \u03b5    d   +    \u2309  ;   recall that \u2212 \u230a x \u230b = \u2308 \u2212 x \u2309 .  We distinguish three cases:    Case 1 V-shaped skews (Fig. 4a ):   t   \u03bb , i + 1   \u2264   t   \u03bb , i   +   d   +   for some \u03bb \u2265   \u03bb   0   . We choose \u03bb maximal with this property, so that   t     \u03bb   \u2032   , i + 1   >   t     \u03bb   \u2032   , i   +   d   +   for all   \u03bb   \u2032   \u2208 { \u03bb + 1 , \u2026 , \u2113 } . Notice that this implies that, for all such   \u03bb   \u2032   , node (   \u03bb   \u2032   , i ) cannot be right-triggered, as the links ( (   \u03bb   \u2032   , i + 1 ) , (   \u03bb   \u2032   , i ) ) cannot be causal. Hence, all links ( (   \u03bb   \u2032   \u2212 1 , i ) , (   \u03bb   \u2032   , i ) ) must be causal in this case. By induction on   \u03bb   \u2032   , we can thus infer   t   \u2113 , i   \u2265   t   \u03bb , i   + ( \u2113 \u2212 \u03bb )   d   \u2212   .  Furthermore,   t     \u03bb   \u2032   , i + 1   >   t     \u03bb   \u2032   , i   +   d   +   ensures that the trigger message from (   \u03bb   \u2032   , i ) to (   \u03bb   \u2032   , i + 1 ) arrives well before time   t     \u03bb   \u2032   , i + 1   . Thus, node (   \u03bb   \u2032   , i + 1 ) will be triggered at the latest when the trigger message from its lower left neighbor (   \u03bb   \u2032   \u2212 1 , i + 1 ) arrives. Again by induction on   \u03bb   \u2032   , we infer that   t   \u2113 , i + 1   \u2264   t   \u03bb , i + 1   + ( \u2113 \u2212 \u03bb )   d   +   , and hence  (5)    t   \u2113 , i + 1   \u2264   t   \u03bb , i   + ( \u2113 \u2212 \u03bb + 1 )   d   +   .   Combining these bounds and applying Eq. (4), we obtain     t   \u2113 , i + 1   \u2212   t   \u2113 , i   \u2264 ( \u2113 \u2212 \u03bb ) \u03b5 +   d   +   \u2264   d   +   +  \u2308   \u2113 \u03b5    d   +    \u2309  \u03b5 .        Case 2 Non-V-shaped skews, non-triangular (Fig. 4c): Case 1 does not apply and   p   left   i + 1 \u2192 ( \u2113 , i )   starts at some node ( 0 ,   j   0   ) , for   j   0   \u2260 i + 1 . If   p   left   i + 1 \u2192 ( \u2113 , i )   contained more left-up links than rightward links, it would contain a subpath originating at a node in column i + 1 that also would have more left-up than rightward links. This is not possible, since then the construction would have terminated at this node, either resulting in the path originating at a layer   \u2113   \u2032   > 0 or at node ( 0 , i + 1 ) . Hence   p   left   i + 1 \u2192 ( \u2113 , i )   is of length 2 \u2113 + r for some r \u2265 0 and   j   0   = i \u2212 r mod  W .  For all indices j \u2208 { i + 1 , i + 2 , \u2026 , i + 1 +   \u03bb   0   } , we have that | j \u2212   j   0     |   W   \u2264 j \u2212 i + r , and hence, by definition of the skew potential, also     t   0 , j   \u2212   t   0 ,   j   0     =   t   0 , j   \u2212   t   0 ,   j   0     \u2212 | j \u2212   j   0     |   W     d   \u2212   + | j \u2212   j   0     |   W     d   \u2212   \u2264   \u0394   0   + | j \u2212   j   0     |   W     d   \u2212   \u2264   \u0394   0   + (   \u03bb   0   + r + 1 )   d   \u2212   .   Recalling the length of   p   left   i + 1 \u2192 ( \u2113 , i )   established above, we obtain that  (6)       t   \u2113 , i     \u2265     t   0 ,   j   0     + ( 2 \u2113 + r )   d   \u2212        \u2265     t   0 , j   \u2212   \u0394   0   \u2212 (   \u03bb   0   + r + 1 )   d   \u2212   + ( 2 \u2113 + r )   d   \u2212        =     t   0 , j   \u2212   \u0394   0   + ( 2 \u2113 \u2212   \u03bb   0   \u2212 1 )   d   \u2212   .      Moreover, by induction on \u03bb \u2208 { 0 , \u2026 ,   \u03bb   0   } , it follows that all nodes ( \u03bb ,   j   \u2032   ) \u2208 { ( \u03bb , i + 1 ) , \u2026 , ( \u03bb , ( i + 1 +   \u03bb   0   \u2212 \u03bb ) mod  W ) } are triggered at time   t   \u03bb ,   j   \u2032     \u2264   max   i < j \u2264 i +   \u03bb   0   + 1   \u2061 {   t   0 , j   } + \u03bb   d   +   . Plugging in Eq. (6) implies  (7)    t   \u03bb ,   j   \u2032     \u2264   t   \u2113 , i   +   \u0394   0   \u2212 ( 2 \u2113 \u2212   \u03bb   0   \u2212 1 )   d   \u2212   + \u03bb   d   +     and hence      t     \u03bb   0   , i + 1   \u2264   t   \u2113 , i   +   \u0394   0   \u2212 ( 2 \u2113 \u2212   \u03bb   0   \u2212 1 )   d   \u2212   +   \u03bb   0     d   +   \u2264   t   \u2113 , i   +   \u0394   0   \u2212 ( \u2113 \u2212   \u03bb   0   \u2212 1 )   d   \u2212   ;    the second inequality holds by the definition of   \u03bb   0   , which implies   \u03bb   0     d   +   \u2264 \u2113   d   \u2212   .  Since Case 1 does not apply, we have   t   \u03bb , i + 1   >   t   \u03bb , i   +   d   +   for all   \u03bb   0   \u2264 \u03bb \u2264 \u2113 . We can hence use the same argument as used for deriving Eq. (5) to show that   t   \u2113 , i + 1   \u2264   t     \u03bb   0   , i + 1   + ( \u2113 \u2212   \u03bb   0   )   d   +   . It follows that     t   \u2113 , i + 1   \u2264   t     \u03bb   0   , i + 1   + ( \u2113 \u2212   \u03bb   0   )   d   +   \u2264   t   \u2113 , i   +   d   \u2212   + ( \u2113 \u2212   \u03bb   0   ) \u03b5 +   \u0394   0   =   t   \u2113 , i   +   d   \u2212   +  \u2308   \u2113 \u03b5    d   +    \u2309  \u03b5 +   \u0394   0   ,   where the last equality follows from Eq. (4).    Case 3 Non-V-shaped skews, triangular (Fig. 4b): Neither Case 1 nor Case 2 apply. In this case,   t   \u03bb , i + 1   >   t   \u03bb , i   +   d   +   for all \u03bb \u2208 {   \u03bb   0   , \u2026 , \u2113 } , and   p   left   i + 1 \u2192 ( \u2113 , i )   is a triangular path starting at node (   \u2113   \u2032   , i + 1 ) for some   \u2113   \u2032   <   \u03bb   0   \u2212 1 : By construction, the first (causal) link of   p   left   i + 1 \u2192 ( \u2113 , i )   is ( (   \u2113   \u2032   , i + 1 ) , (   \u2113   \u2032   + 1 , i ) ) , implying that node (   \u2113   \u2032   + 1 , i + 1 ) is triggered no later than time   t     \u2113   \u2032   + 1 , i   +   d   +   = max \u2061 {   t     \u2113   \u2032   , i + 1   +   d   +   ,   t     \u2113   \u2032   + 1 , i   +   d   +   } . Hence, since Case 1 does not apply, we must indeed have   \u2113   \u2032   + 1 <   \u03bb   0   .  Let (   \u03bb   0   ,   j   0   ) be the last node on the causal path   p   left   i + 1 \u2192 ( \u2113 , i )   that is still in layer   \u03bb   0   . Observe that   j   0   + r \u2212 u = i , where r (resp. u) is the number of rightward (resp. up-left) hops of   p   left   i + 1 \u2192 ( \u2113 , i )   after (   \u03bb   0   ,   j   0   ) . We apply Lemma 2 to the prefix \u03c0 of   p   left   i + 1 \u2192 ( \u2113 , i )   ending at (   \u03bb   0   ,   j   0   ) , i.e., set i : =   j   0   ,   i   \u2032   = i + 1 and r : = i + 1 \u2212   j   0   in this lemma, which yields     t     \u03bb   0   , i + 1   \u2264   t     \u03bb   0   ,   j   0     + ( i + 1 \u2212   j   0   )   d   \u2212   + (   \u03bb   0   \u2212   \u2113   \u2032   ) \u03b5 .   Since Case 1 does not apply, we can use the same induction as used before Eq. (5) to prove that   t   \u2113 , i + 1   \u2264   t     \u03bb   0   , i + 1   + ( \u2113 \u2212   \u03bb   0   )   d   +   . We thus obtain        t   \u2113 , i + 1     \u2264     t     \u03bb   0   ,   j   0     + ( i + 1 \u2212   j   0   )   d   \u2212   + (   \u03bb   0   \u2212   \u2113   \u2032   ) \u03b5 + ( \u2113 \u2212   \u03bb   0   )   d   +        =     t     \u03bb   0   ,   j   0     + ( \u2113 \u2212   \u03bb   0   + i + 1 \u2212   j   0   )   d   \u2212   + ( \u2113 \u2212   \u2113   \u2032   ) \u03b5 .      By construction,   p   left   i + 1 \u2192 ( \u2113 , i )   is of length 2 ( \u2113 \u2212   \u2113   \u2032   ) \u2212 1 and its prefix ending at node (   \u03bb   0   ,   j   0   ) is of length 2 (   \u03bb   0   \u2212   \u2113   \u2032   ) \u2212 ( i + 1 \u2212   j   0   ) . Therefore, the length of the suffix of   p   left   i + 1 \u2192 ( \u2113 , i )   starting at (   \u03bb   0   ,   j   0   ) is 2 ( \u2113 \u2212   \u03bb   0   ) + ( i \u2212   j   0   ) . As this suffix is a causal path, we have     t   \u2113 , i   \u2265   t     \u03bb   0   ,   j   0     + ( 2 ( \u2113 \u2212   \u03bb   0   ) + ( i \u2212   j   0   ) )   d   \u2212   .   Altogether, we arrive at        t   \u2113 , i + 1   \u2212   t   \u2113 , i     \u2264   ( \u2113 \u2212   \u2113   \u2032   ) \u03b5 \u2212 ( \u2113 \u2212   \u03bb   0   \u2212 1 )   d   \u2212        \u2264   \u2113 \u03b5 \u2212  (   \u2113 \u03b5    d   +    \u2212 1 )    d   \u2212        =     d   \u2212   +   \u2113   \u03b5   2      d   +         \u2264     d   +   +  \u2308   \u2113 \u03b5    d   +    \u2309  \u03b5      according to Eq. (4).  Since the claimed bound holds in each of the (exhaustive) cases considered, the proof of Lemma 4 is completed. \u2003\u25a1  We remark that it is possible to construct, by deterministically choosing appropriate link delays, worst-case executions that almost match the bounds established in Lemma 4; an example is shown in Fig. 5 .  In the proof of Lemma 4, in particular, in Case 2 (Fig. 4c), we silently assumed that the starting node ( 0 ,   j   0   ) of the left zig-zag path   p   left   i + 1 \u2192 ( \u2113 , i )   on the left side does not \u201ccollide\u201d (due to a wrap-around) with one of the slow nodes ( 0 , i + 1 ) , \u2026 , ( 0 , i +   \u03bb   0   + 1 ) on the right side. Whereas this is reasonable for wide grids, this is not realistic if W is small. Considering such a collision prohibits some of the worst-case scenarios considered, and hence possibly makes the worst-case skew result provided by Lemma 4 overly conservative. We therefore provide the following corollary, which takes this width constraint into account.    Corollary 1  Set  \u03b4 : =   d   \u2212   / 2 \u2212 \u03b5  . For each layer  \u2113 \u2208 { W , \u2026 , L }  and all  i \u2208 [ W ]  , it holds that    |   t   \u2113 , i   \u2212   t   \u2113 , i + 1   | \u2264 max \u2061  {   d   +   +  \u2308   W \u03b5    d   +    \u2309  \u03b5 ,   \u0394   \u2113 \u2212 W   +   d   +   \u2212 W \u03b4 }  .        Proof The proof is mostly analogous to the one of Lemma 4, with   \u2113   0   resp.   \u0394   0   replaced by \u2113 \u2212 W resp.   \u0394   \u2113 \u2212 W   . Case 2 needs a slightly different treatment, though, by assuming w.l.o.g. \u2113 = W and recomputing the bound Eq. (6) for all indices j \u2208 { i + 1 , i + 2 , \u2026 , i +   \u03bb   0   + 1 } as     t   \u2113 , i   \u2265   t   0 , j   \u2212   \u0394   0   \u2212 | j \u2212   j   0     |   W     d   \u2212   + ( 2 \u2113 + r )   d   \u2212   \u2265   t   0 , j   \u2212   \u0394   0   +   3 \u2113   d   \u2212    2  ,   where we conservatively set r = 0 and exploit that | j \u2212   j   0     |   W   \u2264 W / 2 = \u2113 / 2 in the second step. The analogon of Eq. (7) in the proof of Lemma 4, for \u03bb \u2208 { 0 , \u2026 ,   \u03bb   0   } and ( \u03bb ,   j   \u2032   ) \u2208 { ( \u03bb , i + 1 ) , \u2026 , ( \u03bb , ( i + 1 +   \u03bb   0   \u2212 \u03bb ) mod  W ) } , hence reads     t   \u03bb ,   j   \u2032     \u2264   t   \u2113 , i   +   \u0394   0   \u2212   3 \u2113   d   \u2212    2  + \u03bb   d   +     and thus leads to     t     \u03bb   0   , i + 1   \u2264   t   \u2113 , i   +   \u0394   0   \u2212   3 \u2113   d   \u2212    2  +   \u03bb   0     d   +   \u2264   t   \u2113 , i   +   \u0394   0   \u2212   \u2113   d   \u2212    2  ,   where we used that   \u03bb   0     d   +   \u2264 \u2113   d   \u2212   by the definition of   \u03bb   0   . Finally, re-using the result   t   \u2113 , i + 1   \u2264   t     \u03bb   0   , i + 1   + ( \u2113 \u2212   \u03bb   0   )   d   +   from the proof of Lemma 4, we arrive at        t   \u2113 , i + 1     \u2264     t   \u2113 , i   +   \u0394   0   + ( \u2113 \u2212   \u03bb   0   )   d   +   \u2212   \u2113   d   \u2212    2       \u2264     t   \u2113 , i   +   \u0394   0   + \u2113 \u03b5 +   d   +   \u2212   \u2113   d   \u2212    2       =     t   \u2113 , i   +   \u0394   0   +   d   +   \u2212 W \u03b4 ,      where we used Eq. (4) to derive the second inequality.  Checking the bounds from Case 1 and Case 3 in Lemma 4, we see that they are smaller or equal to the left term in the maximum on the right hand side of the claimed bound. The bound for the differently treated Case 2 matches the right term in the maximum. \u2003\u25a1  We are now ready to derive our main result, namely, bounds on the worst-case skews between neighbors.    Theorem 1 Skew bounds\u2014fault-free case    Suppose that  \u03b5 \u2264   d   +   / 7  . If    \u0394   0   = 0  , then the intra-layer skew    \u03c3   \u2113    (recall  Definition 3  ) is uniformly bounded by    d   +   + \u2308 W \u03b5 /   d   +   \u2309 \u03b5  for any  \u2113 \u2208 [ L + 1 ]  . In the general case,       \u2200 \u2113 \u2208 { 1 , \u2026 , 2 W \u2212 3 } :      \u03c3   \u2113   \u2264   d   +   + 2 W   \u03b5   2   /   d   +   +   \u0394   0   .     \u2200 \u2113 \u2208 { 2 W \u2212 2 , \u2026 , L } :      \u03c3   \u2113   \u2264   d   +   + \u2308 W \u03b5 /   d   +   \u2309 \u03b5 .       The inter-layer skew of layer  \u2113 \u2208 [ L + 1 ] \u2216 { 0 }  , for all  i \u2208 [ W ]  , is determined by         t   \u2113 \u2212 1 , i   \u2212   \u03c3   \u2113 \u2212 1   +   d   \u2212     \u2264    t   \u2113 , i    \u2264     t   \u2113 \u2212 1 , i   +   \u03c3   \u2113 \u2212 1   +   d   +   and        t   \u2113 \u2212 1 , i + 1   \u2212   \u03c3   \u2113 \u2212 1   +   d   \u2212     \u2264    t   \u2113 , i    \u2264     t   \u2113 \u2212 1 , i + 1   +   \u03c3   \u2113 \u2212 1   +   d   +   .           Proof Assume first that   \u0394   0   = 0 . For the sake of the argument, imagine that the HEX grid would start at layer \u2212 ( W \u2212 1 ) , where for all i \u2208 [ W ] and all \u2113 \u2208 { \u2212 ( W \u2212 1 ) , \u2026 , 0 } we would have that   t   \u2113 , i   = \u2113   d   +   . Clearly, starting from any execution on the actual grid, this would result in a feasible execution on the extended grid if we choose all link delays on the imagined links to be   d   +   . It follows that   \u0394   \u2113   = 0 for all \u2113 \u2208 { \u2212 ( W \u2212 1 ) , \u2026 , 0 } . From Lemma 3, we obtain that   \u0394   \u2113   \u2264 2 ( W \u2212 2 ) \u03b5 for all \u2113 \u2208 { 1 , \u2026 , L } (since we have negative layer indices until \u2212 ( W \u2212 1 ) , the lemma also applies to layers 1 , \u2026 , W \u2212 3 ). Now we apply Corollary 1 to all layers \u2113 \u2208 { 1 , \u2026 , L } , yielding that  (8)    \u03c3   \u2113   \u2264 max \u2061  {   d   +   +  \u2308   W \u03b5    d   +    \u2309  \u03b5 , W ( 2 \u03b5 \u2212 \u03b4 ) +   d   +   }  .   Since \u03b5 \u2264   d   +   / 7 , we have   d   \u2212   \u2265 6   d   +   / 7 and \u03b4 \u2265 2   d   +   / 7 and thus 2 \u03b5 \u2212 \u03b4 \u2264 0 ; the maximum in Eq. (8) is hence dominated by the first term. This proves the first statement.  Now consider the case where   \u0394   0   is arbitrary. The bound on   \u03c3   \u2113   for \u2113 \u2208 { 1 , \u2026 , 2 W \u2212 3 } follows from Lemma 4. For \u2113 \u2265 2 W \u2212 2 , observe first that we can apply Lemma 3 to all layers \u2113 \u2208 { W \u2212 2 , \u2026 , L } . Hence the same bound as in the previous case holds due to Corollary 1 applied to layers \u2113 \u2208 { 2 W \u2212 2 , \u2026 , L } .  The third inequality of the theorem holds since     t   \u2113 \u2212 1 , i   \u2212   \u03c3   \u2113 \u2212 1   +   d   \u2212   \u2264 min \u2061 {   t   \u2113 \u2212 1 , i   ,   t   \u2113 \u2212 1 , i + 1   } +   d   \u2212   \u2264   t   \u2113 , i   \u2264 max \u2061 {   t   \u2113 \u2212 1 , i   ,   t   \u2113 \u2212 1 , i + 1   } +   d   +   \u2264   t   \u2113 \u2212 1 , i   +   \u03c3   \u2113 \u2212 1   +   d   +   ;   the last inequality is proved analogously. \u2003\u25a1  We now extend the analysis from the fault-free case to the case of some faulty nodes in the grid. We still confine our examination to a single pulse; we will show later that the necessary preconditions for this type of analysis will eventually be satisfied, no matter what the initial states of the nodes are.  Since the communication structure of our algorithm is extremely simple, it is not difficult to understand the \u201coptions\u201d of Byzantine nodes for disrupting the system's operation within a single pulse, given that all correct nodes have cleared their memory and await the next pulse. If faulty nodes have the possibility to cause a correct node to generate a \u201cfalse\u201d pulse (i.e., to trigger without the immediate support of other correct nodes) this will clearly break our protocol: Once this happens, this will cause a chain reaction distributing the false pulse just like a correct one.  A similar problem arises if a correct node ( \u2113 , i ) has a second faulty neighbor (even if it is just a crash fault) and the two faults are not the left and right neighbors. If both faulty neighbors omit to send trigger messages, the node is not going to be triggered. However, if a Byzantine neighbor does send a trigger message, at some time after ( \u2113 , i ) has received a trigger message from another neighbor, but before the respective link timeout expires, it is immediately triggered. Hence, a Byzantine node can trigger ( \u2113 , i ) late in this case, again creating a \u201cfalse\u201d pulse.  Finally, if both the left and right neighbors of correct nodes may fail, we could have every second node in an entire layer failing, which would prevent the propagation of pulses if these nodes do not send messages. With these issues in mind, we arrive at the following sufficient condition for triggering all nodes exactly once per pulse. Condition 1 Fault separation   For each node, no more than one of its incoming links connects to a faulty neighbor.  We use the following definition to summarize skews.    Definition 4 For \u2113 \u2208 [ L + 1 ] \u2216 { 0 } , we say that layer \u2113 has skew at most \u03c3 if, for any two correct neighbors ( \u2113 , i ) and (   \u2113   \u2032   ,   i   \u2032   ) , |   t   \u2113 , i   \u2212   t     \u2113   \u2032   ,   i   \u2032     | \u2264 \u03c3 with \u2113 \u2212 1 \u2264   \u2113   \u2032   \u2264 \u2113 , and layer \u2113 \u2212 1 has skew at most \u03c3. The skew for layer 0 is given by the used clock generation scheme. If layer L has skew at most \u03c3 (i.e., any two correct neighbors have skew at most \u03c3) we say that the pulse has skew at most \u03c3.  If Condition 1 is satisfied and all correct nodes have cleared all memory flags before a pulse arrives, it is straightforward to derive a (fairly coarse) skew bound.    Lemma 5  Suppose all correct nodes in layer 0 send trigger messages during  [   t   min   ,   t   max   ]  ,  Condition 1  holds, and no correct node in any layer    \u2113   \u2032   \u2208 [ \u2113 + 1 ]  , where  \u2113 \u2208 [ L + 1 ]  , memorizes a trigger message from another correct node or is sleeping at time    t   min   +   \u2113   \u2032     d   \u2212    . With    f   \u2113   \u2264 f  denoting the number of layers    \u2113   \u2032   \u2208 [ \u2113 ]  containing some faulty node, all correct nodes on layer \u2113 are triggered at times within  [   t   min   + \u2113   d   \u2212   ,   t   max   + ( \u2113 +   f   \u2113   )   d   +   ]  . In particular, the pulse has skew at most  \u03c3 ( f ) <   t   max   \u2212   t   min   + \u03b5 L + f   d   +    .     Proof By induction on \u2113. Clearly the statement is true for \u2113 = 0 . The step is trivial for the lower bound, since Condition 1 implies that each node needs to receive a trigger message from a correct neighbor to be triggered, which is delayed by at least   d   \u2212   time. If the upper bound is satisfied for \u2113 \u2208 [ L ] and all nodes in layer \u2113 are correct, certainly all nodes in layer \u2113 + 1 are triggered within   d   +   time. If there is a faulty node in layer \u2113, the upper bound allows for 2   d   +   time for all nodes on layer \u2113 + 1 to be triggered. If a correct node on layer \u2113 + 1 has a faulty neighbor on layer \u2113, Condition 1 necessitates that either its right or its left neighbor is correct and has only correct neighbors on layer \u2113; the claim hence follows, as the node will be left- or right-triggered within 2   d   +   time. \u2003\u25a1  This lemma shows that even in the presence of multiple faults the time to complete a pulse increases only moderately. Thus, increasing the time between pulses (originating from layer 0) accordingly will maintain a clean separation of pulses.  While Lemma 5 guarantees bounded skew and suggests that actually \u03c3 ( f ) =   \u03c3   \u2113   + O ( f   d   +   ) , where   \u03c3   \u2113   is the fault-free layer \u2113 intra-layer skew given in Theorem 1, a more detailed reasoning is required to prove such a bound. Unfortunately, the number of cases that needs to be considered in a formal proof explodes quickly. A large number of cases needed to be examined already in the fault-free case, and dealing with just a single fault became sufficiently tedious for being relegated to Appendix A. Informally, the reasoning employs the following arguments: For a Byzantine faulty node, there are only two options for increasing the skew between neighbors: (i) \u201cshortcut\u201d a causal path to the fast node and (ii) refrain from triggering nodes to inhibit the propagation of the pulse to the slow node.  Dealing with (i) is straightforward: If during the construction of a causal path we run into a Byzantine node, we follow the other incoming causal link of the predecessor node instead, thereby avoiding the Byzantine node, and resume the construction. This is particularly simple for the left zig-zag paths used in Cases 2 and 3 of Lemma 4; see Fig. 6 for an example of how this might look like, where the faulty node is located at ( \u2113 \u2212 1 ,   j   0   ) . When dealing with (ii), the situation is similar. Instead of circumventing faulty nodes in the construction of a causal path, we now need to avoid relying on them to trigger correct nodes. Fig. 6 also gives an example for this, for a faulty node at ( 1 , i + 1 ) . Consult Appendix A for the detailed discussion of these (and similar) cases.  Consequently, in order to increase skews significantly, several faulty nodes need to be in a region that causally affects two neighbors. In a setting where delays are random, it seems unlikely that the elaborate patterns required for large skews will arise, in particular if faults are not in close vicinity of each other. The simulations in Section 4 support this view, showing moderate increase of skews despite a significant number of faults.  We point out that crash failures, where nodes simply cease operating, are more benign. Instead of breaking the entire system, two adjacent crash failures on some layer just effectively crash their common neighbor in the layer above and affect the skews of surrounding nodes. We refer to [32] for simulations concerning crash faults.   Self-stabilization is the ability of the system to recover from an unbounded number of transient faults [18], which may put the system into an arbitrarily erroneous state. When transient faults cease, the system will resume normal operation within a bounded stabilization time\u2014ideally even in the presence of a bounded number of persistent faults. In this section, we will show that HEX is self-stabilizing even in the presence of up to f Byzantine faulty nodes that satisfy Condition 1; under the assumption that correct nodes faithfully execute the HEX algorithm, the pulse generation will eventually work as specified in Lemma 5, even when all nodes start from arbitrary internal states. Note that this can also be guaranteed for the pulse generation at layer 0, by using a self-stabilizing and Byzantine fault-tolerant algorithm like   FATAL   +    [31]; the details are outside the scope of this paper, however.  The analysis in Section 3.1 assumed that   T   link   \u2212   ,   T   sleep   \u2212   , and the time between pulses are sufficiently large for all correct nodes to clear their memory and complete their sleeping period before the next pulse arrives. In the previous section, we argued that faulty nodes have an adverse, but bounded, effect on the skew and the time to complete a pulse. To ensure self-stabilization, we account for this by some additional slack in the time between the   k   th   and   ( k + 1 )   th   pulses, enabling nodes to reach consistent states even when the initial states are arbitrary. Any choice of parameters thus represents a trade-off between the frequency at which pulses can be issued and the fault-tolerance properties of the system. The following condition provides conservative bounds for the parameters   T   link   \u2212   ,   T   link   +   ,   T   sleep   \u2212   , and   T   sleep   +   , as a function of the number of faults and the inaccuracy of the implementation's local time measurements. We stress that, to ensure self-stabilization, the timers must be designed so that they expire within   T   sleep   +   and   T   link   +   time, respectively, even when started from an arbitrary internal state.    Condition 2 Timing constraints   For k \u2208 N , define     t   min   ( k )   : =  min    i \u2208 [ W ]     ( 0 , i )  correct     \u2061  {   t   0 , i   ( k )   }   and    t   max   ( k )   : =  max    i \u2208 [ W ]     ( 0 , i )  correct     \u2061  {   t   0 , i   ( k )   }  .   An execution of Algorithm 1 has pulse separation time  S , if, for all k \u2208 N , it holds that   t   min   ( k + 1 )   \u2265   t   max   ( k )   + S . For a given number of Byzantine faults f in the grid with stable skew  \u03c3 ( f ) , we define        T   link   \u2212   ( f )   : =   \u03c3 ( f ) + \u03b5       T   link   +   ( f )   : =   \u03d1   T   link   \u2212   ( f )       T   sleep   \u2212   ( f )   : =   2   T   link   +   ( f ) + 2   d   +         T   sleep   +   ( f )   : =   \u03d1   T   sleep   \u2212   ( f )     S ( f )   : =     T   sleep   \u2212   ( f ) +   T   sleep   +   ( f ) + \u03b5 L + f   d   +   .      Here, \u03d1 \u2265 1 bounds the maximum clock drift, in the sense that   t   \u2032   \u2212 t \u2264   T   \u2032   \u2212 T \u2264 \u03d1 (   t   \u2032   \u2212 t ) for all real-times   t   \u2032   \u2265 t with clock readings   T   \u2032   , T .  Before we can cast the algorithm's self-stabilization properties into a theorem, we need to specify what it means for the HEX pulse propagation to have stabilized up to a certain layer. Definition 5 Stabilized pulse propagation   For an execution of Algorithm 1 on the HEX grid, we say that layer  \u2113 \u2208 [ L + 1 ]  is stable with skew at most \u03c3 in pulse k, if:  \u2022 All layers   \u2113   \u2032   \u2208 [ \u2113 ] are stable with skew at most \u03c3 in pulse k;  Node ( \u2113 , i ) , i \u2208 W , is not sleeping at time   t   min   ( k )   + \u2113   d   \u2212   , and it does not memorize any trigger messages from correct neighbors at this time;  Layer \u2113 has skew at most \u03c3 in pulse k.   Suppose that, given values f and  \u03c3 ( f )  , an execution of  Algorithm 1  satisfies the following prerequisites:   \u2022  There are at most f Byzantine faulty nodes satisfying  Condition 1  .    The stable skew is at most  \u03c3 ( f )  .    The parameters    T   link   \u2212    ,    T   link   +    ,    T   sleep   \u2212    , and    T   sleep   +    in  Algorithm 1  are chosen in accordance with  Condition 2  .    The pulse separation time is larger than  S ( f )  , as specified by  Condition 2  .   Note that this, in particular, implies that all correct neighbors will satisfy the skew bound \u03c3 ( f ) in all pulses k > L . In order to prove the theorem, we first show a helper statement saying that if all layers up to layer \u2113 are stable in some pulse, they will satisfy the claim of the theorem in all subsequent pulses. Lemma 6  Assume that the preconditions of  Theorem 2  are satisfied and that all layers  \u2113 \u2208 [ L + 1 ]  ,    \u2113   \u2032   \u2208 [ \u2113 + 1 ]  , are stable with skew at most  \u03c3 ( f )  in pulse  k \u2208 N  . Then, these layers are also stable with skew at most  \u03c3 ( f )  in pulse  k + 1  , and for each correct node  ( \u2113 , i )  , there is a unique triggering time    t   \u2113 , i   ( k )    during  [   t   min   ( k )   + \u2113   d   \u2212   ,   t   min   ( k + 1 )   + \u2113   d   \u2212   )  .     Proof Since we have that all layers   \u2113   \u2032   \u2208 [ \u2113 + 1 ] are stable, Lemma 5 shows that all nodes in these layers are triggered during [   t   min   ( k )   +   \u2113   \u2032     d   \u2212   ,   t   max   ( k )   + (   \u2113   \u2032   +   f     \u2113   \u2032     )   d   +   ] . For each node (   \u2113   \u2032   , i ) in such a layer, let   t     \u2113   \u2032   , i   ( k )   be the minimal such triggering time (we still need to establish that there is only one). Since the stable skew is at most \u03c3 ( f ) , for any node (   \u2113   \u2032   , i ) with 0 \u2260   \u2113   \u2032   \u2264 \u2113 , the triangle inequality yields that its correct neighbors on layers   \u2113   \u2032   and   \u2113   \u2032   \u2212 1 trigger within 2 \u03c3 ( f ) of each other. Hence, all trigger messages from correct neighbors are received within a time window of duration 2 \u03c3 ( f ) + \u03b5 . We have   T   sleep   \u2212   ( f ) > 2   T   link   \u2212   ( f ) > 2 \u03c3 ( f ) + \u03b5 , implying that nodes will not memorize any late pulse k trigger messages from correct neighbors after waking up. We thus conclude that, for each node (   \u2113   \u2032   , i ) ,   t     \u2113   \u2032   , i   ( k )   <   t   min   ( k + 1 )   +   \u2113   \u2032     d   \u2212   is unique. With   T   sleep   : =   T   sleep   +   ( f ) +   T   sleep   \u2212   ( f ) , our assumptions yield     t   max   ( k )   \u2264   t   min   ( k + 1 )   \u2212 S ( f ) <   t   min   ( k + 1 )   \u2212   T   sleep   \u2212 \u03b5 L \u2212 f   d   +   .   Hence, the upper bound on the pulse k triggering times of layer   \u2113   \u2032   nodes established in Lemma 5 leads to  (9)       t     \u2113   \u2032   , i   ( k )     \u2264     t   max   ( k )   + (   \u2113   \u2032   +   f     \u2113   \u2032     )   d   +        <     t   min   ( k + 1 )   \u2212   T   sleep   \u2212 \u03b5 L \u2212 f   d   +   + (   \u2113   \u2032   +   f     \u2113   \u2032     )   d   +        \u2264     t   min   ( k + 1 )   \u2212   T   sleep   +   \u2113   \u2032     d   \u2212   .      We thus observe that no node will be sleeping or have memorized any trigger messages from other correct nodes at time   t   min   ( k + 1 )   +   \u2113   \u2032     d   \u2212   . Since we assumed that \u03c3 ( f ) is a bound on the stable skew, the requirements of Definition 5 are met for pulse k + 1 and all layers   \u2113   \u2032   \u2208 [ \u2113 + 1 ] , as claimed. \u2003\u25a1  With this lemma, the proof of Theorem 2 boils down to showing that if layer \u2113 is stable in pulse k, then layer \u2113 + 1 is stable in pulse k + 1 .    Proof of Theorem 2 We prove the theorem by induction on \u2113, where the hypothesis is that the claims of the theorem are satisfied by all layers   \u2113   \u2032   \u2208 [ \u2113 + 1 ] . For \u2113 = 0 , the statement is trivial. For the step from \u2113 to \u2113 + 1 , repeated use of Lemma 6 reveals that it is sufficient to show that layer \u2113 + 1 is stable in pulse \u2113 + 2 .  By the induction hypothesis and Lemma 5, no correct node in layer \u2113 sends trigger messages during [   t   max   ( \u2113 + 1 )   + ( \u2113 + f )   d   +   ,   t   min   ( \u2113 + 2 )   + \u2113   d   \u2212   ] . Using exactly the same derivation as for Eq. (9) in the proof of Lemma 6, we find that any triggering message originating in a correct layer \u2113 node must have arrived at any correct layer \u2113 + 1 node before time t : =   t   min   ( \u2113 + 2 )   \u2212 (   T   sleep   +   ( f ) +   T   sleep   \u2212   ( f ) ) + ( \u2113 + 1 )   d   \u2212   . We will complete the proof by showing that this entails that correct nodes ( \u2113 + 1 , i ) will neither sleep nor memorize trigger messages from correct nodes at time   t   min   ( \u2113 + 2 )   + ( \u2113 + 1 )   d   \u2212   .  To this end, suppose that starting from the above time t, nodes on layer \u2113 + 1 do not receive trigger messages from correct nodes on the previous layer. By Algorithm 1, nodes will forget messages that arrived more than   T   link   +   ( f ) time ago. Thus, the latest time when a correct node ( \u2113 + 1 , i ) in layer \u2113 + 1 could be triggered due to a remembered message from some correct neighbor on layer \u2113 is smaller than t +   T   link   +   ( f ) .  Hence, consider the case that ( \u2113 + 1 , i ) has a faulty neighbor on layer \u2113. W.l.o.g., assume that the faulty neighbor is node ( \u2113 , i + 1 ) (the other case is symmetric). By the above reasoning, ( \u2113 + 1 , i ) can only be left-triggered at or after time t +   T   link   +   ( f ) , which in addition requires a memorized trigger message from ( \u2113 + 1 , i ) . Thus, if neither ( \u2113 + 1 , i ) nor ( \u2113 + 1 , i + 1 ) are triggered during [ t \u2212   d   +   , t +   T   link   +   ( f ) ) , neither node can be triggered anymore: Condition 1 guarantees that both nodes have no other faulty neighbor than ( \u2113 , i + 1 ) , and the above reasoning applies also to ( \u2113 + 1 , i ) .  Therefore, assume that one of them, say ( \u2113 + 1 , i + 1 ) , is triggered at time   t   \u2113 + 1 , i + 1   \u2208 [ t \u2212   d   +   , t +   T   link   +   ( f ) ) . It will not wake up (and therefore not be triggered again) before time   t   \u2113 + 1 , i + 1   +   T   sleep   \u2212   ( f ) . Node ( \u2113 + 1 , i ) receives the trigger message from ( \u2113 + 1 , i + 1 ) by time   t   \u2113 + 1 , i + 1   +   d   +   and therefore either (a) forgets it by time   t   \u2113 + 1 , i + 1   +   T   link   +   ( f ) +   d   +   or (b) is triggered during [   t   \u2113 + 1 , i + 1   ,   t   \u2113 + 1 , i + 1   +   T   link   +   ( f ) +   d   +   ) . If ( \u2113 + 1 , i ) is triggered, its corresponding trigger message to ( \u2113 + 1 , i + 1 ) arrives by time   t   \u2113 + 1 , i + 1   +   T   link   +   ( f ) + 2   d   +   \u2264   t   \u2113 + 1 , i + 1   +   T   sleep   \u2212   ( f ) . This message thus arrives at ( \u2113 + 1 , i + 1 ) before it wakes up again. When ( \u2113 + 1 , i + 1 ) wakes up, it clears its memory and will not be re-triggered before ( \u2113 + 1 , i ) is triggered again (or the next pulse arrives on layer \u2113). But ( \u2113 + 1 , i ) cannot be triggered again: If it was not triggered (Case (a)), it forgot any previous trigger messages, and if it was (Case (b)), it clears its memory upon waking up. Consequently, ( \u2113 + 1 , i + 1 ) cannot be triggered again either.  Overall, no node on layer \u2113 + 1 is triggered after time   t   \u2113 + 1 , i + 1   +   T   link   +   ( f ) \u2264 t + 2   T   link   +   ( f ) +   d   +   or receives trigger messages from correct nodes after time t + 2   T   link   +   ( f ) + 2   d   +   \u2264 t +   T   sleep   \u2212   ( f ) (until time   t   min   ( k + 1 )   + ( \u2113 + 1 )   d   \u2212   ). Hence, all nodes are awake by time t +   T   sleep   \u2212   ( f ) +   T   sleep   +   ( f ) > t +   T   sleep   \u2212   ( f ) +   T   link   +   ( f ) and have forgotten all spurious messages. By the previous observations, this concludes the proof. \u2003\u25a1  As mentioned earlier, the analytic results obtained in the previous sections are limited to worst-case skews. Hence, we conducted extensive simulation experiments to complement them with representative statistical data. This data reveals the following major facts about HEX:  (1)  Average skews considerably smaller than worst-case. The quite fancy scenarios required for establishing the worst-case skews in Theorem 1 already suggested that they are very unlikely to occur in practice. Indeed, we were not able to generate neighbor skews that came close to the worst case under uniformly and independently distributed link delays.   Small, localized fault effects. As argued in Section 3.3, HEX should implicitly confine the effects created by a faulty node to a small neighborhood. Our simulation results revealed that faults typically affect direct neighbors only, and become invisible after one additional hop. This is true even for clustered crash faults and multiple (separated) Byzantine faults.   Stabilization times much smaller than guaranteed by theoretical analysis. The layer-wise stabilization used for bounding the worst-case stabilization time in Section 3.3 assumes an involved worst-case scenario on each layer, which appears to be very unlikely in practice. Simulations of the original version [33] of the HEX algorithm already revealed typical stabilization times that are much smaller than the predicted worst case. The link timeouts added in Algorithm 1 cause HEX to reliably stabilize within two clock pulses, even in scenarios with multiple faults.  Our simulation framework has been built around Mentor Graphics\u00ae ModelSim 10.1d, which allows accurate digital timing simulations of circuit designs specified in VHDL (Very High Speed Integrated Circuit Hardware Description Language). It is used to simulate an entire HEX grid, which consists of multiple instances of a VHDL implementation of Algorithm 1 embedded into a custom testbench. The latter has the following purposes:  (1) Set the grid size and instantiate the corresponding number of nodes as well as interconnecting wires.  Provide the layer 0 clock sources (i.e., generate the clock pulse of node ( 0 , i ) , i \u2208 [ W ] ) at time   t   0 , i , \u03c1   in simulation run \u03c1, with some pre-selected skews. Clock sources for a single pulse and for multiple pulses per run are supported.  Control the individual link delays during the simulation. Both random delays (uniform within [   d   \u2212   ,   d   +   ] ) and deterministic delays are supported.  Control fault injection during the simulation: links can be declared correct, Byzantine (choose output constant 0 resp. 1 corresponding to no resp. fast triggering), or fail-silent (output constant 0); declaring a node Byzantine or fail-silent is equivalent to doing so for each of its outgoing links. The selection of faulty nodes and/or links can be done deterministically or randomly in different simulation runs \u03c1, but remains fixed for all pulses generated in a multi-pulse simulation run \u03c1.  The VHDL implementation of Algorithm 1 consists of a few fairly simple design entities only: An asynchronous state machine, a threshold gate, sleep and link timers driven by start/stoppable oscillators, and resettable memory flags. The asynchronous state machine, shown in Fig. 7a , consists only of three states, which are visited cyclically: In the (initial) ready state, it waits for the trigger condition in Algorithm 1 to become true. The state machine then proceeds to the firing state, where it emits a pulse, and then moves into the sleeping state. One resettable memory flag per incoming link is used to memorize the occurrence of a pulse from the respective neighbor. It is reset when the state machine takes the transition from the sleeping state to ready, or when the respective link timer generates a timeout. Fig. 7b provides the simple state machine for the memory flag: Starting from the (initial) ready state, it waits for the reception of a trigger message, which results in a transition to the state memorize and the setting of the corresponding memory flag. After the timeout   T   link   , the memory flag is reset and the state machine returns to the ready state.  The implementation of the above state machine is completely asynchronous and has been generated using the Petrify tool [35]; the designs of the timers, start/stoppable oscillators, and memory-flags are based on the designs provided in [36]. The complete HEX node was synthesized with Synopsys\u00ae Design Compiler version C-2009.06-SP4, using the UMC 90 nm standard cell library [37]. Note that we had to augment this library by a custom Muller C-Gate [38] developed in the context of the DARTS project [30,39]. The detailed timing analysis of the HEX node implementation revealed an end-to-end switching delay, without wire delays, in the interval [ 0.161 , 0.197 ]  ns .  Although HEX is, by design, metastability-free in the absence of failures, we cannot rule out the possibility that faulty nodes cause metastable upsets [40] of state-holding devices such as memory flags. However, as laid out in more detail in [36], the probability that a faulty node produces a signal transition within the picosecond-range window of vulnerability is extremely small and can be further decreased by means of synchronizers [11] or elastic pipelines [38]. In our simulations, we may hence safely exclude metastability-inducing behavior.  Using our testbed, we conducted the following types of simulation experiments:   (A) Statistical evaluation of the neighbor skews. These experiments require simulation runs involving only a single pulse propagating through the HEX grid. The primary quantities of interest in simulation run \u03c1 are:  \u2022 the (absolute) skews |   t   \u2113 , i , \u03c1   \u2212   t   \u2113 , i \u2212 1 , \u03c1   | between neighbors ( \u2113 , i ) and ( \u2113 , i \u2212 1 ) in the same layer \u2113,  the (signed) skews   t   \u2113 , i , \u03c1   \u2212   t   \u2113 \u2212 1 , i , \u03c1   and   t   \u2113 , i , \u03c1   \u2212   t   \u2113 \u2212 1 , i + 1 , \u03c1   of every node ( \u2113 , i ) , \u2113 > 0 , relative to its direct layer \u2113 \u2212 1 neighbors ( \u2113 \u2212 1 , i ) resp. ( \u2113 \u2212 1 , i + 1 ) .  For op \u2208 { avg ,   q   95   , max \u2061 } , we define the average, 95%-quantile, and maximum (absolute)  \u2022  layer \u2113 intra-layer skew in run \u03c1:   \u03c3   \u2113 , \u03c1   op   : =   op   i \u2208 [ W ]   { |   t   \u2113 , i , \u03c1   \u2212   t   \u2113 , i + 1 , \u03c1   | } ;   intra-layer skew in run \u03c1:   \u03c3   \u03c1   op   : =   op   i \u2208 [ W ] , \u2113 \u2208 [ L + 1 ] \u2216 { 0 }   { |   t   \u2113 , i , \u03c1   \u2212   t   \u2113 , i + 1 , \u03c1   | } ;   intra-layer skew in simulation set R:   \u03c3   op   : =   op   i \u2208 [ W ] , \u2113 \u2208 [ L + 1 ] \u2216 { 0 } , \u03c1 \u2208 R   { |   t   \u2113 , i , \u03c1   \u2212   t   \u2113 , i + 1 , \u03c1   | } .   inter-layer skew between layer \u2113 and  \u2113 \u2212 1  in run \u03c1:     \u03c3   \u02c6     \u2113 , \u03c1   op   : =   op   i \u2208 [ W ]      T   \u2113 , i , \u03c1   ;   inter-layer skew in run \u03c1:     \u03c3   \u02c6     \u03c1   op   : =   op   i \u2208 [ W ] , \u2113 \u2208 [ L + 1 ] \u2216 { 0 }      T   \u2113 , i , \u03c1   ;   inter-layer skew in simulation set R:     \u03c3   \u02c6     op   : =   op   i \u2208 [ W ] , \u2113 \u2208 [ L + 1 ] \u2216 { 0 } , \u03c1 \u2208 R      T   \u2113 , i , \u03c1   .   (B) Statistical evaluation of the stabilization time. These experiments require multiple pulses. Essentially, the system is started, with every node in an arbitrary state, and then attempts to forward a sequence of pulses generated at layer 0 (with bounded skew and a certain separation time). Using post-processing of the recorded triggering times, we compute the stabilization time as the number of pulses needed for the intra- and inter-layer skews to persistently fall below a layer-dependent threshold.  Both types of experiments were performed with and without faulty nodes of different types. Note that the triggering times of faulty nodes are of course not considered when computing the inter- and intra-layer skews.  We conducted a suite of simulations that complement the analytic intra- and inter-layer worst-case skew bounds given in Theorem 1 by statistical data. First, Fig. 8 resp. Fig. 9 show a 3D plot of a typical pulse propagation wave in a fault-free grid with L = 50 and W = 20 , end-to-end delays in [ 7.161 , 8.197 ]  ns ( \u03b5 = 1.036  ns ), and layer 0 skews all 0 resp. ramping up/down by   d   +   . The end-to-end delays result from combining the assumed wire and routing delays with the switching delay bounds. The latter were determined by the ModelSim timing analysis of the HEX node to lie within [ 0.161 , 0.197 ]  ns . For the wire and routing delays, we more or less arbitrarily assumed a value within [ 7 , 8 ]  ns . Since the absolute values do not really matter for our simulations, our choice just reflects the facts that (i) communication delays dominate switching delays and (ii) that the delay uncertainty \u03b5 is not too large compared to   d   \u2212   in modern hardware devices. Throughout this section, we hence assume delay values that are uniformly distributed within [   d   \u2212   ,   d   +   ] = [ 7.162 , 8.197 ]  ns . The grid (sliced between width W \u2212 1 and 0 \u2261 W for readability, and truncated to the first 30 layers) lies in the ( \u2113 \u2208 [ L + 1 ] , i \u2208 [ W ] ) plane and the z-dimension shows the triggering time   t   \u2113 , i   of the corresponding node ( \u2113 , i ) . To further improve readability, we connected all points ( \u2113 , i ,   t   \u2113 , i   ) and ( \u2113 , i + 1 ,   t   \u2113 , i + 1   ) , i \u2208 { 0 , \u2026 , W \u2212 2 } . It is apparent that the wave propagates evenly throughout the grid, nicely smoothing out the initial skew differences.   Table 1 shows average (   \u03c3   avg   ) , 95%-quantile (   \u03c3     q   95     ) , and maximal (   \u03c3   max   ) intra-layer and minimal (     \u03c3   \u02c6     min   ) , 5%-quantile (     \u03c3   \u02c6       q   5     ) , average (     \u03c3   \u02c6     avg   ) , 95%-quantile (     \u03c3   \u02c6       q   95     ) , and maximal (     \u03c3   \u02c6     max   ) inter-layer skews, respectively, in the absence of faulty nodes and taken over all nodes and 250 simulation runs, in the setting described above.  Four different choices for the layer 0 skews between neighbors were used: The triggering times of the layer 0 nodes   t   0 , i   are (i) all 0 (resulting in   \u03c3   0   = 0 and skew potential   \u0394   0   = 0 ), (ii) uniformly in [ 0 ,   d   \u2212   ] (i.e.,   \u03c3   0   \u2248   d   \u2212   and   \u0394   0   = 0 ), (iii) uniformly in [ 0 ,   d   +   ] (i.e.,   \u03c3   0   \u2248   d   +   and   \u0394   0   \u2248 \u03b5 ), and (iv) ramping-up/down by   d   +   :   t   0 , i + 1   =   t   0 , i   +   d   +   for 0 \u2264 i < W / 2 and   t   0 , i + 1   =   t   0 , i   \u2212   d   +   for W / 2 \u2264 i < W \u2212 1 , i.e.,   \u03c3   0   =   d   +   and   \u0394   0   \u2248 W \u03b5 / 2 = 10.36 . Note that (iii) resp. (iv) reasonably model the average case and worst-case input provided by a layer 0 clock generation scheme with neighbor skew bound   d   +   , respectively.  Inspecting Table 1 reveals that not a single instance in the collected data showed a skew   \u03c3   max   >   d   +   = 8.197  ns resp.     \u03c3   \u02c6     max   > 2   d   +   = 16.394  ns . In scenarios (i) to (iii),     \u03c3   \u02c6     min   \u2248   d   \u2212   , i.e., all nodes were always triggered by their lower neighbors (obviously, this latter property is violated in scenario (iv) due to the excessive initial skews). A comparison with the worst-case results of Theorem 1, which bound   \u03c3   max   \u2264 21.63  ns and [     \u03c3   \u02c6     min   ,     \u03c3   \u02c6     max   ] \u2286 [ \u2212 14.47 , 29.83 ]  ns for scenarios (i) and (ii), reveals a much better typical skew in every scenario.  The histograms of the skew distributions in scenario (i) are shown in Fig. 10 ; scenarios (ii) and (iii) look similar. One observes a sharp concentration with an exponential tail. Only in scenario (iv), as already indicated by the large values of   q   95   in Table 1, there is a visible cluster near the end of the tail that is again caused by the large initial skews, see Fig. 11 .  Given the considerable differences between the minimum (     \u03c3   \u02c6     min   ) and maximum (     \u03c3   \u02c6     max   ) inter-layer skew in Table 1, in conjunction with its non-zero bias, the question of layer-dependence arises. Fig. 12 provides     \u03c3   \u02c6     \u2113   min   ,     \u03c3   \u02c6     \u2113   avg   and     \u03c3   \u02c6     \u2113   max   , along with their standard deviations, over the layers \u2113 \u2208 [ 30 ] \u2216 { 0 } in case of scenario (iii) resp. (iv). The diagrams reveal that the fairly discrepant skews observed in lower layers start to smooth out after layer W \u2212 2 , in accordance with Lemma 3, which shows that the behavior observed in Fig. 9 is very typical. To avoid cluttering the diagrams, we omitted     \u03c3   \u02c6     \u2113     q   5     and     \u03c3   \u02c6     \u2113     q   95     , which are close to     \u03c3   \u02c6     \u2113   min   resp.     \u03c3   \u02c6     \u2113   max   .  Next, we back up the results of our analysis in Section 3.3: We consider f uniformly placed failures under the constraint that Condition 1 holds. In each run, each Byzantine node randomly selects its behavior on each outgoing link as either constant 0 (fail-silent) or constant 1. A typical pulse with a single faulty node ( 1 , 19 ) , marked as a red dot, is shown in Fig. 13 ; Fig. 14 depicts a sample scenario with 5 Byzantine faulty nodes.  In Table 2 , we list the statistical results for f = 1 . One observes that the behavior for scenarios (i) to (iii) is very similar, hence we will showcase the main points by examining scenario (iii) and (iv) more closely.  In Figs. 15a resp. 15c, we show box-plots of minimum, 5 % -quantile, average, 95 % -quantile, and maximum intra- resp. inter-layer skews from 250 runs with f \u2208 [ 6 ] faults for scenario (iii). 9   9 Note that for the absolute values of the intra-layer skew, the minimal and 5 % -quantile values are close to zero and, thus, of little relevance. A comparison of values f > 0 with f = 0 reveals that skews increase moderately. In particular, the skews increase substantially slower than the derived worst-case bound of roughly 5 f   d   +   . Furthermore, Figs. 15b and 15d show the same data, except that, in addition to the faulty nodes themselves, also their outgoing 1-hop neighbors are discarded from the data set ( h = 1 ). Here, a comparison of the case f = 0 and any f > 0 reveals that all fault effects have essentially disappeared or are mitigated notably, which confirms that HEX exhibits strong fault-locality. Concerning fail-silent nodes, all results are qualitatively similar, albeit with smaller skews.   Fig. 16 gives the same plots for scenario (iv). Apart from the expected increase in skews, we observe two points worth mentioning. First, a single fault essentially causes the \u201cworst-case\u201d skew. This demonstrates that, as already indicated by scenario (iii), skew effects of multiple faults do not accumulate, or do so in a very limited way. Second, the maximal intra-layer skews typically exceed the inter-layer skews. An explanation for this behavior is provided in Fig. 17 : Intuitively, for \u201cramped\u201d triggering times generated at layer 0, the pulse propagates \u201cdiagonally\u201d (cf. Fig. 9) instead of \u201cvertically\u201d (= layer by layer). This limits the power of the HEX grid to mitigate Byzantine behavior, as it is implicitly optimized for propagating pulse waves vertically.  We now present the results of the multi-pulse simulations conducted for evaluating stabilization time statistics. The same scenarios as in our single-pulse experiments were used here. For the timeouts and the pulse separation time S , we used nominal values that are compatible with the (scenario-dependent) maximum skew observed for f \u2208 [ 6 ] Byzantine or fail-silent nodes. These skews where determined via the previous simulations, plus a slack of   d   +   accounting for the fact that we work with a statistical sample showing an exponential tail. Timeouts and pulse separation times were computed according to (a modified 10   10  Condition 2 does not take into account that triggering signals in our HEX implementation have non-zero duration, resulting in slightly increased values. version of) Condition 2, assuming \u03d1 = 1.05 . The results are shown in Table 3 .  For each scenario, fault-number, and fault-type, we executed 250 simulation runs. For each run, f faulty nodes were placed uniformly at random under the constraint that Condition 1 held. Then, starting with all non-faulty nodes in random initial states, 10 consecutive pulses were generated, where placement and behavior of faulty nodes remained fixed during an individual run. For each run \u03c1, the firing times   t   \u2113 , i , \u03c1   ( k )   of all pulses 1 \u2264 k \u2264 10 were recorded; thanks to the large pulse separation times, unambiguously assigning a corresponding pulse number to a triggering time (after initial spurious triggering events ceased) was easy.  Due to the fact that our simulations only cover the first 10 pulses, it could occur that some runs do not stabilize (yet). Even worse, we cannot rule out the possibility that a run which seems stable violates the skew bounds in some later pulse. However, our actual experiments showed that non-stabilizing runs occur only in scenarios in which the a priori chosen skew bound \u03c3 ( f , \u2113 ) was smaller than the maximal skews reported in Table 2, i.e., where \u03c3 ( f , \u2113 ) was too small. We are hence confident that our stabilization time estimates can be considered representative for realistic skew bounds.  Our stabilization time estimate for each run is computed (off-line) as the minimal pulse k with the property that the maximal layer \u2113 intra- resp. inter-layer skew, for every layer \u2113 \u2208 [ L + 1 ] , is below the a priori chosen skew bound   \u03c3   \u02c6   ( f , \u2113 ) resp. \u03c3 ( f , \u2113 ) . As the former directly depends on the latter (cf. Theorem 1), we used 4 different choices C \u2208 { 0 , 1 , 2 , 3 } for the skew bound, obtained by setting \u03c3 ( f , \u2113 ) = ( 4 \u2212 C )   d   +   for C \u2208 { 1 , 2 , 3 } resp. the very conservative skew bounds resulting from Lemma 5 for C = 0 .   Fig. 18a resp. Fig. 19a shows both the average and the average + standard deviation of the stabilization times for scenario (iii) resp. (iv) for Byzantine faults. Similarly, Fig. 18b resp. Fig. 19b shows scenario (iii) resp. (iv) in case of fail-silent faults. By and large, unless C is chosen aggressively large, resulting in too small \u03c3 ( f , \u2113 ) , HEX usually stabilizes after the very first pulse. For large C, the average stabilization time estimates go up moderately. Given that the number of simulation runs that did not stabilize within 10 pulses was low ( < 25 % even in the most unfavorable scenario), however, we can safely infer that the typical stabilization time of HEX is indeed much lower than the worst-case stabilization time bound L + 1 established in Theorem 2. The results verify that the already good self-stabilization properties of the original HEX algorithm reported in [32] are further improved by the additional link timeouts.  Finally, we also computed the stabilization time estimates for the very same scenarios after also discarding the single-hop outgoing neighbors of faulty nodes ( h = 1 ). In this case, HEX turned out to stabilize after the very first pulse in every run. This again confirms the strong fault locality property claimed for the HEX grid.   DISCUSSION    Stabilization time and pulse separation time\u2003 The bound on S given by Condition 2 and Theorem 2 is not a large factor from being optimal: The stable skew \u03c3, which clearly is a lower bound on S , is at least roughly 2   d   +   . Our values of S are at most roughly 10 times larger; by rule of thumb, we estimate that S cannot be reduced by more than roughly factor 2. Given that the used values of S guarantee stabilization within less than a microsecond, we consider increasing the (effective) frequency at which the system can be run the most important issue related to the pulse separation time: given that S > 100  ns , a na\u00efve use of HEX as a clocking system results in fairly low operational frequencies. There are several remedies to increase the frequency of the resulting clocks, however.  First, one can try to decrease   d   +   , \u03b5, and other parameters that affect skews and delays by engineering efforts. The amazing improvements that clock tree engineering achieved over the decades serve to demonstrate that there is great potential for improving HEX via this approach. Second, one may use frequency multiplication to derive faster clocks from less frequent HEX pulses. Last but not least, one can seek to improve HEX from an algorithmic point of view. We now briefly discuss the latter two options.   Frequency multiplication\u2003 In [32], we presented a scheme that synchronizes local high-frequency start/stop-pable oscillators to the HEX pulses. Each node's oscillator generates a high-frequency fast clock signal for less than the minimum pulse separation time    \u0393   min   , which has to be less than the pulse separation time   t   \u2113 , i   ( k + 1 )   \u2212   t   \u2113 , i   ( k )   , for every node ( \u2113 , i ) and every pulse k. Having the high-frequency oscillators generate pulses only in this restricted time window ensures a metastability-free restart of the oscillator with the next pulse (cf. Fig. 20 ). Note that the pulse separation time may vary with each pulse at node ( \u2113 , i ) , as it depends on S , the node's position in the HEX grid, the delay uncertainties from layer 0 to L, the initial layer 0 skews etc. It is of course beneficial in terms of achieving a stable amortized frequency of the fast clocks if   \u0393   min   is large compared to the variability of the pulse separation times.  On the other hand, the achievable worst-case skew of the fast clock between neighbors turned out to be equal to the HEX clock skew plus an additive term of roughly \u03f1   \u0393   min   , where \u03f1 = \u03d1 \u2212 1 is the relative drift of the oscillators. This deterioration of the achievable skew prohibits to make   \u0393   min   arbitrarily large. Since \u03d1 < 1.05 for practical oscillators, however, the skew of the HEX pulses will usually dominate the overall skew.  In any case, the performance of the frequency multiplication depends strongly on the engineering parameters   d   +   , \u03d1 and \u03b5 as well as on   \u0394   0   . Sufficiently good parameters, in combination with stable low frequency pulses generated by HEX, are hence a prerequisite for achieving stable fast clocks with a small neighbor skew.   Decreasing skews further\u2003 In the fault-free case, we observed intra-layer skews of roughly   d   +   . The inter-layer skews, on the other hand, have a higher bound but have a bias of s \u2248   d   +   . Whereas one can compensate this bias by subtracting s at the application-level, as discussed in [32], which reduces the skew appropriately, this cannot mitigate the increase of the skew by a factor 2 or more even in the presence of few faults (cp. Fig. 15): The reason is that the HEX nodes rely on their neighbors in the same layer to \u201chelp out\u201d if one of their neighbors in the previous layer is faulty. This incurs an additional signal delay and therefore a substantial increase of the skew. This problem would be mitigated, if not eliminated entirely, via augmenting the HEX topology by connecting each node to additional in-neighbors from the previous layer. This would, through clock multiplication, allow to increase the effective system frequency and also reduce the stabilization time.   Embedding\u2003 The presented topology can be embedded into a VLSI circuit using two interconnect layers: One simply \u201csqueezes\u201d the cylindric shape of the HEX grid flat. However, this simplistic solution has two substantial drawbacks. First, the now physically close nodes from opposite \u201csides\u201d of the original cylinder are distant in the grid and therefore may suffer from larger skews. This might entail that actually half of the nodes cannot be used for clocking. Second, it might be difficult to synchronize the nodes at layer 0 due to physical distance.  As a remedy, a slightly modified topology that arranges the nodes of each layer in a circular pattern could be used. To avoid large variations in link lengths, \u201cdoubling layers\u201d responsible for \u201cduplicating\u201d the nodes of a standard layer to quickly increase the number of nodes are used; see Fig. 21 for an illustration. The resulting topology can be easily embedded into two interconnection layers with little distortion. The analysis from Section 3 provides strong evidence that the resulting skews would not be worse (if not better); conducting the detailed analysis of such variants of HEX is a topic of future research, however.   CONCLUSIONS   We proposed a candidate for a scalable and fault-tolerant alternative for clock distribution in VLSI circuits, multi-core processors, and other hardware devices. Our approach supports multiple synchronized clock sources and is self-stabilizing even in the presence of a large number of non-clustered Byzantine failures of both clock sources and HEX nodes. Theoretical worst-case analysis and elaborate simulation experiments have been used to show that HEX guarantees a small skew between neighbors in the grid.  Part of our current/future work on HEX is to explore the properties of alternative topologies, which may be chosen to improve clock skews and/or resilience. Moreover, we are working on self-stabilizing Byzantine fault-tolerant higher-level services that may benefit from the enticing properties of HEX.  Recall that the various cases encountered in our analysis (i.e., mainly in Lemma 4) are always tackled by the following generic pattern:  \u2022 Consider a causal path (typically a left zig-zag path) leading to a node ( \u2113 , i ) on some layer \u2113 (\u201cfast node\u201d), which is supposed to be triggered much earlier than its neighbor ( \u2113 , i + 1 ) on the same layer (\u201cslow node\u201d).  Derive a lower bound on the triggering time of the fast node in relation to the triggering times of the nodes on the causal path, from the length of the path and the fact that delays are at least   d   \u2212   .  Derive an upper bound on the triggering time of the slow node, from the bounds on the triggering times of the nodes on the causal path, the fact that delays are at most   d   +   , and bounds on the skew in some previous layers.  We will follow the general structure of the proof of Lemma 4 in terms of the discussed cases, where we also generalize Lemma 2 once it is needed. It is straightforward to see that similar arguments apply to Lemma 3 and Corollary 1, so we will omit these from the discussion.   Case 1 V-shaped skews (  Fig. 4a  ):    t   \u03bb , i + 1   \u2264   t   \u03bb , i   +   d   +    for some maximal  \u03bb \u2265   \u03bb   0      Case 1 implicitly uses a simple causal path construction, which we now need to make explicit. Since the case considers columns i and i + 1 only, we distinguish two subcases in which we need to modify the approach.   Case 1a: The faulty node is  (   \u2113   \u2032   , i + 1 )  for some    \u2113   \u2032   \u2208 {   \u03bb   0   ,   \u03bb   0   + 1 , \u2026 , \u2113 \u2212 1 } We backtrace the \u201crightmost\u201d causal (not necessarily zig-zag) path ending in ( \u2113 , i ) , i.e., if the current source of the path is right-triggered, the incoming link from the right neighbor is added; if it is centrally triggered, the link from the lower right neighbor; otherwise, the one from the lower left neighbor. Several possibilities exist:  (1) We reach column i + 1 in a layer \u03bb >   \u2113   \u2032   . In this case, either   t   \u03bb , i + 1   \u2264   t   \u03bb , i   +   d   +   (if ( ( \u03bb , i + 1 ) , ( \u03bb , i ) ) is in the causal path) or   t   \u03bb + 1 , i + 1   \u2264   t   \u03bb + 1 , i   +   d   +   (if ( ( \u03bb , i + 1 ) , ( \u03bb + 1 , i ) ) is in the causal path). We can hence proceed exactly as in the fault-free setting in Case 1 of Lemma 4.  The causal path reaches the faulty node, i.e., we would add one of the links ( (   \u2113   \u2032   , i + 1 ) , (   \u2113   \u2032   + 1 , i ) ) or ( (   \u2113   \u2032   , i + 1 ) , (   \u2113   \u2032   , i ) ) . In the first case, (   \u2113   \u2032   + 1 , i ) must have been centrally triggered. We add the link ( (   \u2113   \u2032   , i ) , (   \u2113   \u2032   + 1 , i ) ) instead and resume the construction. In the second case, (   \u2113   \u2032   , i ) must have been right-triggered. We add the link ( (   \u2113   \u2032   \u2212 1 , i + 1 ) , (   \u2113   \u2032   , i ) ) instead and resume the construction, which will eventually terminates in one of the following two ways:  (2a) We reach column i + 3 at some layer \u03bb \u2265   \u03bb   0   (see Fig. A.22a for an example).  We reach layer   \u03bb   0   \u2212 1 before we reach column i + 4 .  Regarding (2a), we know that the causal path to ( \u2113 , i ) originates in some layer \u03bb \u2265   \u03bb   0   . By the same induction as used in Lemma 2, one can show that every node on the   k   th   left-diagonal on or to the right of the causal path has a triggering time that is at most k   d   +   more than the maximal triggering time of any node on the causal path on diagonal 0. In fact, since the causal path is not necessarily a triangular left zig-zag path here (see Fig. A.22a), the induction itself works only for nodes on or to the right of the causal path which are also above horizontal segments of the causal path. However, the direct proof that establishes the induction basis also shows that the assertion trivially holds for nodes on these horizontal segments also.  For the, in terms of the lower bound on   t   \u2113 , i   , worst-case causal path, which goes from ( \u03bb , i + 3 ) via ( \u03bb , i + 1 ) and ( \u03bb + 1 , i ) to (   \u2113   \u2032   , i ) , the induction starts at the left-diagonal ( \u03bb , i + 1 ) to ( \u03bb + 1 , i ) with maximal triggering time   t   \u03bb + 1 , i   . Observe that node (   \u2113   \u2032   , i + 3 ) is   \u2113   \u2032   \u2212 \u03bb + 2 diagonals from, e.g., node ( \u03bb , i + 1 ) . It hence follows that all correct nodes in columns i + 1 , i + 2 , and i + 3 in layers \u03bb to   \u2113   \u2032   that are on or to the right of the causal path\u2014in particular, nodes (   \u2113   \u2032   , i + 2 ) resp. (   \u2113   \u2032   , i + 3 ) \u2014will be triggered by time   t   \u03bb + 1 , i   + (   \u2113   \u2032   \u2212 \u03bb + 1 )   d   +   resp.   t   \u03bb + 1 , i   + (   \u2113   \u2032   \u2212 \u03bb + 2 )   d   +   . Consequently, (   \u2113   \u2032   + 1 , i + 1 ) will be triggered by time   t   \u03bb + 1 , i   + (   \u2113   \u2032   \u2212 \u03bb + 4 )   d   +   , and it follows that   t   \u2113 , i + 1   \u2264   t   \u03bb + 1 , i   + ( \u2113 \u2212 \u03bb + 3 )   d   +   . Since we have that   t   \u2113 , i   =   t   \u03bb + 1 , i   + ( \u2113 \u2212 \u03bb \u2212 1 )   d   \u2212   , comparison with Case 1 of Lemma 4 reveals that the resulting skew is O (   d   +   ) larger, so this case is covered.  To deal with (2b), we can argue similarly, provided that, for some layer \u03bb \u2265   \u03bb   0   , nodes ( \u03bb , i + 1 ) , ( \u03bb , i + 2 ) , and ( \u03bb , i + 3 ) are triggered before or shortly after ( \u03bb , i ) , i.e., that   t   \u03bb , i + k   \u2264   t   \u03bb , i + k \u2212 1   +   d   +   for 1 \u2264 k \u2264 3 . If this holds true, we are essentially in Case 1 of Lemma 4, except that the causal path leading to ( \u2113 , i ) resp. to ( \u2113 , i + 1 ) need not start at ( \u03bb , i ) resp. ( \u03bb , i + 1 ) but rather at ( \u03bb , i + k \u2212 1 ) resp. ( \u03bb , i + k ) for some 1 \u2264 k \u2264 3 . Note that this shift results from the need to avoid the faulty node in the causal path construction; as in (2a), it changes the resulting skew by at most O (   d   +   ) .  Still, there is also the possibility that there is no \u03bb \u2265   \u03bb   0   where   t   \u03bb , i + k   \u2264   t   \u03bb , i + k \u2212 1   +   d   +   for 1 \u2264 k \u2264 3 holds. We will deal with these cases (which correspond to Case 2 and 3 in Lemma 4) below.   Case 1b: The faulty node is  (   \u2113   \u2032   , i )  for some    \u2113   \u2032   \u2208 {   \u03bb   0   ,   \u03bb   0   + 1 , \u2026 , \u2113 \u2212 1 } In this event, we use essentially the same approach as for Case 1a, except that we shift it one column to the left: Now the construction of the causal path might encounter a left-triggered node whose lower-left neighbor is the faulty node, forcing the construction to evade to column i \u2212 1 ; in turn, column i + 3 is not needed any more to circumvent the faulty node when deriving an upper bound on   t   \u2113 , i + 1   . See Fig. A.22b for an example.   Case 2 Non-V-shaped skews, non-triangular (  Fig. 4c  ): Case 1 does not apply and    p   left   i + 1 \u2192 ( \u2113 , i )    starts at some node  ( 0 ,   j   0   )  , for    j   0   \u2260 i + 1    If the above Subcase (2b) of Case 1a does not apply, the causal path to the fast node ( \u2113 , i ) can be constructed independently of the causal path to the slow node ( \u2113 , i + 1 ) : For every \u03bb \u2208 {   \u03bb   0   , \u2026 , \u2113 } , there are neighbors (usually ( \u03bb , i ) and ( \u03bb , i + 1 ) , except for the possible column shift needed for circumventing the faulty node) with a difference in triggering times of more than   d   +   .  When constructing the left zig-zag path ending at ( \u2113 , i ) , the faulty node may be approached either via some correct node's left link or lower-right link: In the former case, we evade via the other causal link to the lower-left neighbor. If we would reach the faulty node via the lower-right link, we first backtrack/go one hop to the right before we go down-right and finally down-left (see Fig. 6). Clearly, this makes the causal path shorter and thereby decrease the triggering time bound for the fast node by at most O (   d   \u2212   ) . The latter is of course only possible if the faulty node is in a column smaller than i.  If the faulty node is in column i or i + 1 , however, which led to the index shift by k \u2208 { 1 , 2 , 3 } mentioned in (2a) above, we need to construct   p   left   i + 2 \u2192 ( \u2113 , i )   or   p   left   i + 3 \u2192 ( \u2113 , i )   instead of   p   left   i + 1 \u2192 ( \u2113 , i )   . In these left zig-zag paths, we can pass around the faulty node to the right. Note that this may actually increase the fast node's triggering time bound by O (   d   \u2212   ) , albeit the resulting decrease of the skew bound is by far outweight by the simultaneous increase O (   d   +   ) of the triggering time of the slow node (which is caused by circumventing the faulty node in the causal path to ( \u2113 , i + 1 ) , as also discussed in (2a) above).  The same is true if the faulty node lies in the triangular region with corners ( 0 , i + 1 ) , ( 0 , i + 1 +   \u03bb   0   ) , and (   \u03bb   0   , i + 1 ) used in Case 2 (Fig. 4c), see Fig. 6. In fact, even a fail-silent node could not prevent that (   \u03bb   0   , i + 1 ) is triggered quickly here: By adding a few nodes, if necessary, and arguing that the faulty node can be bypassed by right- or left-triggering, at most O (   d   +   ) time is lost. This finally covers Case 2 of Lemma 4.   Case 3 Non-V-shaped skews, triangular (  Fig. 4b  ): Neither Case 1 nor Case 2 apply   The reasoning for circumventing the faulty node in the construction of the (now triangular) left zig-zag path in Case 3 of Lemma 4 is the same as for Case 2 above. For computing the triggering time of the fast node, though, we also need to adapt Lemma 2 to cope with a faulty node within the part of the triangle with corners (   \u2113   \u2032   , i + 1 ) , (   \u03bb   0   , i + 1 \u2212   \u2113   \u2032   ) , and (   \u03bb   0   , i + 1 ) in Fig. 4b that is to the right of   p   left   i + 1 \u2192 ( \u2113 , i )   . Note that the latter possibly needed to evade the faulty node as well, see Fig. A.23a .  Recall that the proof of Lemma 2 proceeds by induction over the left-diagonals of the triangle. As already argued in (2a), the modified shape of the zig-zag path does not invalidate the statement of the lemma. Moreover, if the faulty node has column index smaller than i, its right and upper right neighbors will be centrally and right-triggered, respectively, at most O (   d   +   ) later (if they are not triggered otherwise earlier) than indicated by the bounds derived in the original Lemma 2. Examples of the two basic cases that may occur here are shown in Fig. A.23. This covers all possibilities for Case 3 of Lemma 4, except the ones where the faulty node has column index i or i + 1 . In this event, as already argued before, we fall back to considering   p   left   i + 2 \u2192 ( \u2113 , i )   or   p   left   i + 3 \u2192 ( \u2113 , i )   , which again allows the causal path leading to the slow node to pass the faulty node on its right.   REFERENCES", "highlights": "We argue that a hexagonal grid with simple intermediate nodes is a robust alternative to buffered clock trees typically used for clock distribution in VLSI circuits, multi-core processors, and other applications that require accurate synchronization: Our HEX grid is Byzantine fault-tolerant, self-stabilizing, and seamlessly integrates with multiple synchronized clock sources, as used in multi-synchronous Globally Synchronous Locally Asynchronous (GALS) architectures. Moreover, HEX guarantees a small clock skew between neighbors even for wire delays that are only moderately balanced. We provide both a theoretical analysis of the worst-case skew and simulation results that demonstrate a very small average skew."}