{"id": "S0168874X15000384", "article": "MAIN-TITLE Isogeometric local h-refinement strategy based on multigrids   HIGHLIGHTS          An isogeometric local h-refinement based on multigrid resolution is proposed.      It leads to a solution on a quasi-optimal mesh for a given precision criterion.      It solves the problem of non-straight boundaries in multigrid resolution with FEA.          KEYPHRASES   Isogeometric analysis  Local h-refinement  Controlled accuracy  Full-multigrid method   Multigrid algorithms are iterative solvers showing interesting rates of convergence [1\u20133]. They were originally introduced to solve fluid mechanics problems using finite differences by Brandt and Livne [4] and were extended to solve solid mechanics problems with finite element analysis by Parsons and Hall [5,6]. Multigrid resolution has already been used with IGA as a way to reduce computational time by Gahalaut et al. [7]. This kind of resolution is designed for problems where the fine discretization is known a priori.  There has been in the recent years quite an extensive work on designing efficient solvers and preconditioners that are well suited to isogeometric analysis (IGA). Up to our knowledge the first work on specific isogeometric preconditioners is attributed to Beir\u00e3o da Veiga et al. [8] and Buffa et al. [9]. Multigrid (MG) and multilevel methods were also coupled with IGA to design efficient iterative solvers, see for example the work of Gahalaut et al. [7,10] and Donatelli et al. [11]. Finally one can also cite the work of Collier et al. [12] on the performance of standard iterative solvers for IGA. It is important to note that in the work presented in this paper, our goal is not to design efficient iterative solvers for IGA based on multigrid methods. We suggest that multigrid methods can be used to obtain a new local h-refinement strategy for IGA with controlled accuracy of the solution. Consequently, the proposed work falls into the class of isogemetric methods with local h-refinement such as T-splines [13,14], LR splines [15] and hierarchical b-splines [16,17].  The use of the full multigrid algorithm (FMG) with finite element analysis (FEA) combined with an error indicator has been developed as a solver with adaptative refinement. This algorithm is very efficient but presents a loss of accuracy when the refinement of non-straight boundaries is required as shown in Adams and Taylor [3] and Biboulet et al. [18]. One way to deal with this difficulty is to go back to the CAD geometry each time a refinement is needed. We propose here a way to circumvent this problem using IsoGeometric Analysis. Indeed, IGA allows an exact description of the CAD geometry even with non-straight boundaries [19]. Refinement of such meshes can be done keeping the exact description of the CAD geometry. In this paper, the MG resolution is used as an automatic local mesh refinement tool with controlled accuracy. Here the desired fine mesh is not known a priori and depends on the required level of accuracy on the solution.  This paper is organized as follows. First a short introduction to MG techniques with FEA and a short introduction to IGA with NURBS are presented. Then, we present a localized FMG with IGA algorithm. Finally, the performances of this algorithm are analyzed on several examples.  MG methods are mainly based on the smoothing properties of iterative solvers such as Gauss\u2013Seidel or preconditioned conjugate gradients. In other words, MG methods are based on the ability of these solvers to capture the high frequency error in the solution (see [5,6,20]). One iteration of the chosen iterative solver is called a smoothing step. The first idea is to exploit this property using two grids, in the well-known correction scheme. These two nested meshes of the same geometry cover the whole considered domain which is therefore a global MG approach. Quantities on the fine and coarse grid are noted respectively by the f and c subscript. K is the stiffness matrix, F are the generalized forces and U is the discretized displacement field we are looking for using a FE discretization of a given linear solid mechanics problem.  Here, the aim of the CS is to solve the equilibrium equation arising from a static linear elastic analysis on the fine grid   K   f     U   f   =   F   f   .  1. The first step is to do \u03bd 1 smoothing steps on the fine grid with an iterative solver initialized with an initial guess   U   f   0   , obtaining a solution     U   \u00af     f   0   .  Assuming that the iterative solver decreases the high frequency error, then the difference   E   f   0   between     U   \u00af     f   0   and the exact solution we are looking for   U   f   (   E   f   0   =   U   f   \u2212     U   \u00af     f   0   ) is only composed by low frequency error. Consequently   E   f   0   can be computed on the coarse grid.  Therefore, the residual   R   f   0   =   F   f   \u2212   K   f       U   \u00af     f   0   is transferred on the coarse grid with a restriction operator R , and the low frequency error is computed with a direct solve on the coarse grid   K   c     E   c   0   = R (   R   f   0   ) .  Then, the displacement coarse correction is transferred on the fine grid with a prolongation operator P , and the solution on the fine grid is corrected as     U   ^     f   0   =     U   \u00af     f   + P (   E   c   0   ) .  Finally, \u03bd 2 smoothing steps are done on     U   ^     f   0   to correct the high frequency error introduced by the prolongation operator giving the solution   U   f   1   .  These operations form a two grids MG cycle. The two grids MG cycle is repeated until convergence of the solution is reached. The algorithm is presented in Fig. 1 .  This algorithm can be generalized for N grids. Indeed, if the direct solve on the coarse grid is too expensive, the CS can be applied recursively with a limited number of MG cycles \u03b3. Fig. 2 shows a MG cycle with three grids for \u03b3 = 1 (V-cycle) and \u03b3 = 2 (W-cycle). Applied to N grids, MG solvers can be quasi-optimal and reach a complexity in O ( n ) (where n = size (   K   f   ) ).  In practice, the convergence rate of a MG resolution can depend on the quality of the initial guess   U   f   0   . A way to avoid such a dependency is the FMG resolution. For a two grid resolution with the CS, the idea consists in using as an initial guess on the fine grid   U   f   0   as the prolongation of the solution computed on the coarse grid   U   f   0   = P (   U   c   ) with   K   c     U   c   =   F   c   . The generalization to N grids is represented in Fig. 3 . Solutions boxed in Fig. 3 represent the converged solutions on a given level of discretization.  In the previous part prolongation and restriction operators P and R are mentioned. There are some constraints on these operators dealing with primal quantities (U) and dual quantities (R). We can see in Fig. 4 a representation of the relation between these quantities in the two grids case.  A condition we can impose to these operators is to preserve internal work for any couple (   U   c   ,   F   f   )    (1)  \u3008   U   c   ,   F   c   \u3009 = \u3008   U   f   ,   F   f   \u3009 ,  \u2200 (   U   c   ,   F   f   )  \u21d4   U   c   T   R   F   f   =   U   c   T     P   T     F   f   ,  \u2200 (   U   c   ,   F   f   )  \u21d4 R =   P   T        The conservation condition on the internal work gives us a relation between the two operators P and R . For a given prolongation operator P we have no choice on the restriction operator if we want this condition to be verified (Eq. (1)).  It is possible to impose another kind of condition: for all   U   c   , a prolongation, a solve on the fine grid, a restriction and a solve on the coarse grid have to keep   U   c   unchanged  (2)    K   c     U   c   =   F   c   ,  \u2200   U   c    \u21d4   K   c     U   c   = R   K   f   P   U   c   ,  \u2200   U   c    \u21d4   K   c   = R   K   f   P      It gives a condition on stiffness matrices of the two grids (Eq. (2)). MG resolution using this approach are algebraic MG resolutions (see [21]). We are not going to use that kind of approach here because it implies a new computation of all stiffness matrices each time a new grid is added which can become expensive.  Usually in MG resolution with FEA, interpolation operators are used as prolongation operators. We will see further in this paper that this solution is not pertinent in MG resolution with IGA.  The FMG solver presented in Section 1.1.1 is suited for problems with a known final mesh. It is possible to build an algorithm with automatic refinement using an error indicator with an FMG resolution. In this case only the coarse discretization is known a priori and the successive grids are built locally with information from the error indicator (see Fig. 5 ).  This algorithm uses several levels of discretization, but all the meshes are defined on the whole structure. It implies that quantities of interest (displacement in the linear elastic case) are computed on areas with identical discretization on several meshes. An example with three levels of discretization is displayed in Fig. 6 . With a MG algorithm with global refinement, quantities of interest are computed on blue areas which have the same discretization on the three grids and on red areas which have the same discretization on the last two grids. It is possible to save computational cost by avoiding the calculation on blue and red areas for each grid. It is the principle of localization in MG algorithms.  The idea of localization is to refine only the area where the level of accuracy is not satisfied (see Fig. 7 ).  This kind of refinement creates internal interfaces. With \u0393  N being the boundary of \u03a9  A with Neumann boundary conditions, the internal interfaces \u0393  AB (between \u03a9  A and \u03a9  B ) and \u0393  BC (between \u03a9  B and \u03a9  C ) are   \u0393   AB   =   \u03a9   A   \u2229 \u2202   \u03a9   B   \\   \u0393   N   and   \u0393   BC   =   \u03a9   B   \u2229 \u2202   \u03a9   C   \\   \u0393   N   (in red in Fig. 7). Dirichlet boundary conditions from the lower level of discretization are imposed on these interfaces. With   u     \u03a9   k     being the displacement solution on the \u03a9  k domain, we want   u     \u03a9   A     ,   u     \u03a9   B     and   u     \u03a9   C     to verify  (3)  {       u   |   \u0393   AB       \u03a9   B     =   u   |   \u0393   AB       \u03a9   A     ,       u   |   \u0393   BC       \u03a9   C     =   u   |   \u0393   BC       \u03a9   B     .          Further details are given in Cavin et al. [2], Rannou et al. [22], Biotteau et al. [23].  We briefly review the concept of NURBS-based IGA first presented in Cottrell et al. [19] and Hughes et al. [24], where a detailed account may be found. NURBS are a generalization of B-splines and standard in CAD and computer graphics for geometry modeling (see [25\u201327]).  B-splines are piecewise polynomial functions with a prescribed degree of continuity. Univariate B-spline basis functions are constructed from a knot vector, a set of coordinates in parametric space, \u039e = {    \u03be   1   ,   \u03be   2   , \u2026 ,   \u03be   n + p + 1    } , where   \u03be   i   \u2208 R is the ith knot, i is the knot index, i = 1 , 2 , \u2026 , n + p + 1 , p is the polynomial order, and n is the number of basis functions. More than one knot can be placed at the same location in the parametric space. If m is the multiplicity of a given knot, the functions are   C   p \u2212 m   continuous at that location. If the knots are equally spaced, the knot vector is said to be uniform. A knot vector is referred to as open if its first and last knots have multiplicity p+1. This results in the basis being interpolatory at the endpoints of the interval.  B-spline basis functions for a given order p are defined recursively in the parametric space by way of the knot vector \u039e. Beginning with piecewise constants (p=0) we have  (4)    N   i , 0   ( \u03be ) = {     1   if    \u03be   i   \u2264 \u03be <   \u03be   i + 1   ,     0   otherwise .       For p = 1 , 2 , 3 , \u2026 , the basis is defined by the Cox\u2013de Boor recursion formula  (5)    N   i , p   ( \u03be ) =   \u03be \u2212   \u03be   i       \u03be   i + p   \u2212   \u03be   i       N   i , p \u2212 1   ( \u03be ) +     \u03be   i + p + 1   \u2212 \u03be     \u03be   i + p + 1   \u2212   \u03be   i + 1       N   i + 1 , p \u2212 1   ( \u03be ) .      Let d  s denote the number of spatial dimensions. A B-spline curve in   R     d   s     is defined as follows:  (6)  C ( \u03be ) =   \u2211   i = 1   n     P   i     N   i , p   ( \u03be ) ,   where   P   i   \u2208   R     d   s     denotes control point i.  The univariate B-spline concept can be extended to multiple dimensions with the use of tensor products, but representation of many desired shapes of engineering interests, such as conic sections, require further generalization. Non-Uniform Rational B-Splines (NURBS), rational projections of higher dimensional B-splines, can be introduced for this purpose and consequently share many of the same properties as B-splines. More details can be found in Cohen et al. [25], Rogers et al. [27] and Piegl and Tiller [26], as well as Cottrell et al. [19].  Analogues of finite element h-and p-refinement are available in IGA. h-refinement is termed knot insertion and consists in adding new knots in the knot vectors. Knot insertion does not change the geometric modeling and preserves continuity as long as new knots are not already present in the knot vector. p-refinement is termed order elevation and consists in increasing the polynomial order of the basis functions. As with knot insertion, neither the geometry nor the parametrization is changed during the process. Moreover, continuity is preserved at element boundaries by increasing knot multiplicity. The main difference in IGA when comparing refinement strategies with finite element ones is that h-and p-refinement do not commute. The flexibility of knot insertion and order elevation allows us to introduce k-refinement in which order and continuity of the basis functions can be simultaneously increased. This can be attained by performing order elevation on the coarse geometric mesh followed by knot insertion up to the desired mesh refinement. It is important to note that k-refinement will produce maximum continuity on a patch if the coarsest mesh is composed of a single element. If the initial mesh comprises constraints on continuity across element boundaries, these will exist on all meshes. For more insight on mesh generation and refinement in IGA see Cottrell et al. [19, Chapter 2].  Here, we propose an isogeometric local h-refinement strategy based on the localized FMG algorithm (see Section 1.1.3) for a given precision criterion. First, prolongation and restriction operators between a coarse grid and a localized fine one have to be defined for IGA. Then, a way to evaluate error between these two successive grids has to be chosen. Finally, the local h-refinement procedure developed will be exposed.  We want to build a prolongation operator P between two successive nested grids, a coarse one and a fine one. With   U   f   being the control variables of the displacement on the fine grid, and   U   c   being the control variables of the displacement on the coarse grid, we want P to satisfy  (7)    U   f   = P (   U   c   ) .      The case of order 1 NURBS basis functions correspond to order 1 finite element functions. The classical prolongation operator for order 1 finite element basis functions for nested grids is based on interpolation. In this particular case, the h-refinement process does not modify current control points and the computing of new control points is localized by elements. Hence, the prolongation operator is easy to build a priori, knowing only the element refinement rule (see Fig. 8 ).  In the case of higher order NURBS basis functions, the h-refinement process of an element depends on his neighboring elements. Hence, the prolongation operator is not known a priori and depends on the elements that are to be refined (see Fig. 8). The problem has to be treated at the patch level rather that at the element level. In order to build the prolongation operator, the isoparametric concept is used. The prolongation operator will be built during the geometry refinement and will be used for the prolongation of the displacement fields. For the piecewise linear case, this procedure is identical to the one presented for the particular case of   C   0   linear finite elements.  We consider nested meshes emanating from NURBS based IGA and with h-refinement. With IGA, basis functions used to describe the displacement field are the same as the ones used to describe the geometry. Therefore, with   Q   f   and   Q   c   being respectively the control points of the geometry on the fine grid and the coarse grid, P satisfies  (8)    Q   f   = P (   Q   c   ) .      In the FMG algorithm, the fine grid is always obtained from a nested refinement of the coarse grid. The prolongation operator we chose is obtained under a matrix form during the h-refinement procedure of a NURBS mesh as presented in Cohen et al. [25].  In the 2D case, h-refinement is done in two steps. h-refinement is performed in one parametric direction \u03b7, an intermediate grid is obtained. Then h-refinement is done in the other parametric direction \u03be. We define two intermediate prolongation operators   P   \u03b7   and   P   \u03be   which are respectively the prolongation operators in the first parametric direction \u03b7 and in the second parametric direction \u03be (Fig. 9 ). Therefore we have  (9)  P =   P   \u03be   \u25cb   P   \u03b7   .      Using this decomposition of the prolongation operator (   P   \u03be   ,   P   \u03b7   ) instead of the full operator P allows an important saving of computational memory. This is a direct consequence of the tensor product structure of NURBS based IGA.  This method works well for building a prolongation operator between two nested grids obtained from a global refinement of the coarse one. We saw in Section 1.1.3 that localized multigrid resolution methods are more efficient than global ones. Therefore, a local prolongation operator has to be defined.  To build a local prolongation operator, a small adaptation of the previous method is done. Actually, it has to allow the extraction of a part of the domain, and ensure the same smoothness of the solution across the internal grid interfaces as the one used on the coarse grid.  In order to build this local prolongation operator, the extraction operator   P   e   is introduced. The principle of this extraction operation is detailed in Fig. 10 . This is a one dimension example with B-splines quadratic basis functions. The part of the domain to be extracted is [ 0.375 , 0.875 ] . Control points associated to dotted black basis functions are removed, control points associated to red basis functions will be imposed in a strong way in order to ensure the same smoothness as for the underlying coarse grid and control points associated to blue basis functions will be the unknowns of the problem.  The construction of local prolongation operator is detailed in Fig. 11 . Elements to be refined are colored in red. The global prolongation operator   P   g   between the two first grids is built with the previous method. Now, the NURBS mesh of the convex containing the elements to be refined is extracted with the extraction operator   P   e   defined previously. The local prolongation operator   P   loc   is obtained with the composition of these two operators   P   loc   =   P   e   \u25cb   P   g   . Each of the operators can be decomposed with the two parametric directions   P   i   =   P   \u03be   i   \u25cb   P   \u03b7   i   ,  i \u2208 [ e , g ] .  This proposed local refinement allows us to impose the conditions detailed in Eq. (3) (Section 1.1.3) in a strong sense. Indeed, the discretization of Eq. (3) leads to   U   | \u0393   2   =   P   loc   (   U   | \u0393   1   ) , with \u0393 being the internal boundary between \u03a9 2 and \u03a9 1. This operator ensures the desired smoothness of the solution across the internal interface (in blue in Fig. 11). Fig. 12 is an example of localization for a one dimensional and a two dimensional problem.  In the implemented algorithm, several areas of a NURBS mesh can be locally refined. For each of these areas a prolongation operator is built (Fig. 13 ).  Now, we are ready to define an error indicator able to identify elements to be refined.  In FMG, we need to know the error between the converged solution at the end of a multigrid cycle and the exact solution in order to build a finer localized grid to reach a given level of accuracy. In practice, the true useful information is not the exact value of the error, but which elements have to be refined. As a consequence, we will define an error indicator which allows us to have an approximate of the exact error. Furthermore, a keypoint is that it has to be not expensive in term of CPU time (see for instance [18,22,23]).  The error indicator with the solutions on the two fine grids \u03a9  k and \u03a9  k+1 of the current grid set (   \u03a9   1   ,   \u03a9   2   , \u2026 ,   \u03a9   k   ,   \u03a9   k + 1   ) is always computed on grid \u03a9  k . For clarity, a quantity \u03b1 computed from the converged solution on the grid \u03a9  i is noted \u03b1  i .  They are several error indicators which can be used in localized FMG algorithm [2]:  \u2022 displacement error indicator :   \u2225   u   k + 1   \u2212   u   k     \u2225     L   2       \u2225   u   0     \u2225     L   2       ,  stress error indicator :   VM (   \u03c3   k + 1   \u2212   \u03c3   k   )   VM (   \u03c3   0   )   ,  energy density error indicator :     |   e   k + 1   \u2212   e   k   |     e   0       ,  energy error indicator :       \u222b   \u03a9   |   e   k + 1   \u2212   e   k   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9     ,  It is shown in Cavin et al. [2] that displacement and energy error indicator are the only ones that behave well in singular problems. Moreover, with NURBS based IGA, it is cheaper to compute the energy error indicator knowing the non-assembled stiffness matrix than computing the displacement error indicator which requires the evaluation of all the basis functions. The energy error indicator is a global indicator. In order to build a local refinement strategy, a local criterion is needed. In the next section is presented a local criterion derived from the global energy error indicator.  For a given set of grids (   \u03a9   0   , \u2026 ,   \u03a9   k   ,   \u03a9   k + 1   ) , we define  (10)  {       D   i   =   \u03a9   i   \\   \u03a9   i + 1   ,  \u2200 i \u2208 [ [ 0 ; k ] ] ,       D   k + 1   =   \u03a9   k + 1   ,         D   \u00af     i   =   \u03a9   i   \u2229   \u03a9   i + 1   ,  \u2200 i \u2208 [ [ 0 ; k ] ] ,         D   \u00af     k + 1   = { \u2205 } .       With these notations, we have  (11)  {       \u22c3   i \u2208 [ [ 0 ; k + 1 ] ]     D   i   = \u03a9 ,       \u222b     D   i   \u2229   D   j      d \u03a9 = 0 ,  \u2200 i \u2260 j \\ ( i , j ) \u2208   [ [ 0 ; k + 1 ] ]   2   .         D   \u00af     k   =   D   k + 1         The definition of these domains is illustrated for a four grids set in Fig. 14 .  Here we use the energy error indicator as a global indicator. Due to the localization, the quantity   e   i   , i \u2208 [ [ 0 ; k + 1 ] ] cannot be defined on the whole domain \u03a9. The energy error indicator \u03b7 is redefined as  (12)    \u03b7   2   =   \u2211   1 \u2264 i \u2264 k + 1       \u222b     D   i     |   e   i   \u2212   e   i \u2212 1   |  d \u03a9     \u222b     \u03a9   0       e   0    d \u03a9        The energy error indicator has to verify   \u03b7   2   \u2264   \u03f5   2   , with \u03f5 being the precision criterion on the whole structure imposed by the user.  For each grid, we define the following:  (13)  {       \u03b7   i   2   =     \u222b       D   \u00af     i     |   e   i + 1   \u2212   e   i   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9   ,       \u03f5   0   2   =   \u03f5   2   ,       \u03f5   i   2   =   \u03f5   i \u2212 1   2   \u2212      \u222b     D   i     |   e   i   \u2212   e   i \u2212 1   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9    ,  \u2200 i \u2208 [ [ 1 ; k ] ] .          The localized FMG with IGA algorithm stops when   \u03b7   k   2   \u2264   \u03f5   k   2   . Indeed, with this condition, the global precision criterion is checked:  (14)    \u03b7   k   2   =   \u03b7   2   \u2212   \u2211   1 \u2264 i \u2264 k       \u222b     D   i     |   e   i   \u2212   e   i \u2212 1   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9   \u2264   \u03f5   k   2   \u21d4   \u03b7   2   \u2264   \u03f5   k   2   +   \u2211   1 \u2264 i \u2264 k       \u222b     D   i     |   e   i   \u2212   e   i \u2212 1   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9   =   \u03f5   2        For the given set of grids (   \u03a9   0   , \u2026 ,   \u03a9   k   ,   \u03a9   k + 1   ) , a grid \u03a9  k+2 will be built if the arrest criterion   \u03b7   k   2   \u2264   \u03f5   k   2   is not verified. In order to build the next grid \u03a9  k+2, a local refinement criterion is needed to select the possible refined elements of the grid \u03a9  k+1.  As explained in Section 2.2, the error indicator is computed on the grid \u03a9  k . Therefore the local refinement criterion is on the grid \u03a9  k . The way to choose the elements of the grid \u03a9  k+1 to be refined is detailed in the next section.  We define the quantities  (15)    \u03a9       D   \u00af     k     e   : element  of  the  grid    \u03a9   k    on  the  domain      D   \u00af     k   ,   (   \u03b7   k   e   )   2   =     \u222b     \u03a9       D   \u00af     k     e     |   e   k + 1   \u2212   e   k   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9   \u00d7     \u222b       D   \u00af     k      d \u03a9     \u222b     \u03a9       D   \u00af     k     e      d \u03a9   .      The local criterion chosen is to flag all the elements   \u03a9       D   \u00af     k     e   which are not satisfying   (   \u03b7   k   e   )   2   \u2264   \u03f5   k   2   for a further refinement. Indeed, if all elements of     D   \u00af     k   check this criterion, we have  (16)    (   \u03b7   k   e   )   2   =     \u222b     \u03a9       D   \u00af     k     e     |   e   k + 1   \u2212   e   k   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9   \u00d7     \u222b       D   \u00af     k      d \u03a9     \u222b     \u03a9       D   \u00af     k     e      d \u03a9   \u2264   \u03f5   k   2   ,  \u2200   \u03a9       D   \u00af     k     e   \u2282     D   \u00af     k     The summation on every   \u03a9       D   k     \u00af     e   leads to  (17)    \u2211     \u03a9       D   \u00af     k     e   \u2282     D   \u00af     k         \u222b     \u03a9       D   \u00af     k     e     |   e   k + 1   \u2212   e   k   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9   \u2264   \u03f5   k   2   \u00d7   \u2211     \u03a9       D   \u00af     k     e   \u2282     D   \u00af     k         \u222b     \u03a9       D   \u00af     k     e      d \u03a9     \u222b       D   \u00af     k      d \u03a9     and knowing that   D   k + 1   =     D   \u00af     k   , we have  (18)  {          \u222b       D   \u00af     k     |   e   k + 1   \u2212   e   k   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9    =      \u222b     D   k + 1     |   e   k + 1   \u2212   e   k   |  d \u03a9     \u222b   \u03a9     e   0    d \u03a9    =   \u03b7   k   2         \u2211     \u03a9       D   \u00af     k     e   \u2282     D   \u00af     k          \u222b     \u03a9       D   \u00af     k     e      d \u03a9     \u222b       D   \u00af     k      d \u03a9    = 1       which leads to     \u03b7   k   2   \u2264   \u03f5   k   2        Therefore, if the local criterion   (   \u03b7   k   e   )   2   \u2264   \u03f5   k   2   is checked for each element   \u03a9       D   \u00af     k     e   of     D   \u00af     k   , the arrest criterion previously presented is checked and the localized FMG with IGA algorithm stops.  The next section details how are chosen the elements on the grid \u03a9  k+1 knowing the elements flagged on the grid \u03a9  k .  Elements on the grid \u03a9  k on which the error indicator is higher than the required level of accuracy are flagged for a further refinement. The solution is not accurate enough in these areas. So all the basis function having support on these elements have to be refined too. Consequently, for each of these elements, the floor (  ( p + 1 ) / 2  ) neighbor in the \u03be direction and the floor (  ( q + 1 ) / 2  ) elements in the \u03b7 direction (where p and q are respectively the polynomial degree of basis functions in the \u03be and the \u03b7 direction) are flagged for a further refinement.  The local refinement procedure is detailed in Fig. 15 for a given grid set (   \u03a9   1   ,   \u03a9   2   , \u2026 ,   \u03a9   k   ,   \u03a9   k + 1   ) for the creation of a finer grid \u03a9  k+2.  All the results presented here are obtained for two dimensional problems with linear elasticity in the static case. The iterative solver used as a smoother in the FMG algorithm is a preconditioned conjugate gradient with the symmetric Gauss\u2010Seidel preconditioner [28]. The error indicator used for refinement is the energy error indicator. The considered numbers of relaxation are   \u03bd   1   =   \u03bd   2   = 3 . Results for three classical problems are presented. The infinite plate with elliptic hole under in-plane tension has an analytic solution (presented in Appendix A, for further details see [29]). Cook\u05f3s membrane presents a singularity in its solution, and the L-shaped plate presents a singularity of higher order in its solution.  The first example is the infinite plate with a elliptic hole under in-plane tension. We study the problem for linear elasticity under plane strain conditions. Due to the symmetries, the domain is restricted to a quarter. The exact solution of this problem is known and applied as a Neumann boundary condition on the finite quarter plate, Fig. 16 .  This example is used to show the advantages of a local FMG IGA algorithm on a global FMG IGA algorithm.  Quantities used to quantify performances of these algorithms are  \u2022 the evolution of the exact energy error on the whole domain (computed with the analytic solution, see Fig. 16) depending on the total number of degrees of freedom. For a set of grids (   \u03a9   1   ,   \u03a9   2   , \u2026 ,   \u03a9   k   ) , the total number of degrees of freedom   n   dof   =   \u2211   i = 1   k   dof (   \u03a9   i   ) ,  the number of MG cycles done for the solving on each level of grid, which is directly related to the computational cost.  The geometry used as initialization for the FMG IGA algorithm is the geometry from the CAD software (Fig. 17 (a)). The final mesh obtained with the global FMG IGA algorithm is shown in Fig. 17(b) and the final mesh obtained with the local FMG IGA algorithm is displayed in Fig. 17(c).  We can see in Fig. 18 (a) that the localized FMG IGA algorithm gives a more accurate solution than the solution from the global FMG IGA algorithm with fewer dofs. Moreover, Fig. 18(b) shows that the localized FMG IGA algorithm converges with fewer MG iterations than the global FMG IGA algorithm. These results validate the use of the localization in the FMG IGA algorithm.  In this part the good performances of the FMG IGA algorithm are highlighted with two numerical examples: Cook\u05f3s membrane and the L-shaped plate. These problems are still solved for a two dimensional case in linear elasticity under plane strain conditions. First, performances of the FMG algorithm with FEA and with IGA will be compared, then the good behavior of the FMG IGA algorithm regarding the degree of basis functions will be highlighted.  In this part, we will show the good numerical behavior of the algorithm solving singular problems and show the interest of using   C   1   quadratic basis functions instead of   C   0   quadratic basis functions used in FEA. In the first case a classical h-refinement for IGA keeping the solution   C   1   through element boundaries is used and in the second case, a h-refinement giving a solution   C   0   through element boundaries is done.  Final meshes, the error indicator convergence and the number of MG cycles until convergence will be compared.  Data used for solving these two problems are given in Fig. 19 .  The initial mesh from the CAD software and the final mesh obtained when the FMG IGA algorithm converges are given in Fig. 20 .   Figs. 21 (a) and 22 (a) show that a   C   1   discretization has better convergence rate than a   C   0   one. Once the algorithms converged, the   C   1   discretization deals with a set of 15 grids and the   C   0   one with a set of 16 grids.  We can note that the convergence rates obtained for these two benchmarks are not as good as the convergence rate obtained for the infinite plate with elliptic hole. This is due to the singularities in the solution of these two problems.  The computational cost of the solving with a   C   1   discretization (as in IGA) and a solving with a   C   0   discretization is not easy to compare. The   C   1   discretization allows convergence to a given error level with fewer degree of freedom compared to a   C   0   discretization, but a MG cycle is more expensive with the   C   1   discretization due to the fact that we are dealing with less sparse matrices. For the numerical examples presented here, the computational costs were approximately the same. These results highlight the interest of using a   C   1   discretization (as in IGA) compared to a   C   0   discretization (as in FEA). For the same amount of computational work, a solution with a higher continuity degree is obtained.  Here, the Cook\u05f3s membrane problem is solved using the FMG IGA algorithm for linear, quadratic and cubic basis functions. Fig. 23 (a) and (b) show the energy error indicator and the number of MG cycles until convergence for the three cases. As expected, the number of degrees of freedom needed to reach convergence decreases when the degree of the basis functions increase. However, the computational cost of the solving is not easy to interpret, as MG cycle is more expensive regarding the bandwidth of matrices involved.   CONCLUSION   The local h-refinement strategy based on multigrids presented in this paper allows the solving of mechanical problems with automatic refinement and controlled accuracy with IGA. We have demonstrated the good behavior of this algorithm and highlighted many of its advantages.  The use of the FMG with IGA allows us to deal with non-straight boundaries without going back to the CAD geometry for each refinement. Moreover, the continuity properties of IGA allows a better representation of the solution than with basis functions only   C   0   through element boundaries, like in FEA. Finally, the solution obtained is piecewise defined on different levels of dicretization allowing a local h-refinement with IGA, offering an alternative to hierarchical B-splines and T-splines.  The extension to three dimensional cases is natural with the tools presented and does not require further developments. Works are in progress to apply this algorithm to non-linear mechanical behaviors.  The analytic solution of the infinite elastic plate with an elliptic hole under biaxial traction is calculated for example in Gao [29]. Applied to an infinite elastic plate with an elliptic hole under uniform traction give us the following results (Fig. A1 ).  With the orthogonal curvilinear coordinate system resulting from the transformation function z = c cos ( \u03b6 ) , where z = x + iy and \u03b6 = \u03be + i \u03b7 , with c =     a   2   \u2212   b   2     and   \u03be   0   =   cosh   \u2212 1   (  a /     a   2   \u2212   b   2      ) , we have   {       \u03c3   \u03be \u03be     =   \u2212    1   2      \u03c3   \u221e     e   2   \u03be   0           +    1   2         \u03c3   \u221e     e   2   \u03be   0       cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 )    [  sinh ( 2 \u03be ) + cosh ( 2   \u03be   0   ) \u2212 cos ( 2 \u03b7 ) cosh ( 2 ( \u03be \u2212 \u03be 0 ) )  ]       +    1   2         \u03c3   \u221e     e   2   \u03be   0         ( cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) )   2      sinh ( 2 \u03be ) [  cos ( 2 \u03b7 ) \u2212 cosh ( 2   \u03be   0   )  ]       +    1   2         \u03c3   \u221e       ( cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) )   2      sinh ( 2 \u03be ) [  cosh ( 2 \u03be ) \u2212 cosh ( 2   \u03be   0   )  ]       \u03c3   \u03b7 \u03b7     =   \u2212    1   2      \u03c3   \u221e     e   2   \u03be   0           +    1   2         \u03c3   \u221e     e   2   \u03be   0       cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 )    [  sinh ( 2 \u03be ) \u2212 cosh ( 2   \u03be   0   ) + cosh ( 2 ( \u03be \u2212 \u03be 0 ) ) cos ( 2 \u03b7 )  ]       \u2212    1   2         \u03c3   \u221e     e   2   \u03be   0         ( cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) )   2      sinh ( 2 \u03be ) [  cos ( 2 \u03b7 ) \u2212 cosh ( 2   \u03be   0   )  ]       +    1   2         \u03c3   \u221e       ( cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) )   2      sinh ( 2 \u03be ) [  cosh ( 2 \u03be ) + cosh ( 2   \u03be   0   ) \u2212 2 cos ( 2 \u03b7 )  ]       \u03c3   \u03be \u03b7     =      1   2         \u03c3   \u221e     e   2   \u03be   0         ( cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) )   2      sin ( 2 \u03b7 )       \u00d7 [  sinh ( 2 ( \u03be \u2212   \u03be   0   ) ) ( cos ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) ) \u2212 cosh ( 2   \u03be   0   ) + cosh ( 2 \u03be )  ]       \u2212    1   2         \u03c3   \u221e       ( cosh ( 2 \u03be ) \u2212 cos ( 2 \u03b7 ) )   2      sin ( 2 \u03b7 ) [  cosh ( 2   \u03be   0   ) \u2212 cosh ( 2 \u03be )  ]           REFERENCES", "highlights": "This paper presents an isogeometric local h-refinement algorithm based on localized multigrid resolution dedicated to computational mechanics. This algorithm leads to a solution on a quasi-optimal refined mesh initially unknown for a given precision criterion. Moreover, it allows us to circumvent the obstacle of refinement of non-straight geometric boundaries existing in full multigrid algorithms with isoparametric finite element analysis."}