{"id": "S001044851500024X", "article": "MAIN-TITLE Analysis of an EMST-based path for 3D meshes   HIGHLIGHTS          We analysed sensitivity of the EMST structure to obtain a more robust synchronization.      We computed how a vertex can be moved without changing the connections.      We present a new theoretical analysis and a way to visualize EMST robustness.      We detect fragile area and to predict the 3D object robustness.      Keywords are Euclidean minimum spanning tree, Sensitivity analysis, Synchronization.          KEYPHRASES   Euclidean minimum spanning tree  Sensitivity analysis  Synchronization   Internet is very useful for broadcasting multimedia information. There are more and more 3D object exchanges in computer graphics, CAO and video games. Therefore, it is essential to produce efficient techniques for protecting, visualizing, sharing, printing and modifying these 3D objects. For these applications, it could be important to have a single 3D mesh path which orders the vertices. In this domain, this vertex ordering step is often called the synchronization step. Indeed, contrary to the 2D imaging field, where there is a trivial path with rows and columns, the case of 3D objects is more complex, even though the 3D mesh is semi-regular or regular. For example, in 3D data-hiding, it is essential to locate where the binary embedded data is distributed. This kind of path is used for synchronization with the aim of keeping the same order at inserting and extracting stages. A survey of 3D watermarking techniques has been proposed by Wang et\u00a0al.\u00a0 [1]. Watermarking techniques are interesting to protect the file content and also to embed meta-data. Data-hiding may be a way to have new functionalities, i.e. keeping the standard format without increasing the size. Another example of the benefits of having a single 3D mesh path is to produce a deterministic traversal of the mesh for 3D compression, as presented in a survey by Peng\u00a0et\u00a0al.\u00a0 [2].  The step which gives a mesh order is one of the main difficulties in compression, watermarking or visualization. Furthermore, in some specialized areas (medicine, industry), the position of vertices and the connectivity between them (in the 3D mesh) should not be affected by the path building process. Various methods have been proposed, but we are interested by the Euclidean Minimum Spanning Tree (EMST) method proposed by Amat et\u00a0al.\u00a0 [3]. The authors proposed a scheme which does not move any mesh vertex. They used an EMST to be able to scan the mesh in a unique manner for data synchronization.  Since the method is fragile, an EMST sensitivity analysis is necessary to determine the robustness threshold of an EMST-based on a 3D mesh. In this paper, we analysed the EMST sensitivity by computing how a vertex can be moved without changing the connections in the EMST. Since the problem is very difficult, we made some assumptions in order to make it tractable. It may also be interesting to quantify the EMST robustness. A sensitive analysis can be useful for some applications such as 3D reconstruction\u00a0 [4], 2D object recognition and classification\u00a0 [5], watermarking\u00a0 [3,6], compression\u00a0 [7] and segmentation\u00a0 [8]. For example, the proposed analysis could be used to improve the choice of the mark vertex selecting proposed by Wang\u00a0et\u00a0al.\u00a0 [9].  The rest of the paper is organized as follows. In Section\u00a0 2, we deal with the 3D path building issue. We present various classes of techniques, such as the synchronization by data structure (EMST). In Section\u00a0 3, we present the problem of EMST sensitivity. Then, in Section\u00a0 4, we propose a new approach to this problem by analysing the displacement of the vertex at each step of Prim\u2019s algorithm\u00a0 [10]. We assessed our theory in order to quantify the displacement of the vertices. The results are given in Section\u00a0 5 and our approach is validated. The discussion is concluded in Section\u00a0 6 and future work directions are mentioned.  3D processing is a comparatively new multimedia research field. One of the main problems in these applications is the ordering of 3D model data. In this section, we present ordering techniques based on a single path of 3D model. First, we present methods which only perform a path on a part of the mesh. Then we introduce some methods which order the patches created on the mesh. Finally, we present techniques that define a path along all vertices of the mesh.  One of the first paths for data-hiding watermarking techniques was proposed by Ohbuchi et\u00a0al.\u00a0 [11]. The algorithm and synchronization of the embedded message are quite simple. The idea, illustrated in Fig.\u00a01 , consists of duplicate facets of the mesh along a band that encodes the message. To start the duplication, a starting edge and an orientation of the triangles must be defined. To encode a \u20180\u2019, from the current edge, they have to duplicate the first edge they meet during the exploration, and for embedding a \u20181\u2019 they have to duplicate the second edge. The duplicated edge becomes the current one and the algorithm continues until all bits of the message are embedded.  With this approach, the mark is robust to geometrical modifications such translation, rotation and scaling. But it is visible and easily detectable, i.e. the algorithm is not secure. Moreover, vertices and facets are added and the size of the mesh increases as a function of the message size. Nevertheless, it is one of the first paths proposed for 3D blind data-hiding methods.  The idea behind creating a band, or performing a scan on the mesh to synchronize the hidden message is classic reasoning. For example, Mao et\u00a0al.\u00a0 [12] and Cayre et\u00a0al.\u00a0 [13] proposed almost the same approach to scan the mesh.  In the approach proposed by Mao et\u00a0al., they built a triangle path in the mesh to synchronize the data to be embedded, as illustrated in Fig.\u00a02 . They selected a starting triangle \u0394 , an edge e of \u0394 , and an orientation of this triangle. At each step, they choose one of the neighbour triangles as a function of the orientation and the previous step. From the current edge c , they scan the triangle in the direction of the orientation and select the last edge e of the current triangle \u0394 . Then they select the neighbouring triangle   \u0394   \u2032   , if it exists, such that e is the common edge between \u0394 and   \u0394   \u2032   . Then   \u0394   \u2032   becomes the current triangle, and will be scanned in the opposite direction. The orientation to scan the triangle alternates as illustrated in Fig.\u00a02. The operation continues until we do not need triangles to embed the hidden message.  In principle, this method does not create geometric error. However, the watermark can be detectable because it is a high density area in the mesh. Furthermore, such methods are obviously not robust against connectivity attacks.  In this section, we present some methods that create patches on the 3D mesh. This is an interesting approach to deal with certain constraints in the 3D mesh area such as malicious attacks or visible deformations induced by watermarking for example. In segmentation areas, a 3D mesh is partitioned following the model semantics. For example, Tierny\u00a0et\u00a0al.\u00a0 [14] proposed a method based on construction of the skeleton of the mesh that produces a small number of patches. These patches are quite semantically correct, but there are few of them and they are not ordered. Defining a path in a mesh requires a higher number of patches and a very deterministic algorithm.  Luo and Bors\u00a0 [15] proposed an efficient watermarking scheme based on regions of equal geodesic distance. These distances are calculated from a chosen vertex (in red in Fig.\u00a03 ).  Each strip in Fig.\u00a03(b) is used for embedding a single bit, while the region around the source, which is shown in blue, is trimmed away. Patches are created thanks to their geodesic distance from a vertex, so they are ordered by construction.  Wang et\u00a0al.\u00a0 [16] proposed another synchronization for their watermarking method that is based on generating a cylindrical system patch by discretizing its h and \u03b8 domains. Patches are ordered according to their spatial locations. In another paper, Wang et\u00a0al.\u00a0 [17] proposed to use manifold harmonics and to quantify the amplitudes of some low frequencies coefficients in order to hide a 16-bit watermark (see Fig.\u00a04 ).  The Edgebreaker mesh compression algorithm proposed by Rossignac\u00a0 [18] is a mono-resolution algorithm, i.e. it does not allow access before full load. It puts the vertices and facets in order at the same time without redundancy, as illustrated in Fig.\u00a05 . The scan is also unique, as it depends on the first vertex and the first triangle chosen.  This technique is based on region growing that incrementally encodes facets and their relations. Thanks to this algorithm, we obtain a unique sequence of vertices that totally defines the mesh.  To illustrate the need for a well defined order in a 3-D mesh, we present two watermarking techniques which are based on previous synchronization methods. The watermarking of Bogomjakov et\u00a0al.\u00a0 [19] is based on swapping elements in the file. The synchronization step can be done by any kind of deterministic mesh traversal and they use the traversal performed by the Edgebreaker \u00a0 [18] algorithm. This example shows that ordering vertices of a 3-D mesh in a robust way is a relevant goal to produce more and more applications in this area. Another method proposed by Wang and Men illustrates that the synchronization is determined only by the file ordering\u00a0 [20].  In the method proposed by Amat\u00a0et\u00a0al.\u00a0 [3], data embedding in the mesh is based on modification of the connection between the vertices in the mesh, without moving the vertices. In order to synchronize the message, an EMST is computed. Fig.\u00a06 (a) illustrates the EMST of a horse mesh (504 vertices). The EMST is unique, depending on a seed vertex   v   0   , while the path of vertices is also unique. This can be a synchronization tool because we can scan the EMST with a single path. Amat et\u00a0al.\u00a0 [3] selected quadruples, a vertex and its three sons in the EMST to embed one bit per quadruple, if possible. In order to avoid visual distortion and desynchronization, the quadruples must verify three conditions: coplanarity, the measure of the angle formed by the two triangles must be close to 0; convexity, to scan the same geometrical space; and if two quadruples are neighbours or overlapped, then only one of them is used for the embedding.  However, this method produces fragile watermarking, i.e. if the mesh is modified then the watermark is not extractable. The problem is to know how this method is stable. Indeed, if it is fragile enough to detect any modification. Conversely, we want to know how the method is robust against vertex displacement in order to find new tracks for robust watermarking. We focus on this original method to quantify the fragility of the data synchronization by studying the robustness of the EMST. Indeed, as we can see Fig.\u00a06(b) which is the EMST of the noisy horse mesh with \u03c3 = 1   0   \u2212 2   , the EMST computed on a mesh is very sensitive to vertex displacement. Fig.\u00a06(c) illustrates the comparison between the original horse mesh and the noisy one. The problem is well known in the graph theory for the minimum spanning tree (MST), but has not been very well studied in the geometrical case (i.e. EMST). We discuss the state of the art of the analysis of the MST sensitivity in Section\u00a0 3.  In this section, we present how the problem of EMST sensitivity may be defined with various approaches.  As per this paper, we have taken a cloud of vertices V and explored how we can move a vertex in space without changing the connections E in the Euclidean minimum spanning tree T =  ( V , E )  . Let G =  ( V , E )  be a graph with n nodes and m edges. An EMST is MST which is based on the Euclidean distance, i.e, a tree T =  ( V ,   E   T   )  which joins all the vertices of a graph G =  ( V , E )  using the edges   e   i   =  {   v   s   ,   v   t   }  \u2208 E , with a weight \u03c9  (   e   i   )  \u2208   R   +   , that minimizes the total weight   \u2211     e   i   \u2208   E   T     \u03c9  (   e   i   )  .  Our approach is based on Prim\u2019s algorithm in order to have an incremental algorithm. At each step we have a sub-tree   T   i   =  (   V   i   ,   E   i   )  of the final EMST. The algorithm starts with a seed vertex   v   0   \u2208 V . We note    (   T   i   )    i \u2264 n   =  (    (   V   i   )    i \u2264 n   ,    (   E   i   )    i \u2264 n   )  the tree sequence representing the EMST construction pattern.  With these notations   T   0   =  (  {   v   0   }  , 0\u0338 )  . At each step i > 0 , the algorithm adds the closest vertex   v   i   \u2208     V  \u00af    i \u2212 1   to   V   i \u2212 1   and to   E   i \u2212 1   it adds the connection between   v   i   and the closest vertex of   v   i   in   V   i \u2212 1   that we call its \u201cfather\u201d and denote by f  (   v   i   )  .  Hence, we deduce:   (1)    V   i   =   V   i \u2212 1   \u222a  {   v   i   }  ;    (2)    E   i   =   E   i \u2212 1   \u222a  {   v   i   , f  (   v   i   )  }  .       The Minimum Spanning Tree (MST) is a well-known problem in graph theory. It is a polynomial problem that is solved by two famous algorithms, i.e Prim\u2019s\u00a0 [10] and Kruskal\u2019s\u00a0 [21]. For a given MST T , it is interesting to know which connections are fragile, and which are not. The MST sensitivity problem may answer this question. MST sensitivity is also a polynomial problem. In this section, we have presented an approach for solving the problem and we draw a conclusion for our application.  For Gordeev\u00a0 [22,23], the MST sensitivity analysis is an optimization problem based on matroids. The aim is to determine the maximum intensity of a disruptive vector such that the solution of the optimization problem remains a solution after the perturbation. Gordeev considers the following model: let   D   m   =  {   T   1   , \u2026 ,   T   q   }  , with  ( q > 1 )  being a system of subsets of E called trajectories; A =  (   a   1   , \u2026 ,   a   m   )  \u2282   R   m   such that \u2200 i    a   i   = \u03c9  (   e   i   )  , the weight of the edges of the graph G and \u03c9  (   T   A   )  a functional called the trajectory length for A , such that \u03c9  (   T   A   )  =   \u2211     e   i   \u2208 T     a   i   . Therefore, the combinator problem is defined with the pair  ( E ,   D   m   )  , A is the variable to optimize in order to minimize the functional \u03c9  (   T   A   )  . Gordeev models the MST problem with   D   m   , the set of all spanning trees of G in which the MST is a trajectory that minimizes the functional \u03c9  (   T   A   )  .  Let \u03c8  ( A )  be the index set i of the optimal trajectories   \u03c4   i   of the problem for a given A , and B \u2208   R   m   , such that for \u03f5 \u2208   R   +   \u2217   ,  \u2016 B \u2016  < \u03f5 is a perturbation vector. Gordeev talks about \u03f5 -stability when \u03c8  ( A + B )  \u2282 \u03c8  ( A )  . In the MST problem, for a given noise intensity \u03f5 , some MST are always solutions of the MST problem after the perturbation. He deduces a stability radius \u03c1  ( A )  = sup \u03f5 , such that A is \u03f5 -stable for the problem. Its algorithm is polynomial and its complexity is O  (   n   3   m log  (     n   2     m   )  )  and for a complete graph O  (   n   5   )  .  For Dixon et\u00a0al.\u00a0 [24] the sensitivity analysis problem is, for a given graph G =  ( V , E )  and T =  ( V ,   E   T   )  its MST, to know how each edge value can be modified (for   e   i   \u2208   E   T   and   e   i   \u2208 E \u2216   E   T   ) without changing the connections of T . They divide the problem into two parts. For \u2200   e   i   \u2209   E   T   , they compute how much they can decrease \u03c9  (   e   i   )  without changing the MST and, for all the edges   e   i   \u2208   E   T   , they compute how much they can raise the weight of   e   i   , \u03c9  (   e   i   )  without changing the MST. This step has a linear time complexity as a function of the number of edges.  The aim of Yaman et\u00a0al.\u00a0 [25] is to introduce a robust version of the MST where the edge costs are specified as interval numbers. It is a spanning tree such that the weight of the tree minimizes the maximum deviation from the MST. They introduce the notion of a weak tree, and it is an MST for some scenarios. In other words, for different edge valuations, the weak tree is not always an MST. Then, an edge is a weak edge if it lies on some weak tree. On the contrary, an edge is a strong edge if it lies on an MST for all possible edge evaluations. Their goal is to define a robust spanning tree, so they introduce two robustness measures for the MST problem, \u201cabsolute robustness\u201d and \u201crelative robustness\u201d. These measures are used to characterize the worst case scenario, and then they use mixed integer programming to find a robust spanning tree. This method is very interesting for small graphs but it has huge complexity.  For each step of the Prim\u2019s algorithm, we want to compute the area in which the vertex   v   i   \u2208   V   i   can be moved without changing the connection in the EMST. This area depends on the seed vertex (denoted   v   0   ) and the vertices selected before   v   i   . Fig.\u00a07 illustrates that the EMST changes when a vertex moves too much. Distinguish EMST between the vertex ordering is necessary to well understand the analysis. Nevertheless, we point out that the ordering given by Prim\u2019s algorithm is dramatically dependent of the EMST stability.  To compute this area we make the following simplification assumptions on the disruption of vertices: Assumption\u00a03.1 At the step i > 0 of Prim\u2019s algorithm, we will disturb only the position of the vertex   v   i   , resulting in the disturbed vertex   v   \u2217   ;    Assumption\u00a03.2 The geometric disruption will be restricted to only be along the half-line  ] f  (   v   i   )  ;   v   i   )  .  After the perturbation,   T   i   \u2217   =  (   V   i   \u2217   ,   E   i   \u2217   )  denotes the graph sequence with   V   i   \u2217   =  {   v   0   \u2217   ,   v   1   \u2217   , \u2026 ,   v   i   \u2217   }  . Suppose that \u2200 k ; k < i the EMST at step k is always the same (   T   k   =   T   k   \u2217   ). This is an important hypothesis, and we note that it is not always verified. Indeed, we simplified the problem by taking into account these assumptions, in order to compute the intrinsic vertex properties. At the step i , supposing that   T   k   \u2217   \u2260   T   k   ,  \u2200 k \u2260 i , implies that the radius   r   i   of   v   i   depends of the previous ones.  Then, to keep the same connections in the EMST, we need to verify these two conditions:  1.     v   \u2217   =   v   i   \u2217   ,   v   \u2217   is selected at the i th step of Prim\u2019s algorithm;    f  (   v   \u2217   )  = f  (   v   i   \u2217   )  , the father of   v   \u2217   is still the father of   v   i   .  In this section, we propose to analyse the sensitivity of the EMST by analysing the vertex displacement. In this paper, we limit the vertex displacement analysis along the half-line  ] f  (   v   i   )  ;   v   i   )  . To compute the possible displacement of each vertex without changing the connection in the EMST, we divide the problem into two parts. In Section\u00a0 4.1, we present how the vertex   v   i   can come up to f  (   v   i   )  . We compute a minimum distance limit of \u03c9  (  {   v   \u2217   , f  (   v   i   )  }  )  denoted by   d   i   \u2212   and deduce a displacement radius   r   i   \u2212   . In Section\u00a0 4.2, we explain how   v   i   can move away from f  (   v   i   )  . We also compute a maximum distance limit of \u03c9  (  {   v   \u2217   , f  (   v   i   )  }  )  denoted by   d   i   +   and deduce a displacement radius   r   i   +   . Then, in Section\u00a0 4.3 we show how to keep the EMST stable at the step i + 1 . Finally, in Section\u00a0 4.4, we define a global displacement radius denoted by r .  In this section, we are interested in the approximation of   v   i   to its father f  (   v   i   )  . As we know, f  (   v   i   )  is the closest vertex of   v   i   in   V   i \u2212 1   , as illustrated in Fig.\u00a08 . Obviously, f  (   v   i   )  was selected before   v   i   in Prim\u2019s algorithm. Let f  (   v   i   )  =   v   k   and   V   k   =  {   v   j   : j \u2264 k }  , then we deal with the vertices   v   j   \u2208   V   i   \u2216   V   k   and the edges   e   j   \u2208   E   i \u2212 1   \u2216   E   k   to verify the following properties. Proposition\u00a04.1  Let    T   i   =  (   V   i   ,   E   i   )   be the state of the EMST at the  i  th step of Prim\u2019s algorithm, with the previous notations, if    E   i \u2212 1   \u2216   E   k   \u2260 0\u0338  , we have:   (3)  \u2200   e   j   \u2208   E   i \u2212 1   \u2216   E   k   ;  \u03c9  (   e   j   )  < \u03c9  (  { f  (   v   i   )  ,   v   i   }  )  .        Proposition\u00a04.2  Let    d   i   \u2212    be the minimum distance between  f  (   v   i   )   and    v   \u2217    , then in order to keep the same connections in the EMST we must have  \u03c9  (   v   \u2217   , f  (   v   i   )  )  >   d   i   \u2212    with:   (4)    d   i   \u2212   = max  { \u03c9  (   e   j   )  :   e   j   \u2208   E   i \u2212 1   \u2216   E   k   }  .    This proposition guarantees that    T   k + 1   \u2217   =   T   k + 1   , \u2026 ,   T   i   \u2217   =   T   i    , under Assumption \u00a03.1 , i.e.    T   j   \u2217   =   T   j   , j \u2208  { 0 , \u2026 , k }   . We deduce the displacement radius:   (5)    r   i   \u2212   = \u03c9  (  { f  (   v   i   )  ,   v   i   }  )  \u2212   d   i   \u2212   .        Proof Let   e   l   =  { f  (   v   l   )  ,   v   l   }  be the edge, if it exists, verifying   e   l   =   max     e   j   \u2208  (   E   i \u2212 1   \u2216   E   k   )    \u03c9  (   e   j   )  . If this edge does not exist,   d   i   \u2212   = 0 , so we can move the vertex   v   i   as close as we want to f  (   v   i   )  . We suppose that there is at least one edge   e   l   :     d   i   \u2212   = \u03c9  ( f  (   v   l   )  ,   v   l   )  .   It is important to note that k \u2264 l < i , in other words, in the chronological vertex selection in Prim\u2019s algorithm,   v   k   is selected before   v   l   , and   v   l   before   v   i   . To demonstrate reductio ad absurdum, Proposition\u00a04.2 must be verified to keep the same order in the sequence    (   V   j   \u2217   )    j \u2264 i   .  Supposing:    \u03c9  ( f  (   v   \u2217   )  ,   v   \u2217   )  \u2264   d   i   \u2212   \u21d2 \u03c9  ( f  (   v   \u2217   )  ,   v   \u2217   )  \u2264 \u03c9  ( f  (   v   l   \u2217   )  ,   v   l   \u2217   )  . At the  ( l \u2212 1 )  th step of Prim\u2019s algorithm, we know f  (   v   i   \u2217   )  , f  (   v   l   \u2217   )  \u2208   V   l \u2212 1   . According to the hypothesis \u03c9  ( f  (   v   \u2217   )  ,   v   \u2217   )  \u2264 \u03c9  ( f  (   v   l   \u2217   )  ,   v   l   \u2217   )  , so   v   \u2217   will be chosen at the    ( l \u2212 1 )    t h   step. That is in contradiction with the EMST stability.  Obviously   v   i   is the closest node of f  (   v   i   )  in V \u2216   V   i   , if we move   v   i   along the half-line  ] f  (   v   i   )  ;   v   i   )  closer to f  (   v   i   )  , then the resulting vertex   v   \u2217   \u2208 V \u2216   V   i   is the closest node of f  (   v   i   )  . In conclusion, the father of   v   i   is also the father of   v   \u2217   with this displacement.\u25a1  Now we are interested in the distance of   v   i   from its father f  (   v   i   )  . In order to keep the EMST connections up to step i of Prim\u2019s algorithm, we divide this problem into two cases. Firstly, we are looking for the second closest vertex s  (   v   i   )  to   V   i \u2212 1   to select vertex   v   \u2217   at the i th step, as illustrated in Fig.\u00a09 (a). We consider the distance \u03c9  (  ( f \u2218 s )   (   v   i   )  , s  (   v   i   )  )  .    Proposition\u00a04.3  Let    T   i    be the state of the EMST at the  i  th step of Prim\u2019s algorithm, then in order to keep the connection of the EMST at step  i  we need to verify this first condition:   (6)  \u03c9  ( f  (   v   i   )  , v \u2217 )  < \u03c9  (  ( f \u2218 s )   (   v   i   )  , s  (   v   i   )  )  .       We denote    d   i   1   = \u03c9  (  ( f \u2218 s )   (   v   i   )  , s  (   v   i   )  )   .   Secondly, to keep the same father f  (   v   i   )  , we compute the intersection x  (   v   k   )  between the half-line  ] f  (   v   i   )  ;   v   i   )  and the perpendicular bisector of the segment  [ f  (   v   i   )  ,   v   k   ]    (   v   k   \u2208   V   i \u2212 1   ,   v   k   \u2260 f  (   v   i   )  )  , as illustrated in Fig.\u00a09(b). Proposition\u00a04.4  Let    T   i    be the state of the EMST at the  i  th step of Prim\u2019s algorithm, then in order to keep the connection of the EMST at step  i  we need to verify this second condition:   (7)  \u03c9  ( f  (   v   i   )  ,   v   \u2217   )  < min  { \u03c9  ( f  (   v   i   )  , x  (   v   k   )  )  :   v   k   \u2208   V   i \u2212 1   ,   v   k   \u2260 f  (   v   i   )  }  .       We denote    d   i   2   = min  { \u03c9  ( f  (   v   i   )  , x  (   v   k   )  )  :   v   k   \u2208   V   i \u2212 1   ,   v   k   \u2260 f  (   v   i   )  }   .     Proposition\u00a04.5  Let    T   i    be the state of the EMST at the  i  th step of Prim\u2019s algorithm, then in order to keep the connection of the EMST at step  i  we need to verify  \u03c9  ( f  (   v   i   )  ,   v   \u2217   )  <   d   i   +    , with:   (8)    d   i   +   = min  {   d   i   1   ,   d   i   2   }  .    Under Assumptions \u00a03.1 and 3.2 , i.e.    T   j   \u2217   =   T   j   , j \u2208  { 0 , \u2026 , i \u2212 1 }   . We deduce the displacement radius:   (9)    r   i   +   =   d   i   +   \u2212 \u03c9  (   v   i   , f  (   v   i   )  )  .        Proof Let us demonstrate reductio ad absurdum that \u03c9  ( f  (   v   \u2217   )  ,   v   \u2217   )  <   d   i   1   must be verified to keep the same order in the sequence    (   V   i   \u2217   )    0 < i < n   .  We suppose \u03c9  ( f  (   v   \u2217   )  ,   v   \u2217   )  \u2265   d   i   1   = \u03c9  ( s  (   v   i   )  ,  ( f \u2218 s )   (   v   i   )  )  . According to this hypothesis,   v   i   is the closest vertex of   V   i \u2212 1   , and s  (   v   i   )  the second one. Then   v   i   is disturbed in   v   \u2217   but the other vertices do not move. Moreover  ( f \u2218 s )   (   v   i   )  , f  (   v   \u2217   )  \u2208   V   i \u2212 1   and s  (   v   i   )  ,   v   \u2217   \u2208 V \u2216   V   i \u2212 1   . Prim\u2019s algorithm at step i chooses the closest vertex of   V   i \u2212 1   which is s  (   v   i   )  .   v   \u2217   is too far from f  (   v   i   )  , so to verify the condition of our EMST stability problem \u03c9  ( f  (   v   \u2217   )  ,   v   \u2217   )  <   d   i   1   .\u25a1  Let   v   k   \u2208   V   i \u2212 1   be a vertex satisfying the relation \u03c9  (   v   k   , x  (   v   k   )  )  =   min     v   j   \u2208   V   i \u2212 1     \u03c9  (   v   j   , x  (   v   j   )  )  . Obviously, on the line  ( f  (   v   i   )  ,   v   i   )  , the vertices  { f  (   v   i   )  ,   v   i   , x  (   v   k   )  }  are aligned in this order.  Moreover, x  (   v   k   )  is the equidistant vertex between f  (   v   i   )  and   v   k   . It clearly separates the half-line  ]   v   i   ; x  (   v   k   )  )  into two parts:  \u2022   \u2200   v   \u2217   \u2208  ]   v   i   ; x  (   v   k   )  [  , \u03c9  ( f  (   v   i   )  ,   v   \u2217   )  < d  ( f  (   v   i   )  , x  (   v   k   )  )  ,   v   \u2217   is closer to f  (   v   i   )  than   v   k   ;    \u2200   v   \u2217   \u2208  ] x  (   v   k   )  ; \u221e )  , \u03c9  ( f  (   v   i   )  ,   v   \u2217   )  > d  ( f  (   v   i   )  , x  (   v   k   )  )  ,   v   \u2217   is closer to   v   k   than f  (   v   i   )  .  It proves the proposition.\u25a1  The stability of the EMST, requires also that the next vertex is still the same. Suppose that   v   i   is selected at the i th step of Prim\u2019s algorithm, the next chosen vertex is   v   i + 1   ,   v   i + 1   =    argmin      v   j      { w  (   v   k   ,   v   j   )  :   v   k   \u2208   V   i   ,   v   j   \u2208 V \u2216   V   i   }  . We have shown that under some assumptions   v   i   =   v   i   \u2217   , in the same way, we show that we can restrict the displacement of   v   i   to have the same next vertex and maintain the EMST at the i +   1   t h   step of Prim\u2019s algorithm. We divide this problem in two cases, indeed the next chosen vertex is s  ( v i )  , described in the previous section, or is given by   v   i + 1   =    argmin      v   j      { w  (   v   i   \u2217   ,   v   j   )  :   v   j   \u2208 V \u2216   V   i   }  . Thus this case, is included in the previous analysis.  In the second case, to keep the same next vertex   v   i + 1   , we compute the intersection x  (   v   k   )  between the half-line  ] f  (   v   i   )  ;   v   i   )  and the perpendicular bisector of the segment  [   v   i + 1   ,   v   k   ]    (   v   k   \u2208 V \u2216   V   i   ,   v   k   \u2260   v   i + 1   )  , as illustrated in Fig.\u00a010 . Proposition\u00a04.6  Let    T   i    be the state of the EMST at the  i  th step of Prim\u2019s algorithm, then in order to keep the connection of the EMST at step  i + 1  , we need to verify:   (10)  \u03c9  (   v   \u2217   ,   v   i + 1   )  < min  { \u03c9  (   v   i   , x  (   v   k   )  )  :   v   k   \u2208 V \u2216   V   i   ,   v   k   \u2260   v   i + 1   }  .       We denote    d   i   3   = min  { \u03c9  (   v   i   , x  (   v   k   )  )  :   v   k   \u2208 V \u2216   V   i   }   .     Proposition\u00a04.7  Let    T   i    be the state of the EMST at the  i  th step of Prim\u2019s algorithm, then in order to keep the connection of the EMST at step  i  we need to verify  \u03c9  (   v   \u2217   ,   v   i + 1   )  <   d   i   3    , we deduce the displacement radius:   (11)    r   i   2   =   d   i   3   .      In Sections\u00a0 4.1 and 4.2, we defined two radii of displacement   r   +   and   r   \u2212   . In order to have a single measure of the possible vertex displacement without changing the EMST, we need to verify all the conditions that allow us to compute these parameters independently of the displacement direction.  Let   r   i   =   r   i   = min  {   r   i   +   ,   r   i   \u2212   ,   r   i   2   }  be the displacement radius of the vertex   v   i   along the half-line  ] f  (   v   i   )  ;   v   i   )  . Then x =   1    \u2016 f  (   v   i   )  .   v   i   \u2016     (   v   i   \u2212 f  (   v   i   )  )  denotes the normalized director vector of the half-line  ] f  (   v   i   )  ;   v   i   )  .  Therefore, if   v   \u2217   \u2208  ]   v   i   \u2212 r \u22c5 x ;   v   i   + r \u22c5 x [  the EMST will not be modified at the i th step of Prim\u2019s algorithm. We have defined a scope where the EMST does not change, in this context the vertex ordering done by the Prim algorithm is stable. However, we are aware that modifying the EMST could change dramatically the order defined, even if the percentage of common edge is high.   EXPERIMENTAL RESULTS   In this section, we experimentally analysed the minimum and maximum distance limits   r   i   \u2212   and   r   i   +   presented in Section\u00a0 3 for each vertex   v   i   of several 3D objects. In Section\u00a0 5.1, we describe the experimental conditions. Then, in Section\u00a0 5.2 we present a full example with the 3D object Horse and an analysis of the vertex displacement to comment the results. We also present the result of our analysis by viewing the robust areas on the 3D object Horse. Finally, in Section\u00a0 5.3 we validate the experimental results with the proposed theoretical analysis.  For the experiments, we used a database consisting of more than 20 3D meshes selected from various sources (Stanford University Graphics Laboratory, 1   1  http://www-graphics.stanford.edu. MADRAS project, 2   2  http://www-rech.telecom-lille1.eu/madras. Strategies S.A 3   3  http://www.cadwin.com. and Aimatshape 4   4  http://www.aimatshape.net. ). Their shapes are very different, as illustrated in Fig.\u00a011 , and they are used for different application fields, such as CAD, manufacturing, medicine or entertainment. In this section, we assume that the first vertex is randomly selected. Indeed, if we change the selection of the first vertex   v   0   \u2192   v   0   \u2032   , the same EMST is generated ( T =   T   \u2032   ). In this case the vertex ordering will be different, so   r   i   \u2260   r   i   \u2032   ,  i \u2208  [ 1 , n \u2212 1 ]  in general. But the distribution of the most robust vertices does not change. We choose the first vertex as a parameter, it could be used to define a different order on the EMST. Moreover, we have defined a scope where the EMST does not change, in this context the vertex ordering done by the Prim algorithm is stable. However, we are aware that modifying the EMST could change dramatically the order defined, even if the percentage of common edge is high.  In order to reduce the complexity and to compare these meshes, we sub-sampled them to have approximately 1000 vertices for each 3D mesh. Indeed, for larger 3D objects, we assumed that is always possible to sub-sample them to keep the most interesting vertices. This can be done by a simple decimation, or on a sub-resolution or a clustering method. In fact the complexity of the analysis of EMST algorithm is in O  (   n   3   )  . Indeed, as presented in Algorithm 1, the complexity of computing Prim\u2019s algorithm is in O  (   n   3   )  since for computing the second closest vertex we should calculate all the distances between the vertices   v   j   in   V   i \u2212 1   ,   v   j   \u2260 f  (   v   i   )  and the vertices in V \u2216   V   i   . Moreover, our radius (given by multiple calculations) can be computed at each step without increasing the upper bound of the complexity, but we add a great factor in each main loop.          Moreover, in order to be able to compare their disruptions, we normalized these objects and then k \u2208 R denotes the scaling factor of the normalization. For these experiments we normalized the object in two different manners:  1. As a function of the size of the bounding box (normalization (1)):   k = max  {   x    max    \u2212   x    min    ;   y    max    \u2212   y    min    ;   z    max    \u2212   z    min    }  .      As a function of the average distance between two vertices in the mesh (normalization (2)):   k =   1   m     \u2211     v   i   ,   v   j   \u2208 V   \u03c9  (   v   i   ,   v   j   )  .      The results of our analysis are presented for the mesh Horse normalized by the normalization (1) illustrated in Fig.\u00a011(d). Fig.\u00a012 (a) and (b) respectively present the distributions of the vertices as a function of the radius values. The values are sampled with a step of 10\u22123.  Note that there are many vertices that cannot be moved in one direction, e.g.    r   \u2212   \u2243 0 or   r   +   \u2243 0 . In the case of the 3D object Horse, we have more than 20% for the radius   r   \u2212   which is close to zero and around 30% of the radius   r   +   are close to zero. As the radius value of a vertex becomes more significant, this vertex can be moved more and ultimately be more robust. However, the results illustrated in Fig.\u00a012(a) and (c) show that a significant part of the vertices can be moved, but this also reveals the fragility of EMST structures.  For the radius   r   +   , the occurrences decrease very fast as the radius value increases. We observed that the maximum value for   r   +   is around 1.8\u00d710\u22122 (Fig.\u00a012(a)) whereas as for   r   \u2212   (Fig.\u00a012(c)) the maximum value is around 4\u00d710\u22122. We can thus deduce from this experiment that it is easier to move a vertex   v   i   towards its father f  (   v   i   )  than to take it away. Then, for radius   r   \u2212   (Fig.\u00a012(c)) we note an interesting peak between 1.5\u00d710\u22122 and 2\u00d710\u22122. With this observation, we can consider two kinds of vertices: those which cannot be moved closer to their father and those that can be moved closer to the closest possible of their fathers. Fig.\u00a012(b) and (d) illustrate the cumulative functions of   r   +   and   r   \u2212   respectively. Fig.\u00a012(c) shows an inflection point near 1.5\u00d710\u22122. For the last case, in Fig.\u00a012(e) we can see that the radius   r   2   has a maximum distribution around 0.0233 which is much larger than the radius   r   +   . Fig.\u00a012(f) shows the cumulative distribution which proves that most of the vertices have a radius   r   2   \u2208  [ 0.02 , 0.3 ]  . This behaviour is observed in our database, we propose to present the next result with a radius r defined as: r = min  {   r   +   ,   r   \u2212   }  , since by experiments the radius   r   2   has a very low influence.  After these detailed observations on the 3D object Horse, we compare the behaviour of criteria   r   +   and   r   \u2212   on seven 3D objects of our database. Fig.\u00a013 (a) and (b) illustrate, respectively, the distributions of the vertices for the 3D objects normalized as a function of the size of their bounding box (normalization (1)). Fig.\u00a013(c) and (d) illustrate, respectively, the distribution of the same 3D objects normalized as a function of the average distance between two vertices in the mesh. The distributions of   r   +   seem to be the same for the seven objects we analysed. The main part of the vertices cannot be moved, as we have previously seen for the 3D object Horse, but some of them can be moved. In particular, for criterion   r   \u2212   , we also notice the same shape as Horse. Indeed, a lot of vertices cannot be moved, but we observed a peak around a particular value which corresponds to the average distance between two vertices. In Fig.\u00a013(c), we can validate this intuition because the peak is around the same value. Indeed, this peak is a function of the average distance between two vertices of the mesh.  In order to determine how a vertex can be moved, we propose to let a criterion r quantify the possible motion of each vertex. Thus, for each vertex, we calculate:     r   i   = min  {   r   i   +   ,   r   i   \u2212   }  .      The distribution of this new criterion r is illustrated in Fig.\u00a014 , and compared to   r   +   and   r   \u2212   .  In Fig.\u00a015 we visualized the more robust vertices in order to locate the most robust areas. These mesh parts could be used to synchronize hidden data during a watermarking process for example. Fig.\u00a015(a) and (c) illustrates the original mesh of the 3D object Horse, while Fig.\u00a015(b) and (d) illustrates the result of the visualization. The darker colours correspond to the most fragile areas, whereas the lighter colours correspond to the most robust areas.  As we can notice, a large number of areas, illustrated in darker colour, seem to be rather fragile. We can also notice, for the most robust areas, that the space between them and their neighbourhoods are not regular. This might be a clue for the search of geometrical criteria.  To validate our proposed theory, we need to have a relationship between the theoretical criteria as a function of   r   +   and   r   \u2212   presented in Section\u00a0 3, and the experimental measures as a function of the percentage of the common edge rate between the EMST of the original mesh and the EMST of a noisy one. First, we select x % of the most robust vertices which are the most mobile vertices in the original EMST, where   r   i   >   r   x %   .  Let T \u200bdenote the EMST of the original mesh and   T   \u03c3   the EMST of a noisy mesh such that the noise is Gaussian and its standard deviation equals \u03c3 . In fact, the analysis can be done by determining the correlation between   r   x %   and the intensity of the Gaussian noise added to the 3D mesh.  Let   \u03c3   x %   be the critical standard deviation \u03c3 of the Gaussian noise such that its mean \u03bc  ( T ,   T   \u03c3   )  = x % . For the experiments, we take several 3D objects and we set x to compute, for each mesh, the values of   r   x %   and   \u03c3   x %   . We repeat this experiment 100 times for each 3D object.  In Fig.\u00a016 , for different selection rate   x   %   , the critical standard deviation as a function of our theoretical criterion is presented. Each 3D object is linked to a point in the graph. The x -axis corresponds to the theoretical criterion   r   x %   and the y -axis to the critical standard deviation   \u03c3   x %   . For each selection rate, x = 10 % (Fig.\u00a016(a)) x = 20 % (Fig.\u00a016(b)) and x = 30 % (Fig.\u00a016(c)), we obtain a straight line. Indeed, there is a linear relationship between   r   x %   and   \u03c3   x %   that does not depend on x :     \u03c3   x %   = k \u22c5   r   x %   .      We estimate k , the value of the coefficient of the linear correlation by linear regression, for various vertex selection rates x . Table\u00a01 presents the results.  We also noticed that for x > 30 % , we do not obtain a straight line. The behaviour of the criterion is chaotic because the areas selected are not robust. If some fragile vertices are selected (i.e.    r   x %   is too small), the disturbed vertex is out of its displacement cell and creates disorder in the EMST. This disorder results in a non-correlation of our criterion. In future work, it will be interesting to formalize this study in a theoretical context. This kind of technique should be interesting with various criteria that we are studying, such as estimation of the discrete curvature. The aim is to find a stable criterion in order to use the synchronization in a robust watermarking scheme.  In this paper, we have presented a theoretical analysis of the displacement of vertices without changing the connections in the EMST. Moreover, we have proposed a theoretical criterion in line with the Gaussian noise model in order to select the   x   %   most robust vertices. The proposed approach could be used to synchronize data for several 3D techniques such as watermarking or compression. In this paper, we limited the vertex displacement analysis along the half-line  ] f  (   v   i   )  ;   v   i   )  ,Assumption\u00a03.2 and we assumed that this analysis can be done independently for each vertex, Assumption\u00a03.1. These assumptions are not too much restrictive in the case of watermarking and compression applications where each vertex is processed one by one. In particular, with this analysis, we are able to locate robust areas that could be used for message embedding with the watermarking technique proposed by Amat et\u00a0al.\u00a0 [3].  To continue this work, from a theoretical standpoint, it would be interesting to reduce the chosen constraints of our study. For a given step of Prim\u2019s algorithm, we would like to know how to move the vertex in three dimensions without changing the EMST built in the previous steps and without any a priori or hypotheses about these steps.  We would also like to link this study with 3D robust watermarking in order to build a new synchronization technique using EMST. This is a challenge since EMST is a fragile approach. For example, it might be interesting to build a tree with only the most robust areas for synchronization with the aim of being robust against attacks. Of course, the synchronization is strongly connected with the watermarking method and the application. For example, Su\u00a0et\u00a0al. proposed a very specific watermarking method for CAPD where the synchronization is a function of the flow direction\u00a0 [26].   REFERENCES", "highlights": "For several 3D data applications such as data-hiding or compression, data ordering is a major problem. We need to know how to achieve the same 3D mesh path between the coding and decoding stages. Various algorithms have been proposed in recent years, but we focus on methods based on Euclidean Minimum Spanning Trees (EMST). In this paper, we analyse the sensitivity of the EMST structure to obtain a more robust synchronization. We present a new theoretical analysis and a way to visualize EMST robustness. Moreover, this analysis can be useful in 3D data-hiding in order to detect fragile area and to predict the 3D object robustness during transmission on a noisy channel."}