{"id": "S001044851400102X", "article": "MAIN-TITLE A geometric reasoning approach to hierarchical representation for B-rep model retrieval   HIGHLIGHTS          Hierarchy of B-rep model is generated by geometric reasoning automatically.      This shape descriptor eases global and partial retrieval at level of detail.      Interactive prototype system gives why and how similar features are matched.          KEYPHRASES   Geometric reasoning  Hierarchical representation  Solid model retrieval   3D solid models are extensively used in Computer Aided Design and there is notably increasing requirements of their retrieval. Designers benefit from design reuse, in which they copy\u2013paste an ideal source model or partial of it instead of re-designing from scratch. Finding the ideal model with specific feature distribution from design repositories, however, costs time and energy. Industrial companies implement Product Data Management (PDM) systems to reduce duplication, but how to identify two same models by different names is still challenging. Case-Based Reasoning (CBR) is another important application, which is regarded as the learning technique from past experience to benefit future design. It is formalized as 4 R s in terms of Retrieval, Reuse, Revise and Retain\u00a0 [1]. The cost of manufacturing parts is usually related with their form features of Digital Mock Ups (DMU), which makes cost estimation available. For example, machining parts of similarity may share similar path planing. With all these applications depending on content similarity of solid models, retrieving their internal representation is thus to be emerging.  Early studies treat the solid model as a polygon soap to implement algorithms of general shape retrieval, such as View based\u00a0 [2,3], Reeb Graph based\u00a0 [4,5], Shape distribution based\u00a0 [6,7] and Skeleton based\u00a0 [8,9] methods, to name but a few. Detailed review can be found in\u00a0 [10,11]. The general shape approach is ineffective to be directly used in solid model retrieval\u00a0 [12]. Unlike triangle meshes, most engineering parts are composed of simple regular faces (plane, cylindrical faces, etc.) yet contain rich design semantics with complex feature distribution or topology variant. Small changes of topology may significantly alter similarity among models\u00a0 [13]. Two different solid models with complex feature distributions possibly share similar shape distribution statistical curves\u00a0 [14]. As a result, retrieval for manufacturing classification is also an open research challenge\u00a0 [15]. However, combinations of multi-approaches are reported of better performance\u00a0 [16\u201318], and it is a good idea to introduce general shape retrieval algorithms to enhance solid model retrieval.  Previous researches also evaluate similarity of solid model with its external design features. These semantic features, like hole, boss, slot, etc., are extracted from the native file format pre-defined in specific CAD systems\u00a0 [19] or custom-defined in feature templates interactively\u00a0 [20]. Though semantic intuition of external design features simplifies a design process for users, it has limitation in content-based retrieval. On the one hand, different CAD systems probably organize variant feature definitions. A \u201ccylinder\u201d can be marked up as extrude or sweep in different CAD platforms. On the other hand, customized work flow can be adopted by users to design the same model, which result in different historical feature dependency graphs. Consequently, though external design feature approaches are natural to engineering experience, dependency on feature categories make it hard to fully automatic retrieval between heterogeneous systems.  Boundary representation (B-rep) is a unique internal scheme of solid model. It precisely organizes face-edge topology and geometric information that can be stored in the form of face adjacent graph (FAG); see Fig.\u00a01 . FAG is independent to both users and CAD systems and hence it is suitable for cross-platform retrieval. Some studies focusing on local topology correspondence of FAG adopt the inexact match method\u00a0\u00a0 [21,22]. Other studies treat FAG as a whole at a global scale. Since sub-graph isomorphism is an NP-complete problem, improved graph matching algorithms are proposed\u00a0 [23,24]. All of these studies treat FAG in one resolution and focus on the matching process. A multi-resolution descriptor, however, is also preferred in both global and partial retrieval\u00a0 [25] since features in level of detail (LOD) is essential to avoid sensitiveness of small features reported in the topology-based method\u00a0 [26]. In practical use, the LOD matching would be more preferable to support \u201cexplorable\u201d or \u201citerative\u201d search because designers only need to build a less detailed model as a search query.  Previous studies of geometric reasoning approaches explore feature volumes to get a shape descriptor in LOD. Chu\u00a0 [27] defines additive and subtractive form features to get a feature adjacent graph, which is limited by feature volume constructed by sweeping a face along a direction. Cheng\u00a0 [28] considered concave features by negative feature decomposition, which is suitable for machining parts specifically.  In summary, it has not been studied how to abstract the neutral format B-rep model into multi-resolutions by reasoning about intrinsic FAG, and how to retrieve the hierarchy based on both geometry and topology in LOD, which would require new algorithms to summarize multi-layer distributed similarities instead of conventional one-layer criteria.  This work specifically focuses on the geometric reasoning approach to a hierarchical structure for B-rep model retrieval. Research goals are as follows.  \u2022 Define a geometric reasoning mechanism that is independent of any CAD systems or design history, to associate low-level B-rep information and high-level form features.  Propose a hierarchical descriptor which organizes geometric and topological information of B-rep models with multi-resolution, to supply retrieval with efficiency and effectiveness.  Design and implement coarse-to-fine matching and comparison algorithms to validate global/partial retrieval, with user-friendly feedback to explain why and how two hierarchies are matched with relation to form features.   Fig.\u00a02 illustrates the framework of our solution. The hierarchical partition graph (HPG) is a shape descriptor which is a hyper-graph composed of a tree of resolution level and an adjacent graph. The geometric reasoning procedure listed on the left side is adopted to map the intrinsic property of B-rep model to build an HPG. This process is further divided into two stages: low-level geometric reasoning and high-level geometric reasoning respectively. While the former contains edge recognition, seed detection, faces clustering into partition, and unit hierarchy building inside each partition, the latter reasons about the partition adjacent graph (PAG), recursively records parent of each node and simplifies PAG to HPG. As plotted on the right side, retrieval includes matching, comparing and ranking HPG similarity between the descriptor of query model and that of candidates indexed in design repository. This is ensured by weighted sub-graph isomorphism, where weights take geometric proportion in/between each resolution into account, preserving local/global topology consistency respectively. A shape distribution  ( D 2 )  algorithm is used to get geometric similarity of matched pairs. All of these processes are automatic by design without user interaction.  The rest of this paper is organized as follows. Notions of HPG and related definitions are introduced in Section\u00a0 2. Section\u00a0 3 provides algorithms for the geometric reasoning approach from B-rep to HPG. Weighted sub-graph isomorphism algorithms are presented in Section\u00a0 4. While implementation and results are given in Section\u00a0 5 to confirm our approach, Section\u00a0 6 concludes the present work and a discussion is given for future study.  Though B-rep does not contain high-level form feature information, it contains low-level features such as orientations of edges and faces, and edge-face adjacency in the form of winged-edge data structure\u00a0 [29], which supplies a basis of reasoning to track left/right faces with oriented edges. Visually, concave edges on the B-rep model show that \u201cthere are features nearby\u201d. Essentially, these edges supply mapping between low-level topologies and high-level form features. Following this idea, the B-rep model could seem to be a set of features or face clusters which \u201cgrow\u201d at \u201cseed\u201d from base faces to new ones. Fig.\u00a03 illustrates related notions.    Definition\u00a01 Seed   Let seed  ( S )  be a set of connected edges that divide two sets of adjacent faces   F   1   and   F   2   , where   F   1   \u2229   F   2   = \u2298 ,   F   1   \u222a   F   2   \u2260 \u2298 .    Definition\u00a02 Growth   Growth  ( G )  is an oriented operation based on the winged-edge data structure by querying winged face(s) at one side for another, crossing orientation of seed, from the query side to another.    Definition\u00a03 Partition   A partition  ( P )  is a maximum set of faces of one semantic part of B-rep model B , where  { B \u2223   \u2211   m     P   m   = B , m \u2a7e 1 }  and semantic here is that faces of P share coherent concave/convex adjacency.  For example, there are two partitions at the buttom left view of Fig.\u00a03. Each partition shares the same convex property in terms of adjacent edges joined between faces in that partition. Definition\u00a04 Partition Seed   Partition Seed (PS) is a proper subset of S , on condition that undirected graph G of vertices of PS edges is the Eulerian circuit.  Intuitively, faces on the same side of oriented PS belong to the same partition; see Fig.\u00a03. Note that edge orientation (dashed arrow) on the left wing is used to drive orientations of partition seed (closed dark solid arrows) to a uniform direction. To describe connections between partitions, we defined two categories of PS: single-face closed (SC) and multi-faces closed (MC). While the former means PS is inside a single face, the latter means there are multiple faces joining at PS, say MC is composed of outer-boundary edges. To distinguish concave/convex properties of these joints, SC and MC are further divided into concave/convex versions, say, SCV, SCX and MCV, MCX. The algorithm of concave/convex detection is given in Section\u00a0 3.1. Moreover, multi-faces open convex (MOX) is defined for partition nearby open concave edges. MOX means the boundary of newly-grown faces of open seed. Since this boundary is closed and there are multiple faces around MOX, it is classified in the category of MC; see Fig.\u00a04 .  Based on these minimum definitions, we could see a B-rep model as a group of partitions each of which is bounded by one or many PS. While SC means one partition \u201cbelongs to\u201d or located at the inner boundary of a base face, MC preserve the \u201cconnect with\u201d relationship, say, multi-faces in one partition should be used together to query adjacent faces of another partition. We further abstracted these two relationships as connection properties of PS as follows:  \u2022 \u201cParent\u2013children\u201d relationship between two P connected with SC.  \u201cSibling\u201d relationship between two P connected with MC.  Since every PS is shared by a partition pair \u201c   P   1   \u2013   P   2   \u201d, we further introduced   L   m   p 1 \u2013 p 2   as level of PS in terms of   P   1   , and   L   n   p 2 \u2013 p 1   as level of PS in terms of   P   2   ,  m , n = 0 , 1 , 2 . If PS is MC, which means \u201c   P   1   \u2013   P   2   \u201d are \u201csiblings\u201d and share the same level, then   L   m   p 1 \u2013 p 2   =   L   n   p 2 \u2013 p 1   = 1 , else PS is SC, which represents the \u201cparent\u2013children\u201d relationship, in which case 0 is given to level of \u201cparent\u201d P and 2 to that of \u201cchild\u201d P , respectively. This can be summarized as:  (1)    L   m   p 1 \u2013 p 2   +   L   n   p 2 \u2013 p 1   = 2 .      In each P symbol   L   m   is named for short. Furthermore, master boot partition seed (MBPS) of each partition is defined as PS of maximum   L   m   . Besides, a partition is called the   L   m   partition if its MBPS is   L   m   . These notions are mentioned in Section\u00a0 3.5 where high-level reasoning based on PS is discussed.  Each partition captures unit coherent form feature of B-rep model. To bridge the gap between the low-level face/edge and the high-level partition, the sub-graphs of FAG are extracted to describe the partition property. In practice, these sub-FAG may still have considerable complexity especially when its partition contains a large amount of faces. To solve this problem, the notion of segmentation is defined at middle level that simplifies sub-FAG to a tree-like hierarchical structure. Definition\u00a05 Segmentation   Segmentation (SG) is a set of faces belonging to one semantic part of P , where  { P \u2223   \u2211   n      SG    n   = P ,  n \u2a7e 1 }  and semantic here is that    SG    n   is one-step growth based on    SG    n \u2212 1   which is originated from MBPS.  Based on the winged-edge data structure, one side of faces of MBPS that intersect with   P   m   is selected as its first \u201cback-end\u201d    SG    0   . Each growth returns the subsequent    SG    n   per step until all faces of   P   m   have been covered. Since the growth directions are coherence, all segments can be connected into a path graph to be stored as the property of   P   m   . A detailed algorithm is given in Section\u00a0 3.3. Since SG is a subset of P , the tree structure is adopted to store this \u201cparent\u2013children\u201d relationship and the adjacent graph to store the \u201csibling\u201d relationship between SG. As illustrated in Fig.\u00a05 , while    SG    i   is linked with its \u201csibling\u201d    SG    j   by physical edges, dashed edges on the tree structure represent that SG belongs to P . As of SG which has more than one faces, micro-level face adjacency is further stored as property of SG.  The whole B-rep model is composed of several partitions; thus the partition adjacent graph (PAG) is then built by linking nodes   P   i   and   P   j   at their common PS.  The dark edge between the square node in Fig.\u00a06 represents that two partitions are physically joined at PS. PAG provides a general adjacent relationship between partitions of B-rep model and it is simpler than FAG in terms of graph comparison. For models with complex structures however, it is essential to further simplify PAG to a more efficient data structure HPG. Algorithms will be given in Section\u00a0 3.5.  The hierarchical partition graph (HPG) is a hyper-graph composed of a tree of resolution level (TR) and an adjacent graph (ADJ); see Fig.\u00a07 . Circular grey nodes represent physical faces (one node per face), and white square nodes represent containers of faces. Dark solid lines in ADJ represent physical joint by edges; dashed lines in TR represent the \u201cparent\u2013children\u201d relationship. Each cluster of ADJ is referenced by only one white square node in TR. For example, node   n   11   of TR has children   n   0   and   n   3   ; at the same time, it references its ADJ containing two nodes   n   0   ,   n   3   and one edge   e   0 \u2212 3   as the edge property. With this coarse-to-fine structure, HPG preserves multi-resolutions determined by the depth of node on TR. For example, TR in Fig.\u00a07 has a depth of 4.   n   11   is of resolution level 0. It contains all faces of B-rep without consideration of feature detail;   n   0   and   n   3   are of resolution level 1 since they are partitions further divided by partition seed. Following a \u201cpartition-segmentation-face\u201d pattern, more details of local features are available as resolution level increases.  In summary, the HPG has following properties:  \u2022 Global topology consistency: \u201cparent\u2013children\u201d relationship between each resolution level of TR.  Local topology consistency: \u201csibling\u201d relationship in each cluster of ADJ.  This section describes algorithms of geometric reasoning to construct HPG in practice. Discussion is based on STEP203 and geometric kernel of OpenCascade (OCC)\u00a0 [30].  In Section\u00a0 2.1, notions of SC and MC have been introduced. In this section they are calculated based on graph theory and OCC libraries. Fig.\u00a08 provides flow chart of PS extraction. After the B-rep model has been read from the STEP file by  B  -  rep    TopExp_Explorer  , there are three main procedures distinguished by arrow type. While SC is built in the process of empty arrowheads, MC is calculated in the procedure of black arrowheads. Dashed arrow heads indicate the basic complementary process.  In the basic complementary process, dictionary-data-structure of Face-Edge map is built to simulate the function of winged-edge data structure, which is used to build growth iterator and to recognize the concave/convex edge list. While growth operation has been defined in Definition\u00a02, the Face-Edge map is used to return one face by querying another and to support edge recognition described as follows.   Edge recognition. In OCC, elements of B-rep are defined as integrating both geometry and topology. Since vertex, edge and face have topology of point, curve and surface respectively, their orientations can be evaluated based on these topologies. While forward edge orientation means that its logical direction matches that of its curve, face orientation shows how face normal is aligned with its surface normal\u00a0 [30]. This is useful to judge material side of B-rep model. Face material is defined by orientation of its edges. The side is determined by cross product between surface normal and edge derivative which equals its 3D curve derivative if the edge is forward and opposite, if reversed. In short, if an edge is forward then face material is on the left, or if reversed, it is on the right.  Based on these definitions, we calculated the concave/convex property on top of low-level winged-edge structure; see Fig.\u00a09 . First material orientation is calculated on each face, which is cross product of positive face normal and edge orientation. Note that it is always at the left side of edge on its face. The sum of material orientations following the parallelogram law, is used to cross product to material orientation of one face to get master orientation (the long blank arrow). Finally, the convex edge is detected if master orientation and material orientation are the same. Alternatively, the concave edge has opposite orientations.  As of SC extraction, inner wires are evaluated on every single face. In the process of building MC, MCV and MCX candidates are prepared by closed cycle basis operation based on graph theory. These candidates are sub-graphs of vertex adjacent graph. In Definition\u00a03, a partition is supposed to be a maximum set of faces with coherent concave/convex connections; some candidates split partitions however. For example, cases A and C in Fig.\u00a010 divide one partition into two which have the same concave/convex property. To solve this problem, cross-section judgement is conducted as follows.   Cross-section judgement. To filter out cases A and C in Fig.\u00a010, the linear equation is solved for cross-section judgement. First, for all  MCV  /  MCX  candidates, material orientations     m  \u2192    1   and     m  \u2192    2   (grey dashed arrow) in terms of two winged faces intersecting at middle-point on each edge are calculated. Then the cross-section plane is created by these two vectors. Using this plane the intersecting point is calculated to build cross-section vector     c  \u2192    1   (black solid arrow). Since     m  \u2192    1   ,     m  \u2192    2   and     c  \u2192    1   are in the same plane,     c  \u2192    1   can be determined by linear combination of     m  \u2192    1   and     m  \u2192    2   in their vector space. Let factors for     m  \u2192    1   ,     m  \u2192    2   be   \u03b1   1   ,   \u03b1   2   ; then it meets A \u22c5 x = b form.  (2)   (     m   \u2192     1   ,     m   \u2192     2   )  \u22c5  (      \u03b1   1         \u03b1   2      )  =   c   \u2192   .   Both concave/convex properties and signs of factors   \u03b1   1   ,   \u03b1   2   are considered together to judge MCV and MCX. For concave cases, if signs of factors are all positive, it is not MCV. For convex cases, if signs of   \u03b1   i   ,  i = 1 , 2 , are all positive, it is not MCX.  Lastly, MOX is determined by reasoning about the rest of concave edges. See Fig.\u00a011 ; dashed lines are candidate open-concave edges. After connecting these edges to build an edge adjacent graph, cluster operation is applied by fetching the connected components. These connected components are unclosed (dashed lines) but their newly-grown faces\u2019 boundaries are ensured to be a closed subset of convex edge lists (black lines) which are stored as MOX. For cases that newly-grown faces collapse (cluster on the buttom), these faces are simply merged to get boundaries as MOX.  Algorithm 1 (Fig.\u00a012 ) supplies a partitioning procedure based on PS of Definition\u00a04. It returns set of partitions  { p }  of a B-rep model B in three main steps: initializing two partitions per seed, extending each p the rest adjacent faces recursively, and merging adjacent many small p into one large p . Note that topology consistency is ensured by introducing p s as boundary conditions to prevent merge operation crossing p s ; see Fig.\u00a013 .  For every partition, segments are then built with its MBPS. Algorithm\u00a02 (Fig.\u00a014 ) provides pseudo code of this procedure. Similar to the growth of Definition\u00a02, the basic idea of this algorithm is that starting from MBPS, new segmentation s   g    new    is recursively grown based on previous segmentation, and the new seed p   s    new    is boundary of s   g    new    without contacting to p   s    old    .  The partition is then described by the tree structure, children nodes of which are segments. The sub-graph of FAG is stored as the attributed graph of property of tree node. See Figs.\u00a05 and 13.  Previous sections give low-level geometric reasoning inside each partition. The rest sections present simplification of relationship between partitions at high level. First, PAG is built as the undirected graph. While each graph node represents partition, every edge stands for joint in the form of partition seed. In practice we checked whether two partitions share the same partition seed to link a graph edge, on which the level of seed is stored. The level of each partition (see Eq. (1) and later) is also stored on each graph node. Then we re-organized PAG to hierarchy based on the information of these levels.   HPG is built by reasoning about connection relationship between each adjacent partitions of PAG. Since PAG is a flattened undirected graph with only \u201csibling\u201d relationship, yet a hierarchy is featured with the \u201cparent\u2013children\u201d relationship, say, it is important to determine the \u201cparent\u201d of each node. Semantically, a partition is a relatively independent feature of B-rep model; then the parents of two or more partitions can be seen as a larger container of these features. Though there is not any form feature definition or classification in terms of geometry, there is underlying intrinsic connection property between partitions, the level of single face or multi-face seed (SC and MC). When the level of priority has been defined in Eq. (1), PAG is simplified to HPG based on the minimum information.  The basic idea of our approach is similar to the mesh simplification method. When different levels of partitions and their joints have been defined, partial graph edges are suppressed/un-suppressed subsequently to replace two partition nodes per step with a container node. \u201cParent\u2013children\u201d information is recorded at the same time.   Fig.\u00a015 provides the framework of this high-level reasoning process. While black arrows indicate work flow from PAG to HPG crossing four modules, dashed arrows show how simplification module is called. In short, there are two main stages: reasoning about \u201cparent\u201d node information of every partition node in PAG, and assembling all nodes to build HPG with these \u201cparent\u201d information.   Initialization. In the initialization process, the dictionary data structure is adopted to store the property of nodes and edges on  PAG  :  G  .  edge   [ e ]   [ \u2018  supp_state  \u2019 ]  \u2190 0 ;  G  .  node   [ n ]   [ \u2018  parent  \u2019 ]  \u2190  None  ;  G  .  node   [ n ]   [ \u2018  children  \u2019 ]  \u2190  [  ]  , where  G  .  edge   [ e ]  and  G  .  node   [ n ]  are dictionaries of  edge   e and  node   n , which contains key words (\u2018supp_state\u2019, \u2018parent\u2019, \u2018children\u2019) to query the value of property. If an edge has its \u2018  supp_state  \u2019 = 0 , it is un-suppressed that its adjacent nodes can be simplified by a container. Moreover, \u2018  geometry  \u2019 property is also attached on each node and edge of PAG for assembling.   Basic simplification. In the basic simplification process, \u201cbase\u201d node P 1 and \u201cfeature\u201d node P 2 are simplified to P 3 per step following seed priority   L   m   P 1 \u2013 P 2   in an order of   L   0   \u2192   L   1   \u2192   L   2   . Fig.\u00a016 illustrates this process, where centric black node is P 1 , and grey node represents P 2 . At each step, P 1 is maximum linked node and P 2 is one of its neighbours with minimum   L   m   P 1 \u2013 P 2   and maximum   L   n   P 2 \u2013 P 1   , say, if there is node pair of P 2 should be simplified first, P 2 is updated as P 1 and recursively search for new \u201c P 1 \u2013 P 2 \u201d pair until all these conditions meet. Used seed is recorded at each step, as well as \u2018parent\u2019 and \u2018children\u2019 information: while P 3 is parent, P 1 , P 2 are children. In practice, new node P 3 is created if P 1 , P 2 have no \u2018parent\u2019, yet previous \u2018parent\u2019 is reused if this property exists. This is realized by the \u201cBroadcasting\u201d mechanism: every time a simplified pair \u201c P 1 \u2013 P 2 \u201d is replaced by P 3 , \u2018parent\u2019 is not only stored on P 1 , P 2 , but is also \u2018broadcasted\u2019 to P 1 \u2019s neighbour of the same level as P 2 , where   L   m   P 1 \u2212 P  neighbour    =   L   m   P 1 \u2013 P 2   . After P 3 has been linked to PAG, edges connected with P 1 , P 2 have been deleted.  Intuitively, if   L   0   P 1 \u2013 P 2   <   L   2   P 2 \u2013 P 1   , an arrow can be drawn to represent the \u201cgrowth direction\u201d (on top-left of Fig.\u00a016). If   L   1   P 1 \u2013 P 2   = =   L   2   P 2 \u2013 P 1   , the direction is further determined by comparing PS levels of adjacent partitions. Connecting these arrows provides a tree-like view, which is the reverse direction of simplification process.   Suppression/un-suppression. Basic simplification works on the simple B-rep model of tree-like structure yet cannot process complex patterns like symmetric or recursive pattern shown in Fig.\u00a017 . For level-2 and level-1 patterns, partitions in the centre have two adjacent partitions. Both sides share the same level of MBPS in the central partition. This results in ambiguity of selecting simplification pair P 1 \u2013 P 2 . Arrow directions also indicate this conflict. For the level-0 pattern, simplification pair P 1 \u2013 P 2 failed to initialize since it recursively fetch new P 1 \u2013 P 2 that should be simplified first. Arrow directions also show that it forms a closed directed graph. To solve these problems, conflict graph edges are suppressed/un-suppressed to process basic simplification hierarchically. See Fig.\u00a015. The idea is to suppress conflict edges until their adjacent nodes have been simplified to container nodes. Then these container nodes are grouped under one \u2018parent\u2019 node when conflict edges are un-suppressed.  In suppression module, undirected  Level  2 _ G ,  Level  1 _ G , and directed  Level  0 _ G (sub-graph with grey nodes in Fig.\u00a017) are the sub-graphs of PAG. Numerical \u2018supp_state\u2019 of edge property is tracked to control simplification priority. If \u2018supp_state\u2019 of one edge > 0 , then vertex nodes of the edge can be simplified. First \u2018supp_state\u2019 of simple cycles of  Level  0 _ G is initialized to -2. Then \u2018supp_state\u2019 of clusters of  Level  1 _ G is set to \u22121 on condition that there are conflict edges one step outside leaf nodes. Finally,  Level  2 _ G are recursively suppressed by increase 1 on current maximum \u2018supp_state\u2019 of PAG, where edges are 1-step inside leaf nodes. In short, suppression module forms a hierarchical order  Level  _ 0 \u2192  Level  _ 1 \u2192  Level  _ 2 , and a reversed order is adopted in un-suppression module as follows.  In un-suppression module, first  Simplification_base   ( G )  is called by the  Unsupp_level  2 function if there are edges meets \u2018  supp_state  \u2019 = = 0 . Then partial edges with current maximum \u2018supp_state\u2019 are filtered out to update its value with 1-current maximum \u2018supp_state\u2019. Recursion is performed by this function until current maximum \u2018supp_state\u2019 is decreased to 0. After that, Unsupp_level1 and Unsupp_level0 function update \u2018supp_state\u2019 of related edges to 0 and call  Simplification_base   ( G )  function, respectively. In summary, the suppression/un-suppression mechanism breaks whole PAG into many sub-graphs to call  Simplification_base   ( G )  functions locally, where edges are un-suppressed with \u2018  supp_state  \u2019 = = 0 . This mechanism eliminates growth conflict that it can process arbitrary type of PAG.   Assembling. The last assembling module is composed of two main functions:  BuildHierarchy   ( G )  and  BuildAdjacentGraph   ( G )  , which prepare a tree structure and an adjacent graph of node property respectively. While nodes of HPG are copied from simplified PAG, edges are built by checking \u2018parent\u2019, \u2018children\u2019 information stored on these nodes. Note that unit hierarchy is stored on each node of PAG, so does partition nodes on HPG. After the tree structure has been built, a Upload function is called to update \u2018geometry\u2019 property (geometric faces) of those container nodes created in the simplification process.  Then the adjacent graph of each none leaf node HPG is built by a depth-first iteration. Starting at root node of HPG, its children nodes are copied to ADJgraph. Edges of ADJgraph are then linked by checking physical connections between these children nodes. This process is recursively performed until leaf partition nodes whose \u2018children\u2019 property is empty. Therefore, HPG has all details from macro- to micro-scope, say, feature regions (partition containers) \u2192 partitions \u2192 segmentations \u2192 faces; see Fig.\u00a07.  Matching HPG is to find corresponding sub-regions of B-rep models in level of detail (LOD). It recursively checks current matched node whether there are more detailed feature distribution that can be matched. Given two HPG, the matching process is started at their root nodes which are matched by default. Then ADJgraph of root nodes is queried to match at a more precise level. The VF2 algorithm\u00a0 [31] is adopted for sub-graph isomorphism to get the \u201cbest match\u201d, which is realized by comparing similarity of different scenarios of correspondence. Given two \u2018ADJgraph\u2019 sharing the same topology, multiple scenarios of correspondence can be returned but it is not sufficient to determine the \u201cbest match\u201d just with topology correspondence alone. To address this issue, geometric similarity is combined after each step of isomorphism, to select the \u201cbest match\u201d with the highest score of sum of similarity, which is based on Eq. (4) of Section\u00a0 4.2. Fig.\u00a018 gives a minimum example to illustrate this operation.  To narrow down types of these scenarios, weight of edge is introduced to reduce a number of candidate nodes that can be matched. Since the edge of \u2018ADJgrpah\u2019 represents PS between two P , the property is PS type in five categories which have been discussed: SCX, SCV, MCX, MCV and MOX. Weight is defined as 1 if two compatible edges are in the same category or 0 if not. Intuitively, this criterion requires matched pairs of nodes sharing the same type of connectivity. After best matched sub-graph of root\u2019s ADJgraph has been found, a depth-first recursion is performed on each node of the sub-graph to get how its sub-feature distribution (ADJgraph) can be matched in a more detailed resolution level. Whole recursion stops until no more sub-graph can be matched or matching reaches leaf nodes of HPG.  Since HPG describes the B-rep model in the multi-resolution level, each resolution level is a description of similarity of two shapes. To summarize the total similarity, we introduced   \u03c9    out    to represent weight between each resolution level. Thus we have:  (3)    S    total    =  ( 1 \u2212 \u03c3 )    \u2211   i     \u03c9   i    out    \u00d7   S   i     where \u03c3 represents the penalty factor measuring ratio between unmatched face areas and total face areas of two B-rep models.   \u03c9   i    out    is the ratio between matched faces\u2019 area of   i    th    resolution level and total matched faces\u2019 area of all resolution levels on condition that   \u2211   i     \u03c9   i    out    = 1 .   S    total    is total similarity and   S   i   is similarity of   i    th    resolution level which can be formulated as:  (4)    S   i   =   \u2211   j     \u03c9   j    in    \u00d7 D   2    sim      where   \u03c9   j    in    is the ratio between matched faces\u2019 area of   j    th    node and total matched faces\u2019 area of all nodes in the   i    th    resolution level. D   2    sim    is similarity of matched pair of nodes. As of D 2 shape distribution and its similarity assessment, please refer to\u00a0 [6].  Generally, while global matching is to retrieve a similar whole model, partial matching aims at finding local correspondence between two models. HPG supports both tasks for its level of detail. In global matching, whole HPG are stored, indexed and matched from its root. In partial matching, branches of HPG are processed separately and preserve references to whole HPG. With this method, the partial matching process can reuse the same algorithms of global matching. The only difference is that recursion begins at root of HPG branch. In practice, partial retrieval gets partial features on purpose of design reuse. These features are of notably complexity, say, they cover certain depths on HPG. To reduce search space, depth limitations should be considered in indexing branches of HPG. In this paper, we adopted the proposal that reusable branches are of crossing at least 3 depths\u00a0 [20].  Time complexity in terms of sub-graph isomorphism is compared between HPG and FAG. Considering one-to-one mapping between two FAG, with a number of leaf nodes N , it takes \u0398  (   N   2   )  of time complexity in the best case. In Fig.\u00a019 , HPG of maximum depth is corresponding to the binary tree illustrated as \u201cA\u201d, other types of HPG cost more calculation steps since their TRs are less organized, e.g. \u201cB\u201d and \u201cC\u201d. Its time complexity of one-to-one mapping can be analyzed as follows: in case \u201cA\u201d, the depth of binary tree is   log   2   N . Given its root been matched by default, each ADJgraph with two nodes is of constant time complexity in matching since complexity of V F 2 is \u0398  (   N   2   )  in the best case and \u0398  ( N ! N )  in the worst case\u00a0 [31]. Besides, there are   2   i   \u2212 1 number of ADJgraph in depth i which requires a sub-graph isomorphism operation. The sum of these operations is   2   0   +   2   1   + \u22ef +   2   l o   g   2   N \u2212 1   =   1 \u22c5  ( 1 \u2212   2   l o   g   2   N   )    1 \u2212 2   = N . Therefore the best case of HPG with binary tree costs time complexity of \u0398  ( N )  . Less organized cases, however, can be seen as reduction of clusters yet increasing of nodes complexity in certain clusters, which result in the increase of time complexity. For example, while time complexity of \u201cA\u201d is 7 \u00d7 4 = 28 , \u201cB\u201d costs   2   2   +   2   2   +   3   2   +   4   2   = 33 operations at least, and \u201cC\u201d costs   8   2   = 64 operations at least. Maximum complexity in the worst case is that all leaf nodes share the same root, where ADJgraph of root is FAG which has time complexity of \u0398  ( N ! N )  at most. From the geometry point of view, the maximum complexity is obtained when the B-rep model is convex hull without any features. In summary, time complexity of HPG is reduced by its hierarchical structure and is better than that of sub-graph matching on FAG directly.  We implemented a prototype system to evaluate the efficiency and effectiveness of HPG for both global and partial retrieval. Our system works on hardware of Intel i3 CPU, 3\u00a0GB RAM and OS of Windows7 32 bit. While PythonOCC\u00a0 [32] is adopted as geometric kernel, repository is composed of 101 STEP203 files sorted in 11 categories collected from National Design Repository\u00a0 [33], TraceParts\u00a0 [34], and our original data. As illustrated in Fig.\u00a020 , main frame is composed of three panels: search key panel, option panel and repository browser, where 3d viewer is integrated to facilitate observing feature distribution and highlighting corresponding features in partial match mode. To analyse why and how two models are matched, we further provided a hierarchy view of HPG of selected model; see Figs.\u00a026 and 27. Each node of HPG on top view is clickable, linked by its ADJgraph on the buttom left view and D 2 histogram on the buttom right view. This framework visualizes both topology and geometry interactively in a zoom-able user interface (ZUI), thus to be informative for designers who can navigate B-rep models and check retrieval results. All the interfaces, data structures and algorithms were built on the pythonxy scientific package\u00a0 [35] in python language.   Fig.\u00a021 provides a real example of global search for similar functional design using a \u2018polymer slot\u2019 as the key model. System returns similar models ranked by their similarities (see \u2018 <  Sim  = > \u2019 on the figure). While returned models of higher similarities are mainly of the same category as the key model, those of lower scores are in irrelevant categories. As this feature is important in the information retrieval system, we further performed Precision\u2013Recall Analysis and take comparison between our approach (HPG) and former methods. Fig.\u00a022 gives Precision\u2013Recall curves (P\u2013R) of shape distribution (D2)\u00a0 [6] and inexact matching based on the face adjacent graph (FAG)\u00a0 [21]. These two typical content-based retrieval methods focus on geometry and local topology respectively. P\u2013R of HPG is above D 2 and FAG thus to be of better effectiveness. The main reason is that HPG not only captures geometric distribution with D 2 histogram, but also considers both global and local topology. Essentially, its lowest resolution level corresponds to D 2 comparison, weighted sub-graph isomorphism gives exact match to driven further comparison in higher resolution level, penalty factor in Formula (3) efficiently filter out candidate models with similar D 2 yet dissimilar topology at lower resolution level.  Time estimation and similarity matrix of our approach are also visualized in Figs.\u00a023 and 24  respectively. Though the query time is not very fast, better result could be expected in practical deployment by using static language such as C++/Java instead of python dynamic language adopted in this initial prototype. Given that high-level precision\u2013recall performance yet relatively low-level increase of time complexity, the HPG approach is of both effectiveness and efficiency in terms of \u201conline\u201d retrieval. Indexing time of HPG ranges from a few seconds to a few minutes, depending on complexity of features. Since it is at \u201coffline\u201d stage, it does not hurt the \u201conline\u201d retrieval performance at all.  For evaluating partial retrieval, faces of query model are selected by choosing the HPG branch. It is used to compare with partial HPG stored in repository. These partial HPGs are automatically split from global HPG on the condition that their depths are at least 3\u00a0 [20]. Fig.\u00a025 provides a real example of partial retrieval for socket feature. This feature is a selected branch rooted at node \u201c83\u201d by navigating HPG and observing highlighted features interactively; see Fig.\u00a026.   The matched parts are also highlighted, which ease examination of correspondence. With the support of \u201cShow hierarchy\u201d, users can further dive into its HPG and get why and how two partial features are matched. As shown in Fig.\u00a027,  highlighted partial HPG is corresponding to the highlighted partial features of second returned model 096 \u223c 812 . p r t in repository browser. These two partial features are matched since they share common partial HPG (highlight on top view), the same local topology (ADJgraph on lower left view) and similar shape distribution (lower right view). Furthermore, topology and geometry at each higher resolution level are also matched that their partial hierarchy are summarized to be of high similarity. Compared with the previous feature defined method which requires feature-category prepared interactively or semi-interactively, the HPG approach is efficient, fully automatic and does not depend on the definition of specific form features. After feature segmentation, the compatibility of feature boundaries between the copied source feature and the target base model is essential in design reuse. Since edges between branches of HPG are corresponding to feature boundaries, seed-wire defined in this paper can be seen as the boundary condition in design reuse. Consequently, HPG is of adaptation and effectiveness for reuse oriented partial retrieval.  In this paper, we proposed a geometric reasoning approach to integrate both topology and geometry information into a hierarchy. It is suitable for processing neutral STEP203 format to ease multi-resolution B-rep model retrieval. Due to its level of detail, it reduces the cost of sub-graph isomorphism yet increases discrimination of comparison. The proposed internal and external weights capture intrinsic geometry proportion thus to be self-organized. Results show the effectiveness and efficiency of our shape descriptor HPG. This technique also has limitations. While the D 2 approach works for any shape with or without non-manifold, the HPG depends on consistent closed B-rep models without non-manifold. The FAG method needs less indexing time but HPG requires additional steps for geometric reasoning and graph abstraction based on FAG. Actually, HPG integrates FAG and D 2 . While the former provides reasoning foundation, the latter is used to find the \u201cbest match\u201d, to progress to finer detailed step in matching stage, and to be the basis of integrating distributed similarities at each resolution level.  The proposed hierarchical structures may also be introduced in various knowledge intensive or resource critical applications, such as solid model analysis, knowledge-integration, distributed storage and network transformation, etc. Specifically, seed-wire retains underlying correlation between feature segmentation, which is the boundary condition of design reuse task, say, partial shape in copy\u2013paste operation could be knowledge integrated, validated and transformed by seed-wire. We would like to further investigate in this application to ease design reuse.  There are several aspects to explore and to improve our method in the future: first, reducing topology influence of small fillets and chamfers. Currently we pre-processed these small blend features with a simple suppression algorithm to retain the similarity factor between both versions. Second, free-form surfaces are of low discrimination by the shape distribution method\u00a0 [36]. Interpreting curvature distribution for comparison needs to be considered separately. As of multi-body solid model which usually represents the assembly mechanism, we do not suggest to directly use our method. Since the assembly mechanism is designed on purpose of kinematic function\u00a0 [37], and kinematic information is more important that should be extracted and described explicitly. Lastly, even though our hierarchy reduces computational complexity in LOD, large scale pattern features are corresponding to lots of child partitions that still increase the time complexity of isomorphism considerably. To address this issue, grouping detected patterns\u00a0 [38] and position distribution\u00a0 [16] are possible solutions.   ACKNOWLEDGEMENTS   The authors would like to thank Chuipin Kong and Lu Zhang for implementation of part of this work. Thanks also go to Grant No. 60903111 from National Natural Science Foundation of China for partial funding of this work. They appreciate valuable advices from reviewers and helpful comments from editors on improving this paper.   REFERENCES", "highlights": "3D solid model similarity is dependency of many intelligent design applications, such as design reuse, part management, case-based reasoning, and cost estimation. Matching and comparing its intrinsic boundary representation (B-rep) is a critical issue to retrieval. In this paper, we proposed a geometric reasoning approach to generate hierarchy for B-rep model retrieval. We extracted the winged-edge data structure to support series algorithms for underlying geometric reasoning, which is mainly composed of 3 steps to build hierarchy: partitioning, assembling and simplifying. This hierarchical representation is featured with level of detail  ( L O D )  retaining geometric and topological information which is proved to be efficient in both global and partial retrieval. Our approach is based on the standard for the exchange of product information  ( S T E P )  , which is suitable for data exchange between heterogeneous CAD systems. The result of case studies from prototype implementation demonstrates its effectiveness and efficiency."}