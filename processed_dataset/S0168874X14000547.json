{"id": "S0168874X14000547", "article": "MAIN-TITLE Low intrusive coupling of implicit and explicit time integration schemes for structural dynamics: Application to low energy impacts on composite structures   HIGHLIGHTS          Non-intrusive GC implementation.      Industrial code-coupling.      Simulation of low energy impact on laminated stiffened panel.      Python interface to finite element codes.          KEYPHRASES   Implicit dynamics  Explicit dynamics  Code coupling  GC method  Composite materials   Low energy impacts can be very harmful for composite laminates used in the aerospace industry. They can actually cause significant damages (matrix cracking, delamination, fiber failure, etc.) inside the composite or on the side opposite to the impact. However, the residual print left on the impacted side can be almost undetectable to the naked eye. Induced damages can therefore lead to early failure of the structure while they can be unnoticed during a visual inspection, this is related to the concept of BVID (Barely Visible Impact Damage). Controlling such situations is essential for manufacturers. Numerical simulations of this phenomenon could be really helpful to orient and to rationalize test campaigns by the use of virtual testing as well as to understand scale effects. Various researches are led in the scientific community to simulate these impacts which is actually very difficult to carry out at industrial level. Implicit solvers can be used to deal with this type of problem with satisfactory results [7\u20139]. However non-smooth sources like contact, softening damage laws or cohesive zone models are often introduced in the models which can make convergence of implicit solvers difficult to achieve. Using explicit solvers to simulate low-energy impacts is an alternative way to handle this difficulty despite the non-dominance of high frequency terms or wave propagation in this context [1,2,10,11]. Explicit solvers are indeed more suitable to solve non-smooth problems. However, stability requires the use of very small time steps which linearly decrease with the characteristic length of the smallest mesh element. Moreover, very fine meshes are usually required (at least locally) to capture the non-linear phenomena occurring during an impact. This thus leads to a very large number of increments which can be prohibitive. Note however that these non-linear phenomena occur on a very localized area around the impact point.  Adopting a space/time multiscale strategy thus appears to be advantageous to solve this kind of multiscale problems. This can be performed through domain decomposition where each subdomain owns its time discretization. The purpose of this decomposition is to focus on numerical computation where non-linear phenomena appear [12]. Explicit resolution in the area close to the impact is required because of the lack of smoothness of the solution. However, on the complementary area where the solution is smoother, implicit integration is appropriate. Larger time steps can then be used to save CPU time. The present work is based on the GC method [4] and aims at coupling semi-industrial finite elements codes (FEA) Zset/Z\u00e9bulon  1   1  Zset/Z\u00e9bulonis an implicit FEA code developed by Mines ParisTech, Onera and NW Numerics & Modeling, http://zset-software.com/  and Europlexus. 2   2  Europlexus is an explicit FEA code developed by Commissariat \u00e0 l\u05f3\u00e9nergie atomique (CEA) and the Joint Research Centre (JRC) in Ispra, Italy.  Fig. 1 illustrates the computation strategy. It shows one section of an impacted plate and a typical mesh. This mesh is divided into two domains: an impacted domain (center) which is processed by the explicit code Europlexus with a fine time step and a complementary domain which is processed by the implicit code Zset/Z\u00e9bulon with larger time steps. In addition, low intrusivity is a key feature of the implementation when industrial applications are aimed [13,14]. In the present work this goal has been achieved through Python/NumPy high level scripting so that no coding was required into the native programming languages of Zset/Z\u00e9bulon and Europlexus to implement the coupling algorithm itself.  We describe in this section the algorithmic framework of this study. Space and time discretization of structural dynamics problems are firstly presented. Both implicit and explicit algorithms are expressed in terms of velocity unknowns. This unusual form is useful to handle both implicit and explicit schemes equations within the GC domain decomposition framework (see Section 2.3) which requires continuity of interfacial velocity. Gravouil and Combescure [4] indeed showed that imposing interfacial velocity continuity is mandatory to ensure stability when coupling arbitrary Newmark schemes with different time steps. Domain decomposition method written under this constraint is then presented for two domains. Extension of domain decomposition with different time steps within each sub-domain through the GC method is finally described.  We consider here the finite element discretization of the principle of virtual power which leads to the semi-discretized equilibrium system of Eqs. (1) for an undamped structure [15]:  (1)  {     \u2200 t \u2208 [   t   0   ,   t   f   ] ,  M   u   \u00a8   ( t ) +   f   int   ( u ( t ) ) =   f   ext   ( t )     u (   t   0   ) =   u   0   ,    u   \u0307   (   t   0   ) =     u   \u0307     0         where M is the symmetric definite-positive consistent mass matrix, u is the nodal displacements vector,   f   int   is the internal forces vector (   f   int   ( t ) = Ku ( t ) for linear elasticity with K the stiffness matrix) and   f   ext   is the external forces vector. Single and double superposed dots over a quantity denote respectively its first and second time derivatives. The initial displacements and velocities vectors are respectively denoted as   u   0   and     u   \u0307     0   . t 0 and t  f denote respectively the beginning and the end of the time domain of interest.  The system (1) is then discretized in time to be solved numerically. A lot of time integrators can be found in the literature, see for instance [16\u201319]. However, due to GC method constraints, the present work is restricted to Newmark schemes [20]. A Newmark temporal integrator is defined by two parameters \u03b3 and \u03b2 and involves relations (2) among displacement, velocity and acceleration vectors from time t  n to time   t   n + 1   =   t   n   + \u0394 t . \u0394 t is the time step, n \u2208 \u301a 0 ,   n   step   \u2212 1 \u301b and   n   step   \u2208   N   \u204e   is the number of time step:  (2)  {       u   n + 1   =   u   n      p   + \u03b2 \u0394   t   2       u   \u00a8     n + 1           u   \u0307     n + 1   =     u   \u0307     n      p   + \u03b3 \u0394 t     u   \u00a8     n + 1         with displacement predictors   u   n      p   and velocity predictor     u   \u0307     n      p   given by the following relations:  (3)  {       u   n      p   =   u   n   + \u0394 t     u   \u0307     n   + ( 1 \u2212 2 \u03b2 )    \u0394   t   2     2        u   \u00a8     n           u   \u0307     n      p   =     u   \u0307     n   + ( 1 \u2212 \u03b3 ) \u0394 t     u   \u00a8     n      p         where subscripted quantities   x   n   are the approximations of x (   t   n   ) at time t  n .  Introducing Newmark relations (2) in Eq. (1) leads to the following system of equations as long as \u03b3 is not equal to zero which never happens in practice for stability reasons [15]:  (4)      u   \u00a8     0   =   M   \u2212 1   (   f   0   ext   \u2212   f   int   (   u   0   ) ) \u2200 n \u2208 \u301a 0 ,   n   step   \u2212 1 \u301b , {        1   \u03b3 \u0394 t    M (     u   \u0307     n + 1   \u2212     u   \u0307     n      p   ) +   f   int   (   u   n + 1   ) =   f   n + 1   ext         u   n + 1   =   u   n      p   +   \u03b2 \u0394 t   \u03b3   (     u   \u0307     n + 1   \u2212     u   \u0307     n      p   )         u   \u00a8     n + 1   =    1   \u03b3 \u0394 t    (     u   \u0307     n + 1   \u2212     u   \u0307     n      p   )       From this point, we focus on a step that consists in solving system (4) from time t  n to time   t   n + 1   . The choice of the parameter \u03b2 in the Newmark relations can lead to implicit or explicit systems in the mathematical point of view. Note however that due to CPU cost and programmation constraints, implementations of implicit and explicit algorithms are in practice very different. This is the reason why code coupling is of major importance in this work (see Section 3).  When \u03b2 is set to 0 the system (4) can become explicit if M is replaced by the lumped mass matrix noted   M   lump    [21]. Non-linearities are also naturally handled without requiring any iterative process. The explicit system is obtained as follows:  (5)   {       A   1       u   \u0307     n + 1   =   b   1         u   n + 1   =   u   n      p           u   \u00a8     n + 1   =   2   \u0394 t   (     u   \u0307     n + 1   \u2212     u   \u0307     n      p   )        Note that in explicit finite element codes, \u03b3 is generally set to 1/2.   A   1   is the explicit positive definite diagonal operator defined by  (6)    A   1   =   2   \u0394 t     M   lump     and  (7)    b   1   =   f   n + 1   ext   \u2212   f   int   (   u   n      p   ) +   A   1       u   \u0307     n      p     Although there is no system to solve, an explicit algorithm remains stable as soon as the Courant\u2013Friedrich\u2013Levy (CFL) condition is ensured [3]. In composite laminates damage simulations, at least one element in the ply thickness is required, thus leading to critical time steps of the order of 1 \u00d7   10   \u2212 8    s . This time step is then really small in comparison to the time range of the study (up to 10 \u00d7   10   \u2212 3    s ). A lot of time steps are therefore required that is why one may want to use unconditionally stable implicit algorithms with larger time step when it is possible (i.e. where and when local solution is smooth or mainly governed by low frequencies) to save CPU time.  In this study, the implicit solver will be applied only to linear problems. Under this assumption, the system (4) can then be expressed as follows:  (8)   {       A   2       u   \u0307     n + 1   =   b   2         u   n + 1   =   u   n      p   +   \u03b2 \u0394 t   \u03b3   (     u   \u0307     n + 1   \u2212     u   \u0307     n      p   )         u   \u00a8     n + 1   =   1   \u03b3 \u0394 t   (     u   \u0307     n + 1   \u2212     u   \u0307     n      p   )        with   A   2   being the implicit positive definite symmetrical operator which is defined by  (9)    A   2   =   1   \u03b3 \u0394 t   ( M + \u03b2 \u0394   t   2   K )   where  (10)    b   2   =   f   n + 1   ext   +   A   2       u   \u0307     n      p   \u2212   K   p     u   n        Note that the first equation of system (8) could also be expressed in terms of acceleration or displacement unknowns by rearranging the system (8).  Different multiscale space/time approaches can be found in the literature [4,22\u201328]. These can be viewed as extensions of dual Domain Decomposition (DD) methods, mostly used in parallel computing [29,30]. DD methods consist in spatially splitting a structure into several subdomains and search solution on each subdomain as independently as possible (an example of structure splits into two subdomains named \u03a9 1 and \u03a9 2 is shown in dotted box in Fig. 2 ). The two main key points in DD methods are (i) determining the boundary conditions that must be applied on the subdomain interfaces and (ii) solve the interface problem in an efficient way. The interfacial boundary condition should indeed ensure both kinematics continuities and equilibrium at the interface.  For the sake of simplification we consider in this section only two subdomains (\u03a9 1 and \u03a9 2). Applying a dual DD technique under the constraints to satisfy velocity continuity and equilibrium at the interface [31], the first equation of system (4) leads to system (11) for compatible meshes at the interface [32,29]. At this stage we may note that from the discrete point of view, imposing the continuity of the displacement, velocity or acceleration is not equivalent [4]:  (11)  [       A   1     0   \u2212   C   1   T       0     A   2     \u2212   C   2   T       \u2212   C   1     \u2212   C   2     0     ] [         u   \u0307     1           u   \u0307     2       \u03bb     ] = [       b   1         b   2       0     ]          A   d   ,     u   \u0307     d   and   b   d   are the quantities previously introduced in Section 2.1.1 which are relative to the subdomain \u03a9  d   d \u2208 \u301a 1 , 2 \u301b .   C   d   T   is the transposed interface operator (trace operator), it is a signed boolean   n   d   \u00d7   n   d   \u2223   \u0393     matrix where n  d is the number of degree of freedom (DOF) of the subdomain \u03a9 d and   n   d   \u2223   \u0393     is the number of DOF on the interface. \u03bb is the unknown vector of interfacial forces (the size of this vector is   n   d   \u2223   \u0393     ). System (11) can then be solved with the following three steps:  1.  Free problems: Free interface velocity vectors of subdomains 1 and 2 respectively denoted as     u   \u0307       1     \u2223   \u0393       free   =   C   1       u   \u0307     1   free   and     u   \u0307       2     \u2223   \u0393       free   =   C   2       u   \u0307     2   free   are computed by solving (12) and projecting free velocities obtained (     u   \u0307     x   free   ,  x \u2208 \u301a 1 , 2 \u301b )on the interface with trace operator:  (12)  {       A   1       u   \u0307     1   free   =   b   1         A   2       u   \u0307     2   free   =   b   2         System of Eqs. (12) can be solved in parallel. Note also that it can be solved in terms of displacements by rearranging Newmark relations (2).   Interface problem: Interface problem is solved to determine interface forces vector \u03bb . This problem is obtained by condensing (11) on the third line which leads to the following equation:  (13)      [   C   1     A   1   \u2212 1     C   1   T   +   C   2     A   2   \u2212 1     C   2   T   ]   \ufe38     sum  of  Schur  complements   \u03bb =     \u2212 (     u   \u0307       1     \u2223   \u0393       free   +     u   \u0307       2     \u2223   \u0393       free   )   \ufe38         velocities  obtained  from  free  problems       ( step  1 )         System (13) can then be solved directly after building the interface operator (based on domains Schur complements) or be solved through iterative solvers which do not require explicit computation of the interface operator [32,30]. In fully implicit DD analysis, iterative solution is often advantageous.   Linked problems: Solving the linked problem (14),  (14)  {       A   1       u   \u0307     1   =   b   1   +   C   1   T   \u03bb       A   2       u   \u0307     2   =   b   2   +   C   2   T   \u03bb       This problem is similar to step 1 but interface nodal forces are now taken into account. This step can also be performed in parallel.  The additional feature of multiscale time methods in comparison to a single time-scale DD method is that each subdomain may have its own time stepping.  Let \u0394 t be the finest time step associated with the explicit subdomain \u03a9 1 and let \u0394 T be the largest time step associated with the implicit domain \u03a9 2. m is the ratio between these two time steps: m = \u0394 T / \u0394 t , m \u2208   N   \u204e   . The interface problem has to be written in order to satisfy the kinematic continuities and the balance equations in time. The GC method proposes to ensure both the velocity continuity and the interface equilibrium on the fine time scale. As mentioned above, imposing the continuity of the displacement, velocity or acceleration is not equivalent from a discrete point of view. The velocity is the kinematic quantity that has to be chosen in order to ensure the stability of the coupling method as shown in [4].  Free interface velocity field of the coarse time scale is however not known at each fine time step, so it is linearly interpolated [4] as shown in Fig. 3 . Note that high order interpolation is also possible [33]. The interface problem is then slightly modified in comparison to a dual DD method. In fact it can be shown in [31] that the interface problem (13) can be rewritten at each fine time step as follows:  (15)  \u2200 j \u2208 \u301a 1 , m \u301b ,      [   C   1     A   1   \u2212 1     C   1   T   +   C   2     A   2   \u2212 1     C   2   T   ]   \ufe38     sum  of  Schur  complements     \u03bb   n + j   = \u2212     (     u   \u0307       1   n + j   \u2223   \u0393       free   +       u   \u0307     \u02dc       2   n + j   \u2223   \u0393       free   )   \ufe38         velocities  obtained  from  free       problems  and  interpolation         where   A   1   =   M   lump   / \u03b3 \u0394 t is the operator related to the explicit domain (\u03b2=0) and   A   2   = ( 1 / \u03b3 \u0394 T ) ( M + \u03b2 \u0394   T   2   K ) is the one related to the linear elastic implicit domain. Note also that the interface operator remains constant through the time.   \u03bb   n + j   is the interface force at time   t   n + j   =   t   n   + j \u0394 t .     u   \u0307       1   n + j   \u2223   \u0393       free   is the free interface velocity of the domain with the finest time step at time   t   n + j   and       u   \u0307     \u02dc       2   n + j   \u2223   \u0393       free   is the approximation of the free interface velocity of the domain with the large time step at the same time. This approximation can be obtained by the following linear interpolation:  (16)  \u2200 j \u2208 \u301a 1 , m \u301b ,        u   \u0307     \u02dc       2   n + j   \u2223   \u0393       free   = (  1 \u2212   j   m    )     u   \u0307       2   n   \u2223   \u0393       free   +   j   m       u   \u0307       2   n + m   \u2223   \u0393       free        The GC method, detailed in Algorithm 1, thus consists in performing a single coarse time step on the \u201cfree\u201d problem on domain \u03a9 2. Solution on \u03a9 1 is then advanced with fine time stepping through the coarse time increment by solving the \u201cfree\u201d, \u201cinterface\u201d and \u201clinked\u201d problems. The \u201clinked\u201d problem is finally solved on \u03a9 2. Note that implicit linear system is solved twice per coarse time step. As it will be shown in Section 4.3.2, the associated CPU time becomes negligible as soon as large time steps ratios can be reached. Note also that computing the internal forces is the most expensive part of the explicit solution procedure and is done only once per fine time step. As shown in Eq. (5), internal forces are indeed computed from the displacement predictor which remains the same in \u201cfree\u201d and \u201clinked\u201d solutions. Algorithm\u00a01 GC algorithm from t  n to   t   n + m   .      Compute     u   \u0307       1   n + 1     free   and     u   \u0307       2   n + m     free   (Free problems in \u03a9 1 and \u03a9 2)    for j=1 to j=m (Loop over \u03a9 1 until reaching time    t   n + m   ) do      if  j > 1  then     Compute     u   \u0307       1   n + j     free   (Free problem in \u03a9 1)     end if     Compute       u   \u0307     \u02dc       2   n + j   \u2223   \u0393       free   with formula (16)     Compute   \u03bb   n + j   (Solve interface problem with formula (15))     if  j < m  then     Compute     u   \u0307       1   n + j     (Linked problem in \u03a9 1)     end if     end for    Compute     u   \u0307       1   n + m     and     u   \u0307       2   n + m     (Linked problems in \u03a9 1 and   \u03a9   2   )        In this section, the two finite element softwares used in this work are presented as well as their Python binding implementation. Low intrusive scripting of the GC algorithm as well as the interface operators computation through these bindings is then described.  In this work, two FE codes are used within the code-coupling framework:  \u2022  Zset/Z\u00e9bulon [5] is a non-linear implicit FE code jointly developed by MINES ParisTech, Onera and NWNumerics. Zset/Z\u00e9bulonis suited to smooth non-linear transient dynamics analysis. Its main programming language is C++ but a general purpose Python binding is also available.   Europlexus [6] is a FE software jointly developed by CEA (CEA Saclay, DMT, France) and the European Joint Research Center (JRC Ispra, Italy). It is based on an explicit algorithm. Besides its good ability to handle fluid/structure interaction, it is also suitable to fast transient dynamics and to non-smooth problems. Fortran is the native programming language of Europlexus.  The several algebraic operations required to implement the algorithm described in Sections 2.2 and 2.3 could be hard-coded directly within the native software source codes. This however requires an access and a good knowledge of these different source codes and is thus very intrusive and difficult to extend to different couples of software and especially to commercial softwares. However, the increasing importance of scripting language bindings and especially Python bindings to commercial and academic softwares is nowadays remarkable. Attempts to standardize Python interfaces in the field of computational sciences, such as the CGNS project [34,35], are also worth noting. Python is particularly interesting for scientific applications since it comes with NumPy, a module which adds support for large multi-dimensional arrays and matrices, along with a large library of high-level algebraic functions to operate on these arrays (broadcasting, linear solvers, Fourier transforms, etc.) [36]. Data one want to operate on (essentially nodal displacements, velocities or forces vectors) are generally stored in Fortran or C++ arrays. These arrays can be easily handled in Python-written scripts since Numpy\u05f3s Application Programming Interface (API) allows Numpy arrays to share pointers to the first element of Fortran or C++ arrays. Arrays are thus not copied but shared in memory. Using Python/NumPy to perform algebraic operations on large data arrays is therefore as efficient in terms of CPU performance as hard-coding in the original programming language.  Applied to FE codes, these scripting interfaces allow to have more flexible input data descriptions like in Abaqus or Code_Aster [37] for instance. The Python interpreter can also be embedded within C++ or Fortran written codes [38]. This means that some parts of the application can occasionally call the Python interpreter to run some Python code. In this case, such interfaces allow to have a control on data during the computation process. For the needs of the present study, the Python interpreter has to be called from three critical points in both Zset/Z\u00e9bulon and Europlexus algorithms:  \u2022 before the first increment to initialize variables in the Python script,  at the beginning of an increment, basically to apply new external forces,  at the end of an increment, basically to extract and eventually interpolate kinematic quantities and to solve the interface problem.  publish a function to apply nodal external forces on specified node sets (i.e. the interface nodes),  publish a function to extract nodal kinematic values from specified node sets (velocities in the present algorithm),  implement a mechanism to validate or invalidate an increment in order to be able to solve the \u201clinked\u201d problem after the \u201cfree\u201d problem with no spurious time advance. This mechanism has to be controlled from the Python outer script,  eventually publish the NumPy array view of the lumped mass vector (in explicit code).  The Schur complement of the explicit domain at the interface is defined by the following formula:  (17)    S   1   =   C   1     A   1   \u2212 1     C   1   T   = \u03b3 \u0394 t   C   1     M   \u2212 1     C   1   T     Computing this operator is straightforward since M is replaced by the lumped mass matrix   M   lump   . The Europlexus Python interface publishes a function that gives access to the internal storage of   M   lump   through a NumPy vector with no memory copy.  The Schur complement of the implicit domain at the interface is defined by the following formula:  (18)    S   2   =   C   2     A   2   \u2212 1     C   2   T   = \u03b3 \u0394 T   C   2     ( M + \u03b2 \u0394   T   2   K )   \u2212 1     C   2   T        Computing the Schur complement of the elastic linear implicit operator over the interface is performed by launching a classical Zset/Z\u00e9bulon instance with null Neumann and Dirichlet boundary conditions as well as null initial velocity over the whole domain. The python interface is then used to apply a canonical loading for each interfacial DOF (i.e. value of 1 on the current dof and 0 elsewhere). This is done within fictitious increments (no time advance) using the increment invalidation mechanism described previously. Resulting interfacial velocities are gathered into a NumPy array. The interface operator (left-hand side of Eq. (15)) is then computed and explicitly inverted with NumPy. This procedure is as efficient as a hard-coded implementation as soon as the global operator factorization is conserved. Note also that under these hypotheses (coupling implicit domain with linear elastic material and explicit domain) the interface operator remains constant through the time. Its calculation is then done once at the beginning of the simulation.  Code-coupling involves network communications between the several code instances which are implemented in the Python scripts through the mpi4py module. 3   3  mpi4py implements a Python interface to MPI. Solutions of problems (12) are performed by each code instance with their own Newmark time integration scheme. An extraction of interfacial velocities to NumPy vectors is performed and the coarse scale velocity is transferred through MPI to the fine scale Python instance. Time on the explicit domain is then advanced and time interpolation (Eq. (16)) as well as solution of (15) is performed with NumPy. Resulting interfacial forces are transferred back to the coarse scale Python instance and problems (14) are then solved independently by each code instance. This process is illustrated in Fig. 4 .  Code-coupling simulations with different time step ratios are performed on a stiffened composite panel relatively representative of an aircraft\u05f3s subassembly. The model characteristics and the results obtained are presented in this section.  The geometry, the mesh and the domain decomposition adopted for the stiffened composite panel are shown in Fig. 5 . The central impacted area of the panel (in blue) as well as the impactor is processed with Europlexus and the complementary part which has relatively larger time step is processed with Zset/Z\u00e9bulon. The Newmark parameters are \u03b3=0.5 and \u03b2=0 in the explicit domain and \u03b3=0.5 and \u03b2=0.25 in the implicit domain. The stacking sequence is   [ 90 / 45 / 0 / \u2212 45 ]   s   for the T-shape stiffeners and   [ 90 / 45 / 0 / 0 / \u2212 45 ]   s   for the skin. The characteristic size of elements (hexahedrons and wedges) ranges from 5mm to 0.25mm in the impact area. Note also that each ply is modeled with one element in the thickness direction. Reduced integration elements are set in explicit domain. The size of the problem is about 1million degrees of freedom with 94% of nodes located in the implicit domain. The size of the interface is 4428 degrees of freedom. The 8mm radius impactor has an initial velocity of 10ms\u22121 and a mass of 0.2kg, thus resulting in a 10J impact. The time step of the impacted area is fixed to 1.10\u22128 s during the study, which is in accordance with the stability criterion internally computed by Europlexus. We then perform computations with different time step ratios with m ranging from 10 to 1000 (implicit time steps ranging from 1\u00d710\u22127 s to 1\u00d710\u22125 s). A fully explicit simulation is also performed to make comparisons with the proposed method.  The elastic damage model used in this work in the explicit domain is a simplified version of the mesoscale laminate model OPFM (Onera Progressive Failure Model) [39]. The main modification from the original model consists in not taking into account the viscosity whose effects are assumed to be of second order due to the high loading rates. This simplification allows for an explicit formulation of the material model that is described in Appendix A. The material model used in the implicit domain is only the linear orthotropic elastic part of the material model used in the explicit domain.  The OPFM model was initially implemented for Zset/Z\u00e9bulon through the Z-mat utility. Z-mat is a programming environment dedicated to material models development. It is originally part of the Zset/Z\u00e9bulon solver [5] but can also be linked to Europlexus through its Z-europlexus interface. Using the OPFM model in the current code-coupling environment is then straightforward and almost code-independent. Note however that the Z-mat modularity can decrease the CPU time performance in comparison to a hard-coded constitutive law.  In the present work, no cohesive zone model is introduced so delamination is not taken into account.   RESULTS   The results obtained with this model for a time step ratio of 1000 is shown in Fig. 6 . Cone-shaped matrix damages characteristic of this kind of impact are observed. It can also be seen that matrix damages are more important on the back side of the impact which is also in accordance with classical experiments [8]. Comparisons between matrix damages obtained with time step ratios m = 10 , m = 1000 and fully explicit computation are shown in Fig. 7 . Matrix damages patterns and values are similar. Note that damage variables d 1, d 2 and d 3 such as introduced in Eq. (A.2) (see Appendix) are not bounded.  Deflection evolutions at the center of the panel on the opposite face for time step ratios m=10, m=100 and m=1000 as well as for fully explicit simulation are shown in Fig. 8 . A small difference can be seen between the fully explicit simulation and the group of coupled solutions. This could be attributed to internal differences in the two softwares in terms of element formulation, inner bulk dissipations, consistent/lumped mass matrix or local material orientation updates. In order to focus on the GC algorithm convergence in terms of time step ratio, deflection errors of m=100 and m=1000 simulations relative to the m=10 one are plotted in Fig. 9 . This error is defined by the following expression:  (19)    E   deflection   ( t ) =   |   U   d   ( t ) \u2212   U   d   m = 10   ( t ) |     max   t   ( |   U   d   m = 10   ( t ) | )     where U  d is the evolution of the deflection,   U   d   m = 10   is the evolution of the deflection with m=10. These curves show that solutions are slightly equal (error under 0.01%) over the whole time range even with large time step ratios.  Evolutions of the interface energy dissipation for different time step ratios are shown in Fig. 10 . This dissipation is due to time interpolation of the interfacial velocity of GC algorithm, see [4] for its expression. It can be observed in Fig. 10 that dissipation is low in the present case (below 0.1% of the total energy (10J) in the m=1000 case). Fig. 11 shows energy damage dissipation history for fully explicit as well as for implicit/explicit coupled simulations. For a time step ratio of 1000, the final amount of interfacial dissipation is about 0.1% of the total energy while the damage dissipation is more than ten times higher (about 1.1% of the total energy). It is worth noting that interfacial dissipation increases rapidly at the beginning of the simulation and reaches its maximum level very early (at about 0.1ms). This corresponds to the damping of high frequencies generated by the impact. On the other side damage dissipation evolves more regularly. This shows that numerical dissipation due to the GC algorithm has few influence on the physical dissipation one want to capture.  CPU time distributions are presented in Fig. 12 . Schur complement computation CPU times have been omitted since they are negligible (40min with two processors). We observe that the choice to solve the interface problem on the finest time step is not penalizing in terms of CPU time with this interface size (below 2.6% of total simulation time). We also note that the overall CPU time decreases when the time step ratio increases. This shows that in this case, the computation work is focused on the explicit area. Indeed, for the time step ratios m=100 and m=1000, the CPU times dedicated to implicit solutions are very small (less than 18h for m=100 and 2h for m=1000). However, the time saved reaches a limit which corresponds to the time spent in the explicit process. It can be observed that time spent in explicit code is mainly governed by the computation of free problems and more especially by the computation of internal forces. The computation of internal forces in explicit domain is indeed just done once per fine time step (see Section 2.3). Work is currently ongoing to reduce this bottleneck. In addition the use of the Z-europlexus (Section 4.2) material module can lead to\u00a0increase in CPU time that could be avoided by coding the constitutive relation within Europlexus.   CONCLUSION   Low intrusive implicit/explicit code coupling, based on the GC algorithm, has been implemented. Both implicit (Zset/Z\u00e9bulon) and explicit (Europlexus) codes are involved in the same calculation with their own time step and integration schemes. The minimal interface which should be provided by FEA codes to build this low intrusive method has been identified, in order to extend it to other couples of FEA codes. In addition, non-linearities like contact or intra-laminar damages can easily be introduced in the explicit code. We highlight that with this low intrusive coupling, CPU time can be saved on the simulations of small energy impacts on composites structures. This is a first step towards faster simulations of small energy impacts on large composite assemblies and of problems owning similar space/time multiscale characteristics. Also CPU time can be saved, we show that explicit domain is currently a bottleneck. Actually explicit domain is currently a user defined choice which cannot evolve during the calculation. The explicit domain could in particular be too large at the beginning of the simulation wasting CPU time. It would be suitable to follow non-linearities through time by enlarging the explicit domain \u201con the fly\u201d. A strategy to optimize the size of the explicit domain through the time is ongoing within the GC algorithm. This strategy consists in applying a switch mechanism to change algorithm from implicit to explicit on a subdomain. This would allow to increase the efficiency of the method in particular to simulate delamination phenomena occurring in this kind of impacts by introducing cohesive zone models which is not currently done.   ACKNOWLEDGMENTS   This research has been performed at Onera within the framework of the PRF transition statique/dynamique dans les structures composites project and was also supported by DGA (French ministry of defense). The authors are also grateful to V. Faucher from CEA for his help on Europlexus.  The material model is derived from the Onera Progressive Failure Model [39] and the numerous material parameters have been previously identified for the T700GC/M21 unidirectional ply [40]. The model is formulated in a fully explicit way:  (A.1)  \u03c3 =   C   \u02dc   : \u03b5   where   C   \u02dc   is the fourth order effective elasticity tensor defined as  (A.2)      C   \u02dc     \u2212 1   =   (   S   0   +   d   1     H   1   +   d   2     H   2   +   d   3     H   3   )   \u2212 1      d 1, d 2 and d 3 are respectively the fiber, in-plane matrix and out-of-plane matrix damage variables. Material parameters   H   1   ,   H   2   and   H   3   are fourth order effects tensors that are used to increase the appropriate components of the initial compliance tensor   S   0   =   C   0   \u2212 1   (see parameters in Table A1 ) in accordance with the three damage variables.  Damage evolution laws include a delay effect [41,42] part to avoid the well-known localization effect that is encountered in softening regime:  (A.3)  \u2200 i \u2208 { 1 , 2 , 3 } {        \u2202     d   \u02dc     i     \u2202 t    =    1     \u03c4   i      (   \u03b1   i     (     f   i     \u2212 1 )     p   i     \u2212     d   \u02dc     i   )   if    f   i   \u2265 1        \u2202     d   \u02dc     i     \u2202 t    = 0   if    f   i   < 1       where (   f   1   \u2265 1 ) , (   f   2   \u2265 1 ) and (   f   3   \u2265 1 ) correspond to damage onset in fiber, in-plane matrix and out-of-plane matrix directions respectively. These equations can be solved in an explicit way with an Euler integration scheme. \u03b1  i and p  i are damage evolution parameters and \u03c4  i are parameters related to the delay effect. It is worth noting that the values of characteristic times \u03c4  i are much higher than the global time step ( 1 \u00d7   10   \u2212 8    s ). The Euler integration scheme therefore leads to a good precision. Material parameters are summarized in Table A2 . Due to thermodynamics concerns, damage cannot decrease and the final step in the damage variables computation is  (A.4)    d   i   = max (    max   t   (   d   i   ( t ) ) ,     d   \u02dc     i    )  \u2200 i \u2208 { 1 , 2 , 3 }      Failure criteria are expressed in terms of strain and account for traction/compression/shear coupling:  (A.5)  \u2200 i \u2208 { 1 , 2 , 3 }    f   i   =   \u03b7   i     f   i   t   + ( 1 \u2212   \u03b7   i   )   f   i   c    with  {       \u03b7   i   = 1   if    \u03c3   ii   > 0       \u03b7   i   = 0   if    \u03c3   ii   \u2264 0          (A.6)  Tension  fiber  direction :    f   1   t   =   (      \u03b5   11       X   t      )   2   Compression  fiber  direction :    f   1   c   =   (      \u03b5   11       X   c      )   2   +   1   2     (      \u03b5   12       S   12   f      )   2   +   1   2     (      \u03b5   13       S   13   f      )   2   Tension  in  matrix  direction :    f   2   t   =   (      \u03b5   22       Y   t      )   2   +   1   2     (      \u03b5   12       S   12   m      )   2   +   1   2     (      \u03b5   23       S   23   m      )   2   Compression  in  matrix  direction    f   2   c   =   (      \u03b5   22       Y   c      )   2   +   1   2     (      \u03b5   12       S   12   m      )   2   +   1   2     (      \u03b5   23       S   23   m      )   2   Tension  in  out  of  plane  direction    f   3   t   =   (      \u03b5   33       Z   t      )   2   +   1   2     (      \u03b5   13       S   13   m      )   2   +   1   2     (      \u03b5   23       S   23   m      )   2   Compression  in  out  of  plane  direction :    f   3   c   =   (      \u03b5   33       Z   c      )   2   +   1   2     (      \u03b5   13       S   13   m      )   2   +   1   2     (      \u03b5   23       S   23   m      )   2     Failure parameters are summarized in Table A3 . Non-zero component of effect tensor expressed as matrices in Voigt notation is summarized in Table A4 .  The energy density dissipated by the damage process \u0394   E   dam   over an increment can be expressed by  (A.7)  \u0394   E   dam   =   \u222b   t   t + \u0394 t     \u2211   i = 1   3   \u03c3 :   H   i   : \u03c3     d   \u0307     i    dt   which can be integrated with the following expression:  (A.8)  \u0394   E   dam   =   \u2211   i = 1   3     \u03c3   t + 1 / 2 \u0394 t   :   H   i   :   \u03c3   t + ( 1 / 2 ) \u0394 t   (   d   i   t + \u0394 t   \u2212   d   i   t   )       REFERENCES", "highlights": "Simulation of low energy impacts on composite structures is a key feature in aeronautics. Unfortunately it involves very expensive numerical simulations: on the one side, the structures of interest have large dimensions and need fine volumic meshes (at least locally) in order to properly capture damage. On the other side, explicit simulations are commonly used to lead this kind of simulations (Lopes et al., 2009 [1]; Bouvet, 2009 [2]), which results in very small time steps to ensure the CFL condition (Courant et al., 1967 [3]). Implicit algorithms are actually more difficult to use in this situation because of the lack of smoothness of the solution that can lead to prohibitive number of time steps or even to non-convergence of Newton-like iterative processes. It is also observed that non-smooth phenomena are localized in space and time (near the impacted zone). It may therefore be advantageous to adopt a multiscale space/time approach by splitting the structure into several substructures with their own space/time discretization and their own integration scheme. The purpose of this decomposition is to take advantage of the specificities of both algorithms families: explicit scheme focuses on non-smooth areas while smoother parts (actually linear in this work) of the solutions are computed with larger time steps with an implicit scheme. We propose here an implementation of the Gravouil\u2013Combescure method (GC) (Combescure and Gravouil, 2002 [4]) by the mean of low intrusive coupling between the implicit finite element analysis (FEA) code Zset/Z\u00e9bulon (Z-set official website, 2013 [5]) and the explicit FEA code Europlexus (Europlexus official website, 2013 [6]). Simulations of low energy impacts on composite stiffened panels are presented. It is shown on this application that large time step ratios can be reached, thus saving computation time."}