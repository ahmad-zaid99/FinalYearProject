@&#MAIN-TITLE@&#Interactive tooth partition of dental mesh base on tooth-target harmonic field

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A harmonic field (HF) is introduced to partition individual teeth from dental mesh.


                        
                        
                           
                           A modified weighting scheme of HF is used for mesh partition purpose.


                        
                        
                           
                           Constraints of HF are assigned based on prior knowledge of human teeth.


                        
                        
                           
                           A boundary refining strategy is introduced to handle complicated dental mesh.


                        
                        
                           
                           Smart user interfaces are proposed to improve flexibility and reduce interaction.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Tooth

Dental models

Mesh partition

User interfaces

Harmonic field

@&#ABSTRACT@&#


                  The accurate tooth partition of dental mesh is a crucial step in computer-aided orthodontics. However, tooth boundary identification is not a trivial task for tooth partition, since different shapes and their arrangements vary substantially among common clinical cases. Though curvature field is traditionally used for identifying boundaries, it is normally not reliable enough. Other methods may improve the accuracy, but require intensive user interaction. Motivated by state-of-the-art general interactive mesh segmentation methods, this paper proposes a novel tooth-target partition framework that employs harmonic fields to partition teeth accurately and effectively. In addition, a refining strategy is introduced to successfully segment teeth from the complicated dental model with indistinctive tooth boundaries on its lingual side surface, addressing an issue that had not been solved properly before. To utilise high-level information provided by the user, smart and intuitive user interfaces are also proposed with minimum interaction. In fact, most published interactive methods specifically designed for tooth partition are lacking efficient user interfaces. Extensive experiments and quantitative analyses show that our tooth partition method outperforms the state-of-the-art approaches in terms of accuracy, robustness and efficiency.
               

@&#INTRODUCTION@&#

Three dimensional (3D) tooth models are now widely used in dental-related fields, ranging from oral medicine and forensic medicine to anthropology and archaeology. There are two major ways of reconstructing tooth models. The first one is segmenting teeth from medical images, like dental cone beam computed tomography (CT) images [1]. The second one is partitioning teeth from a noisy 3D dental model, which is generated from scanning the results of patient-specific dental impressions [2]. In fact, segmented teeth on dental models correspond to crowns of the teeth. Full tooth models can be further generated by integrating the segmented teeth with roots reconstructed from CT images [3] or statistical models [4]. Since the CT imaging modality is radiologically invasive and of relatively low resolution [4], the usage of 3D dental models for tooth partitioning is much more popular.

As basic operations of dental models, tooth partition (or segmentation /cutting/decomposition) is a key ingredient in virtual dental applications. For example, it is a fundamental process in dental surgical plans, while the success of surgeries depends not only on the technical aspects of the operation, but, to a larger extent, also on the formulation of precise plans [5]. In other words, precise plans are crucial to the success of surgeries, as well as to the partition procedure. The segmented individual teeth also are essential for virtual orthodontics treatments [6], information retrieval [7,8], and can be used in dentists’ training, communication between the dentist and the patient, etc.

In this research, we aim to find a novel method to partition each tooth from 3D digital maxillary or mandibular mesh models. We also have chosen to involve intuitive user interaction, since fully automatic segmentation is typically impossible, specifically, defining a semantic subpart for shapes remains a challenging task [9]. The major challenges exist in the following two aspects:

The first and primary challenge when partitioning a mesh model is to accurately locate cutting boundaries. In other words, we have to find a proper partition criterion. Most widely cited criterion is the minima rule, which states that human perception usually divides a surface into parts along the concave discontinuity of the tangent plane [10,11]. Based on the principle, surface curvature field is traditionally used to identify the boundaries. However, unlike ideal synthetic models, clinical dental models may have different problems, like tooth crowding and other dental abnormalities, which make the curvature-based method unreliable in terms of accuracy and efficiency. So, choosing an appropriate segmenting strategy to accurately find cutting boundaries is the first and foremost challenge we are facing.

The second challenge lies in the user interface designation. On one hand, user interaction can provide useful high-level information in order to aid in the detection and extraction of target objects. On the other hand, a method that requires too many manual operations is unreasonable. For example, placing a great deal of control points on models will lead to experiences that are tedious and time-consuming. This is because the time it takes can quickly add up to hours and the user may need special training. Moreover, it is important to guarantee real-time feedback during the interaction. Hence, designing smart user interfaces with minimum user interaction and real-time feedback is another crucial key for our research.

Fully considering the challenges described above, we introduce a novel interactive tooth partition framework based on harmonic fields (HFs). The main contributions of our method include the following:
                        
                           •
                           Other than curvature field, a HF with a modified weighting scheme is introduced for dental model segmentation in terms of accuracy and efficiency. This is the first time that HF theory is used in tooth partitioning.

A strategy of assigning constraints for HF is proposed based on prior knowledge on human teeth.

A boundary-refining method is presented to successfully solve the problem of segmenting teeth from complicated maxillary models with indistinctive tooth boundaries on the lingual side surface. The problem had not previously been solved properly.

As an interactive method, smart interfaces are developed to partition teeth intuitively with minimal user interaction. In contrast, user interface designations are barely introduced in most published interactive methods.

@&#RELATED WORK@&#

This paper focuses on tooth partition. Therefore, mesh segmentation methods are first introduced in the order of general methods and methods designed specifically for tooth partitioning. Then, the concept of HF on 3D triangle meshes and the prior knowledge of human teeth, especially in the context of partitioning, are introduced.

Mesh segmentation is always one of the most popular research fields in mesh processing. Plenty of methods have been proposed, including fully automatic methods, such as random walk [12,13], watershed [14,15], clustering [16], shape diameter function [17], and semi-automatic methods that involve user interaction. Because our major research interest is interactive teeth partitioning, we decided to review some state-of-the-art interactive methods, as introduced below, rather than automatic methods. Extensive summaries on the topic can be found in surveys [18].

Recently, sketch-based interactive mesh segmentation methods [9,11,19–22] have become very popular. These methods generally have simple and intuitive interfaces to help users easily express their intentions between computers and users. In fact, technique details behind similar interfaces are different. For example, in order to segment the objects, an efficient local graph-cut-based optimisation strategy was adopted [9], while an improved region-growing algorithm was used in another study [11]. The methods proposed in additional studies [19–22] employ the HF theory for segmentation, but they are different in computational parameters and interactive styles. Interested readers can refer to the literature [23,24] on the comparison between these sketch-based methods.

Nevertheless, the sketch-based methods introduced above have their own limitations. For instance, the tool introduced in one study [9] makes it difficult to cut out the partial part for smooth surfaces. The methods proposed some other studies [19–22] could not produce high-quality cutting boundaries in cases where no obvious concave region exists at the position of interaction. Furthermore, general methods normally have poorer robustness than do the targeted methods when handling special and complicated objects, such as dental models.

Motivated by these sketch-based general segmentation approaches, our method also employs HF for segmentation, but in a tooth-target manner (see Section 3), which makes the proposed method superior to general segmentation methods. In addition, Zheng et al. [19], who name their method “dot scissor (DS),” argue that other than one or multiple sketches used in some studies [9,11,20–22], it is possible to achieve quality segmentations using only single mouse clicks. But, in our research, we notice that one single mouse click is not always sufficient to partition a single tooth from clinical dental models. As a solution, we use the idea of two clicks in order to partition an individual tooth (see Section 3.4).

A large group of segmentation methods have been proposed in order to partition teeth from dental models. In our paper, we classify these methods into three categories: (1) curvature field-based boundary identification method, (2) surface contour line-based boundary identification method and (3) inspection spoke-based segmentation method.

Curvature field is mostly used to identify tooth boundaries. For example, in order to extract feature regions that contain potential tooth boundaries, minimum principal curvature is used in various studies [25–28], while mean curvature is used in others [29,30]. After the feature regions are acquired using thresholding, some methods (e.g., [25,29,26]) adopt morphologic skeleton (MS) operations in order to optimise the feature regions and identify the tooth boundaries. Others, such as the “flood-fill” method [27], the “fast marching watersheds (FMW)” method [28] and the snake-based method [30], directly use the featured regions for segmentation. A summary of these methods is found in Table 1
                        .

The major drawbacks of these methods root in the usage of the unreliable curvature field. The reasons for this include the following: (1) A global value-based thresholding may lead to either over-segmentation, which will impact the accuracy of segmentation, or under-segmentation, which means failure of the partition. The result depicted in Fig. 1
                        (a) is an instance of over-segmentation; some non-tooth regions are included in the extracted tooth part near the cutting position.

On the other hand, the result depicted in Fig. 1(b) is an instance of under-segmentation; two teeth cannot be separated according to the disconnected boundary marked with red rectangle. Actually, MS approaches are used [29] when generating skeletons, as depicted in Fig. 1(b), but the disconnected tooth boundary still exists because morphologic processes before skeletonisation cannot remove some big gaps in feature regions.

(2) Choosing the threshold appropriately sets up a barrier for the automaticity and accuracy of curvature-based methods, since the threshold selection is crucial to these methods. In other words, it is impossible to present an automatic thresholding scheme unless some knowledge about the mesh surface being processed is available [31]. In fact, the threshold in the methods introduced above is either presupposed (as mentioned in [26,30]) or interactive specified (as mentioned in [27]).

(3) The surface curvature is sensitive to noise, which is a classic issue of curvature field-based methods. In a word, though widely used, curvature field is unreliable for partitioning teeth on dental meshes from our perspective.

As another option, surface contour line (SCL) approaches [32,33] allow users to manually select several boundary points on dental meshes, as demonstrated in Fig. 1(c). Then, geodesics are generally used to connect two adjacent control points and form contour lines connected as tooth boundaries. Due to the great flexibility of segmenting complicated dental models, the SCL method is usually used to generate the “ground truth” for experimental evaluation.

However, the shortcomings are also quite obvious. That is to say, users would have to rotate/translate multiple times for carefully specified particular mark points so as to generate one accurate tooth boundary. Such tedious and time-consuming experiences certainly are undesirable for ordinary clinical applications.

Given that tooth boundaries are clear in projected 2D images, inspection spokes are used [34–36] to cut the model in the panoramic image. However, such methods are not as reliable for severe malocclusions because missed interstices and wrong cuts may exist under such circumstances, as depicted in Fig. 1(d).

Compared to methods discussed above, our method is much more effective, efficient and robust because other than the unreliable curvature field, we employ a tooth-target HF which can accurately locate partition boundaries. In the proposed user interfaces, only two selections on the mesh model are needed for segmenting a target tooth in real-time interaction, while, none of the interactive tooth partition methods introduced above specify their user interfaces. Furthermore, the proposed method is robust for use with dental models that have varying complexity, including different malocclusions and dental abnormalities.

Mathematically, a HF on a 3D manifold triangular mesh 
                           M
                           =
                           (
                           V
                           ,
                           E
                           ,
                           F
                           )
                         is a scalar field attached to each mesh point, and satisfies 
                           Δ
                           Φ
                           =
                           0
                        , where V, E and F denote the vertex set, edge set and face set of M respectively. 
                           Δ
                         is the Laplacian operator, subject to particular Dirichlet boundary constraint conditions, i.e., some vertices 
                           
                              
                                 V
                              
                              
                                 c
                              
                           
                           ∈
                           V
                         that are of specified values are treated as constraints in HF [37]. For example, 0 and 1 are used as minimum and maximum bound constraints, respectively, in most of the HF computations. The standard definition of the Laplacian operator on a piecewise linear mesh M is the umbrella operators:
                           
                              (1)
                              
                                 Δ
                                 
                                    
                                       Φ
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       ∈
                                       E
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       ij
                                    
                                 
                                 (
                                 
                                    
                                       Φ
                                    
                                    
                                       i
                                    
                                 
                                 −
                                 
                                    
                                       Φ
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                           
                        where 
                           
                              
                                 w
                              
                              
                                 ij
                              
                           
                         is a scalar weight assigned to the edge 
                           
                              
                                 E
                              
                              
                                 ij
                              
                           
                        . This Poisson equation 
                           Δ
                           Φ
                           =
                           0
                         can then be solved by the least-squares sense, and the equation transforms into
                           
                              (2)
                              
                                 A
                                 Φ
                                 =
                                 b
                                 ,
                                 
                                 A
                                 =
                                 [
                                 
                                    
                                       
                                          
                                             L
                                          
                                       
                                       
                                          
                                             C
                                          
                                       
                                    
                                 
                                 ]
                                 ,
                                 
                                 b
                                 =
                                 [
                                 
                                    
                                       
                                          
                                             0
                                          
                                       
                                       
                                          
                                             b
                                             ′
                                          
                                       
                                    
                                 
                                 ]
                              
                           
                        where L is the Laplacian matrix that is given by
                           
                              (3)
                              
                                 
                                    
                                       L
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 {
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   k
                                                   ∈
                                                   
                                                      
                                                         N
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   (
                                                   i
                                                   )
                                                
                                             
                                             
                                                
                                                   w
                                                
                                                
                                                   ik
                                                
                                             
                                          
                                          
                                             if
                                             
                                             i
                                             =
                                             j
                                          
                                       
                                       
                                          
                                             −
                                             
                                                
                                                   w
                                                
                                                
                                                   ij
                                                
                                             
                                          
                                          
                                             if
                                             
                                             (
                                             i
                                             ,
                                             j
                                             )
                                             ∈
                                             E
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        and C and 
                           b
                           ′
                         are the matrix and the vector, respectively, and stand for the constraints in HF. Different weighting schemes and constraints will lead to different kinds of HF. For example, the standard cotangent-weighting scheme [38], 
                           
                              (4)
                              
                                 
                                    
                                       w
                                    
                                    
                                       ij
                                    
                                 
                                 =
                                 (
                                 cot
                                 
                                    
                                       α
                                    
                                    
                                       ij
                                    
                                 
                                 +
                                 cot
                                 
                                    
                                       β
                                    
                                    
                                       ij
                                    
                                 
                                 )
                                 /
                                 2
                              
                           
                        where 
                           
                              
                                 α
                              
                              
                                 ij
                              
                           
                         and 
                           
                              
                                 β
                              
                              
                                 ij
                              
                           
                         are the angles opposite to edge 
                           
                              
                                 E
                              
                              
                                 ij
                              
                           
                        , will lead to a smooth transiting HF and is well-suited for applications like deformation. The smooth transition property also offers great help in our physical orthotropic material modelling research [37]. However, HF under standard weighting schemes cannot identify the local shape variation, which makes them unsuitable for segmentation purposes [22].

Our method adopts a modified weighting scheme that preserves the nice properties of classic cotangent-weighting schemes while increasing the ability of sensing the concave shape for each tooth.

Prior knowledge of human teeth plays an important role in many tooth partition procedures, and the knowledge used in most published approaches can be concluded as follows:
                           
                              •
                              
                                 Anatomical feature points and incisal edges: As seed points, anatomical feature points on teeth (e.g., red cusps in Fig. 2
                                 (a)) are used [30] to initialise an automatic partition. Along with incisal edges on incisors (e.g., red lines in Fig. 2(b)), the cusp points are also used as landmarks to detect dental arches (as used in [27,35,36]) and occlusal planes (as used in [25,26]).


                                 Dental arch: The dental arch (e.g., green curve in Fig. 2(c)), which represents the shape of the tooth arrangement, is used [27] to realign segmented teeth, and is referred to [35,36] in the context of generating panoramic range images.


                                 Occlusal plane: The occlusal plane (e.g., cyan plane in Fig. 2(d)), which represents the occlusion, is generally used to align dental models to a uniformly defined coordinate system [26].


                                 Positional information: Positional information, such as coarse location of the tooth part in the dental mesh, may be useful for the partition. For example, both Wu et al. [29] and Kronfeld et al. [30] use a PCA-based plane-estimating technique in order to find a plane (e.g., red cutting plane in Fig. 2(e)). This technique divides the dental model into the tooth part and the base part.

As a method designed specifically for tooth partitioning, we also employ prior knowledge to guide our tooth partitioning. See Section 4.2 for further descriptions.

@&#PROPOSED METHOD@&#

Our HF is different from others in four major aspects: weighting scheme of the Laplacian matrix, the constraint assignments for HF calculation, the refining strategy for improving boundaries on some dental models and the user interfaces of segmenting interaction.

In order to keep the nice properties of the classic cotangent-weighting scheme, while also increasing the ability of sensing the concave shape (i.e., enhancing the variation of HF in concave regions and simultaneously suppressing the variation in the rest, as demonstrated in Fig. 3
                        (b)), a modified weighting scheme is introduced. In our strategy, we reserve most of the parameters in standard cotangent-weighting scheme, while the weighting edges in the concave region with smaller values than the weight of the edges belong to the non-concave regions. That is to say, we multiply the 
                           
                              
                                 w
                              
                              
                                 ij
                              
                           
                         in Eq. (4) by a binary coefficient 
                           
                              
                                 γ
                              
                              
                                 ij
                              
                           
                        , and the resulting weight 
                           
                              
                                 
                                    
                                       w
                                    
                                    
                                       ij
                                    
                                 
                              
                              
                                 ˜
                              
                           
                         in our method can be defined by
                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             w
                                          
                                          
                                             ˜
                                          
                                       
                                       
                                          ij
                                       
                                    
                                 
                                 =
                                 
                                    
                                       γ
                                    
                                    
                                       ij
                                    
                                 
                                 (
                                 cot
                                 
                                    
                                       α
                                    
                                    
                                       ij
                                    
                                 
                                 +
                                 cot
                                 
                                    
                                       β
                                    
                                    
                                       ij
                                    
                                 
                                 )
                                 /
                                 2
                              
                           
                        where 
                           
                              
                                 γ
                              
                              
                                 ij
                              
                           
                           =
                           
                              
                                 f
                              
                              
                                 S
                              
                           
                        , which is a small value, if either vertex 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         or vertex 
                           
                              
                                 v
                              
                              
                                 j
                              
                           
                         lies in the concave region, otherwise 
                           
                              
                                 γ
                              
                              
                                 ij
                              
                           
                           =
                           
                              
                                 f
                              
                              
                                 L
                              
                           
                        , which is a large value. Vertex 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         is considered to lie in the concave region if the following inequality holds:
                           
                              (6)
                              
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       avg
                                       ,
                                       i
                                    
                                 
                                 −
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ⊙
                                 
                                    
                                       n
                                    
                                    
                                       i
                                    
                                 
                                 >
                                 λ
                              
                           
                        
                     

Here, 
                           
                              
                                 v
                              
                              
                                 avg
                                 ,
                                 i
                              
                           
                         is given by Eq. (7), 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 i
                              
                           
                         are the position and the normal of vertex 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         respectively, 
                           ⊙
                         denotes the dot product of vectors, and λ is a small constant:
                           
                              (7)
                              
                                 
                                    
                                       v
                                    
                                    
                                       avg
                                       ,
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                    
                                       
                                          v
                                       
                                       
                                          k
                                       
                                    
                                 
                                 /
                                 n
                                 ,
                                 k
                                 ∈
                                 {
                                 j
                                 |
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 E
                                 }
                              
                           
                        
                     


                        Fig. 3 demonstrates the differences between two HFs by mapping field scalar values from 0 to 1 uniformly into colours from red to blue. These two HFs are under the same constraints but in different weighting schemes, i.e., the standard cotangent-weighting scheme (Fig. 3(a)) and ours (Fig. 3(b)). Uniformly sampled iso-lines on the mesh surface are also extracted and coloured to indicate HF variance. From the images, several excellent properties of the proposed HF can be concluded on account of the introduced weighting scheme:
                           
                              •
                              
                                 Shape-awareness: Our HF has strong awareness of concave creases and seams. It means the uniformly sampled iso-lines, which are dense at the concave region, can naturally form the candidates of partition boundaries.


                                 Smoothness: As a method derived from the classic cotangent-weighting scheme, our HF successfully inherits the smooth transition property. That is, the transitions of vertex scalars, from minimum to maximum Dirichlet boundary conditions, are stable and smooth in both concave and non-concave regions. Therefore the cutting boundary consisting of these vertices would be smooth.

There are two special designations for Dirichlet constraints in the proposed HF, i.e., the way of choosing constraint points and the value of constraint points assigned to.

Conventionally, two types of mesh vertices will be assigned as minimum and maximum bound constraints corresponding to vertices on and not on the object respectively. Constraint points in our method are classified into three categories below:
                              
                                 •
                                 
                                    Feature set (FS): The FS contains a set of feature points belonging to the target tooth (e.g. blue spheres in Fig. 4
                                    ). They are automatically identified in our method.


                                    Background set (BS): The BS includes a set of points that surround, yet are certainly not on, the target tooth (e.g., red spheres in Fig. 4). In our method, BS consists of at least one lingual side point and one labial/buccal side point, also automatically identified.


                                    User set (US): The US consists of two points specified interactively by user (e.g., green and yellow spheres in Fig. 4). These two points are placed on two interstices of the target tooth and roughly specify the location of the tooth boundary.

To calculate HF, each constraint point should be assigned a special value. In our solution, minimum (C
                           
                              min
                           ) and maximum (C
                           
                              max
                           ) constraint values are assigned to BS points and FS points respectively, while an interpolated value 
                              
                                 
                                    C
                                 
                                 
                                    I
                                 
                              
                              
                              (
                              
                                 
                                    C
                                 
                                 
                                    min
                                 
                              
                              <
                              
                                 
                                    C
                                 
                                 
                                    I
                                 
                              
                              <
                              
                                 
                                    C
                                 
                                 
                                    max
                                 
                              
                              )
                            is assigned to two US points.

After that, entities of matrix C and vector 
                              b
                              ′
                            introduced above can be set so as to solve Eq. (2). That is to say, if we put all constraint points 
                              {
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              |
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ∈
                              US
                              ∪
                              FS
                              ∪
                              BS
                              ,
                              1
                              ≤
                              i
                              ≤
                              n
                              }
                            on dental mesh M into a list S, and let n and m denote the scale of S and M respectively, then 
                              
                                 
                                    c
                                 
                                 
                                    ij
                                 
                              
                              ∈
                              C
                              
                              (
                              1
                              ≤
                              i
                              ≤
                              n
                           , 
                              1
                              ≤
                              j
                              ≤
                              m
                              )
                            and 
                              
                                 
                                    b
                                 
                                 
                                    i
                                 
                              
                              ∈
                              b
                              ′
                              
                              (
                              1
                              ≤
                              i
                              ≤
                              n
                              )
                            can be given by
                              
                                 (8)
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ij
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          
                                             
                                                w
                                             
                                             
                                                for
                                                {
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                |
                                                M
                                                (
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                =
                                                j
                                                }
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (9)
                                 
                                    
                                       
                                          b
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          
                                             
                                                w
                                             
                                             
                                                for
                                                
                                                {
                                                i
                                                |
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ∈
                                                FS
                                                }
                                             
                                          
                                          
                                             
                                                0.5
                                                w
                                             
                                             
                                                for
                                                
                                                {
                                                i
                                                |
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ∈
                                                US
                                                }
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                for
                                                
                                                {
                                                i
                                                |
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ∈
                                                BS
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           where w is a large constant value and 
                              M
                              (
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              )
                            denotes index of 
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                            in M.


                           Fig. 5
                            demonstrates the reliability with a comparison between state-of-the-art partition methods – DS (Fig. 5(a)) and ours (Fig. 5(b)). DS is supposed to achieve quality segmentations using one single mouse click in this case. Therefore, as illustrated in Fig. 5(a), we use one click (marked with yellow dot in the blue circle), located roughly on partition boundaries repeatedly in the software offered by Zheng et al. [19] in order to partition a target tooth (i.e., the pre-molar). The failure rate within five tests exceeds half. Accordingly, the proposed method is used to partition the same tooth, as illustrated in Fig. 5(b), by selecting the second point that varies from the lingual side to the labial/buccal side surfaces, while keeping the first point fixed, since our method requires two points to segment a single tooth. The acquired boundaries are similar in our case, as long as the constraint points are detected.

From the comparison results, we can see that (1) a single click is not always sufficient to partition a single tooth by adopting HF and (2) as contributions made by the introduced weighting scheme. Our proposed HF also possesses another excellent property on account of specially designed constraints:
                              
                                 •
                                 
                                    High robustness: Our method is robust in handling complicated dental models, due to the use of sufficient constraint points for each target tooth. That is, FS points located on the objective tooth and BS points located on both the lingual side and the labial/buccal side surface can guarantee a closed boundary for dental models with varying complexity. Meanwhile, the two US points specified by the user directly control the accuracy of the boundary, especially on the mesial and distal surfaces of the objective tooth respectively. Besides this, the boundary is not sensitive to user interaction.

After the HF is generated, a number of iso-lines uniformly sampled from HF can be extracted. Then, an optimal iso-loop (e.g., blue loop in Fig. 5(b)) among those iso-lines will be selected as the tooth boundary prepared for the final cutting. However, when the target tooth belongs to the dental model with flat and smooth lingual side surfaces, as demonstrated in Fig. 6
                        (a), even state-of-the-art methods could fail. Fortunately, our proposed method can guarantee a closed boundary that can be used to accurately approximate the labial/buccal side tooth boundary (Fig. 6(b)), though the lingual side curve is not defined well enough (Fig. 6(c)). Therefore, a refining strategy is introduced to fix the problem if necessary.

The idea of our proposed refining strategy is to replace the lingual side iso-loop part with a NURBS curve. After precise observation and large quantities of experience, we notice that (1) the lingual side boundary existing regions are flat on this kind of dental model and (2) the shape of the lingual side boundaries can be approximated by the NURBS curve. Therefore, in our method, the lingual side tooth boundary is regarded as the NURBS curve lying in a proper plane, with dentists satisfied with the solution.

Motivated by partition interfaces introduced in DS, we provide users with an intuitive way to interactively click the mouse at valley regions between two adjacent teeth, like green and yellow dots as demonstrated in Fig. 7
                        (a). These regions correspond to proximal surfaces of the teeth. In addition, the mouse click will roughly specify the location where a tooth boundary (i.e., the cut) is desired.

Specifically, users would begin with clicking on a screen pixel (e.g., hand pointer in Fig. 7(b)) in a selected view to partition a target tooth. Corresponding to the click, point (e.g., green sphere in Fig. 7) can be easily determined on triangular mesh M by intersecting a ray with M. Users can then move the mouse on the screen (e.g., crosses in Fig. 7(c)) to select a second point (e.g., yellow sphere in Fig. 7(c)), while keeping the first one fixed. Then, they can watch the 3D tooth boundary getting updated on the fly. The boundary loop is coloured with blue during this period and will turn red when the user is satisfied (as illustrated in Fig. 7(d)). After that, the second point will automatically be treated as the first one in order to continue segmenting an adjacent tooth.

Under these circumstances, it takes only 
                           N
                           +
                           1
                         (N is a positive integer) times for the user׳s interaction to segment N teeth successfully (e.g., 15 times interaction to partition 14 teeth from Fig. 7(a) illustrated mesh model). The insets in Fig. 7(b) and (c) show close-ups of selecting two US points. A video is provided to demonstrate the interfaces introduced above.

The above-proposed interfaces are not only easy to use, but also beneficial in following aspects:
                           
                              •
                              The selected two user points (i.e., US points) can improve the accuracy of extracted boundaries at the tooth proximal surface, while such accuracy is crucial to subsequent operations, such as the measurement of the tooth long axis and crowding levels.

The rest constraint points (i.e., FS and BS points) can be detected automatically with the proposed interfaces.

The proposed user interfaces are good for reducing user interaction.

@&#IMPLEMENTATION DETAILS@&#

The overview of the system implementation is given in Fig. 8
                        . In a typical segmentation workflow, the dental model is loaded from the disc and viewed in different perspectives while preparing for the partition; this is termed as the pre-partition time. The dental model is then processed (interactively or programmatically) to generate individual teeth; this is termed as the partition time. Therefore, our workflow can also be separated accordingly.

To implement the proposed method, we choose 
                           
                              
                                 f
                              
                              
                                 S
                              
                           
                           =
                           1
                         and 
                           
                              
                                 f
                              
                              
                                 L
                              
                           
                           =
                           0.001
                         as the binary value of the weighting coefficient 
                           
                              
                                 γ
                              
                              
                                 ij
                              
                           
                         in our experiments, and 
                           λ
                           =
                           
                              
                                 10
                              
                              
                                 −
                                 6
                              
                           
                         when we estimated the concave situation of the mesh vertices.

In the proposed method, constraint points are chosen by taking prior knowledge of human teeth into consideration. We use the information of (1) anatomical feature points F, (2) occlusal plane O and (3) height H of the dental model as demonstrated in Fig. 9
                        . Specifically, F are regarded as candidates of FS points in our method. We employ the approach proposed in the research [2] to automatically identify the feature points and occlusal plane because the accuracy of our method is not sensitive to the results of the method of identifying the feature points. We verify the statement by manually selecting the FS points on the tooth, which are different from the points identified in the research [2]. We noticed that the boundaries generated using these two ways are similar.

Meanwhile, the Federation Dentaire Internationale (FDI) notation method that is widely used by dentists is adopted in order to index each tooth and feature points belonging to the tooth. Additionally, the height of the dental model, measured by the distance between O and 
                           O
                           ′
                        , is used to locate BS points, where 
                           O
                           ′
                         is a plane initially located at O. Then we push it iteratively along the normal of O toward the dental base with distance d=1mm until the last position where it intersects with the dental model. With the acquired information, constraint points can be assigned as follows:
                           
                              •
                              
                                 US assigning: Let U and 
                                    U
                                    ′
                                  denote two US points. They will be specified interactively as described above in the user interfaces. Each US point is assigned to C
                                 
                                    I
                                 =0.5, and w is set to 1000 in the HF computation.


                                 FS assigning: Let 
                                    
                                       
                                          U
                                       
                                       
                                          O
                                       
                                    
                                  and 
                                    
                                       
                                          U
                                       
                                       
                                          O
                                       
                                    
                                    ′
                                  denote the projective points of U and 
                                    U
                                    ′
                                  on O respectively, as shown in Fig. 10
                                 . After two meaningful US points are selected, FS points can be easily found, because at least one projective point 
                                    
                                       
                                          F
                                       
                                       
                                          O
                                       
                                    
                                  of them on O will lie in a local region defined by 
                                    
                                       
                                          U
                                       
                                       
                                          O
                                       
                                    
                                  and 
                                    
                                       
                                          U
                                       
                                       
                                          O
                                       
                                    
                                    ′
                                 , while the rest of them have the same FDI index as the detected feature point. The local region we use is a circular disc, while other shapes could be work as long as they detect the FS on the objective tooth. Each FS point is assigned to 
                                    
                                       
                                          C
                                       
                                       
                                          max
                                       
                                    
                                    =
                                    1
                                  in the computation.


                                 BS assigning: The BS points can be identified by intersecting dental models with lines that initially pass through each projective point 
                                    
                                       
                                          F
                                       
                                       
                                          O
                                       
                                    
                                  and are perpendicular to 
                                    
                                       
                                          U
                                       
                                       
                                          O
                                       
                                    
                                    
                                       
                                          U
                                       
                                       
                                          O
                                       
                                    
                                    ′
                                 , as depicted in Fig. 10. Then, the lines are translated to a distance 
                                    D
                                    
                                    (
                                    0
                                    <
                                    D
                                    <
                                    H
                                    )
                                  along normal of O toward dental base. We use 
                                    D
                                    =
                                    2
                                    H
                                    /
                                    3
                                  in our implementations. Each BS point is assigned to 
                                    
                                       
                                          C
                                       
                                       
                                          min
                                       
                                    
                                    =
                                    0
                                  in the computation.

A major challenge in the implementations is to reduce time consumption during the interaction. There are two major strategies employed to realise the real-time feedback:
                           
                              •
                              
                                 Dynamic HF calculation strategy: Because A is a positive definite large-scale sparse matrix in Eq. (2), the cost of HF calculation becomes the principal factor of time consumption in our method. To address the problem, the modern sparse Cholesky factorisation and modification software package introduced in [39,40] is used to efficiently solve the linear system. Corresponding to the dynamic updating strategy proposed in [40], HF pre-computing is carried out once for a model in parallel with the dental features identification and mesh visualisation processes during the pre-partition time. Specifically, two mesh vertices are chosen randomly as minimum and maximum bound constraints in the pre-computing. Therefore at the partition time, HF can be updated timely after constraint points are changed.


                                 Local region based iso-loops extraction strategy: Another strategy to accelerate the procedure is using a local mesh region to extract iso-loops. For a target tooth, we define the local region as part of the dental mesh within a sphere whose centre coordinates are equal to the average coordinates of FS points, and the radius is equal to the average distance from its centre to each BS point. Iso-lines of the local mesh are depicted in Fig. 12
                                 (a).

After the iso-loops are extracted from the HF, a voting strategy similar to [19] is employed in order to select an optimal loop as a boundary of the target tooth. The identified tooth boundary can be used to separate the target tooth, while, as mentioned above, we offer users an option to refine the boundary for a model that has indistinctive tooth boundaries on its lingual side surface. Specifically, we separate the extracted iso-loop according to the scalars computed for each iso-loop point p. Let 
                           
                              
                                 α
                              
                              
                                 p
                              
                           
                         denotes the scalar of p, then we have 
                           
                              
                                 α
                              
                              
                                 p
                              
                           
                           =
                           
                              
                                 n
                              
                              
                                 p
                              
                           
                           ⊙
                           
                              
                                 n
                              
                              
                                 avg
                              
                           
                        , where 
                           
                              
                                 n
                              
                              
                                 p
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 avg
                              
                           
                         denote normal of p and average normal of lingual side BS points respectively, and 
                           ⊙
                         represents the dot product operation.


                        Fig. 11
                        (a) illustrates the scalars (i.e., colour from red to blue attached to the loop). Fig. 11(b) illustrates the reserved labial/buccal side boundary part after thresholding. Then, the NURBS curve is used to approximate lingual side boundary. The NURBS curve lies on plane (e.g., blue plane in Fig. 11(b)) located by three points – two end points of the reserved boundary part and one lingual side BS point. Finally, the NURBS curve (e.g., light green curve in Fig. 11(c)) and the reserved boundary part (e.g., blue curve in Fig. 11(c)) are connected to an integrated one preparing for the mesh cutting.

To conveniently cut and split the mesh surface, a local implicit scalar field is generated by calculating the distance from the points on the boundary to the nearby mesh vertices. The advantage of this implicit cutting operation is that the partition boundaries do not need to be fitted exactly on the mesh surface (such as the lingual side NURBS curve). Boundary curves can be further smoothed through an interpolation operation before the cutting operation is actually carried out. Fig. 11(d) illustrates the cutting result.

@&#EXPERIMENTS AND RESULTS@&#

We used 32 dental models, including upper and lower jaws, to testify the efficiency and accuracy of our method. Many of the models have varying dental abnormalities, for example, some teeth on the dental model depicted in Fig. 12 have a severe crowding problem, while others may be absent from the jaw. The dental model depicted in Fig. 13
                         has indistinctive tooth boundaries on its lingual side surface. Given the restriction on paper length, we only demonstrate segmentation results for 13 cases of our numerous successful results. Among them, 10 are shown in Figs. 12 and 13. Specifically, each row in Fig. 12(a) illustrates partition results on one dental model. Columns in Fig. 12(a) depict intermediate results of the interactive partition, including detected constraint points on the target tooth and iso-lines extracted from the HF within a local region. The final partition results are shown in Fig. 12(b)–(g).

The success in segmenting teeth from dental models illustrated in Fig. 13 is on account of our proposed refining strategy. In conclusion, the experimental results demonstrate that our approach is effective in accurately segmenting individual teeth from dental models with minimum interaction.

We compare our method with several segmentation approaches, including (1) the DS [19], (2) the FMW [28] and (3) the MS [29]. Actually, DS is the general segmentation approach that inspired this work. Both FMW and MS are approaches designed specifically for tooth partitioning. In contrast, FMW is an interactive method that employs the classic watershed algorithm, while MS is an automatic approach that is superior to the methods proposed in [27,30], as introduced in [29].


                        Fig. 14(a) and (b) shows the partition results of DS and ours respectively. Although DS performs fairly well in the segmentation, insets in Fig. 14(a) show that the generated boundaries may intersect or nest with each other occasionally, whereas our approach produces good results without having such problems.

In this paper, we claim that surface curvature is unreliable for clinical tooth partitioning. We support the argument by employing two typical curvature-based methods for segmentation. Figs. 14(c), (d) and 15
                        
                         illustrate the comparisons. We also provide videos to animate the procedures depicted in the figures.

Specifically, we use software provided by Kalogerakis et al. [41] to generate the curvature field. Seeds of regions corresponding to each tooth are specified by feature points as used in our method. Seeds of regions corresponding to the dental base are specified interactively. Then, a fast marching watershed algorithm is employed to flood from the seeds to the rests on the dental model. As Fig. 14(c) shows, both over-segmentation and under-segmentation occurred using FMW.

In the other comparison, morphologic skeleton operations are employed to identify tooth boundaries. The detected non-tooth part, tooth part and potential tooth boundaries are coloured with red, pink and blue respectively in Fig. 15(b) and (c). If the threshold is chosen inappropriately, disconnected regions that are marked with red and green rectangles, as shown in Fig. 15(a), will lead to nonseparated and undetected teeth using MS respectively, as depicted in Fig. 15(b). We are unable to carry on the partition procedures after skeletonisation and pruning because of the non-tooth regions (e.g., the bulge) shown in Fig. 15(c). These non-tooth regions are incorrectly included in the tooth part of MS.

On one hand, the threshold selection issue is avoided in our approach. On the other hand, the bulge problem will not affect our approach, as demonstrated in Fig. 15(d). Furthermore, it demonstrates the high accuracy of our method that gum regions on the interstices between the teeth are excluded in our segmented teeth (see inset in Fig. 15(d)), while such regions are included in the segmented teeth and ignored by MS.

@&#EVALUATION@&#

Since there are no existing dental segmentation benchmarks providing ground truth for evaluation, we asked two dentists, given the necessary training and sufficient practice time, to identify the boundary of each tooth manually on all experimental models using the SCL method. For each tooth, all its marked contours from the two dentists were averaged to produce its ground truth. Fig. 16
                         shows some segmented teeth and their ground truth by overlapping the two models and highlighting the differences marked with blue and orange. Then, the Directional Cut Discrepancy (DCD) method [42] is employed to calculate the mean errors. The mean errors shown in Fig. 17
                         demonstrate that our approach has average mean errors of about 0.13mm, which is approved by the dentists.

We also recorded the time consumption of our proposed method, as shown in Fig. 18
                        , including the average time consumed by HF updating, local mesh extracting, iso-lines extracting, tooth boundary selecting and the total time for single tooth segmenting in the partition time. All experiments were carried out on a common PC computer with an Intel Core Quad-core processor 2.67GHz with 4GB memory. The time cost for a single tooth interactive partition ranges from less than one second to nearly 4.5s, and ascends with the scale of dental models in our experiments. In contrast, the popular commercial software “3Shape” often takes several minutes to segment one model with intensive interaction.

@&#CONCLUSIONS@&#

In this paper, we propose an innovative approach to interactively partition individual teeth from digital maxillary or mandibular models. Though widely used in most published tooth partitioning methods, curvature field is unreliable for segmenting teeth in terms of accuracy, and we support this argument through the experimental results of two curvature-based segmentation methods designed specifically for tooth partitioning.

In addition to surface curvature, a tooth-target harmonic field with improved weighting schemes and constraints guided by prior knowledge is employed to identify the tooth boundaries in our approach. Additionally, a boundary-refining strategy is introduced to successfully solve the problem of a complicated model with indistinctive tooth boundaries on its lingual side surface.

As a novel interactive method, smart and intuitive user interfaces are also proposed to improve the flexibility and reduce user interaction. Effectiveness and efficiency of the proposed method is approved by (1) comparisons between state-of-the-art methods and ours, (2) mean errors and (3) time consumption evaluations.

Since our proposed framework is based on HF, the input models should be manifold. Right now, one tooth is corresponding to one HF in our method. It would be more interesting to extend the current framework for multiple teeth partitioning under a uniform HF, and further reduce the interaction. Given that the time consumption of the HF based method will increase, along with augment of the mesh scale, segmenting teeth from high precision dental models with low time cost might be another interesting future direction to explore.

None declared.

@&#ACKNOWLEDGMENTS@&#

The authors would like to thank the anonymous reviewers for their helpful comments. We are also grateful to Zheng Zou and Qing Liu for proofreading the manuscript. This research was supported by the National Natural Science Foundations (Nos. 61173122 and 60903136), Key Project of Natural Science Foundation of Hunan Province, China (No. 12JJ2038).

Supplementary data associated with this paper can be found in the online version of http://dx.doi.org/10.1016/j.compbiomed.2014.10.013.


                     
                        
                           Video 1
                           
                              Demonstration of the interfaces in our tooth partition method.
                           
                           
                        
                     
                     
                        
                           Video 2
                           
                              Demonstration of tooth partition using fast marching watersheds [28].
                           
                           
                        
                     
                     
                        
                           Video 3
                           
                              Demonstration of tooth partition using fast morphologic skeleton [29].
                           
                           
                        
                     
                  

@&#REFERENCES@&#

