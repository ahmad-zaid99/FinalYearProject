@&#MAIN-TITLE@&#Implementation of a parallel finite-element library: Test case on a non-local continuum damage model

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           New finite-element code based on a hybrid object/vector design.


                        
                        
                           
                           Parallel implementation showing a close to perfect scalability on integral type localization limiter algorithms.


                        
                        
                           
                           Results in agreement with theoretical predictions and comparable to other numerical approaches in terms of energies and fragments’ shapes are obtained with an explicit time-integration scheme and non-local continuum damage.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Finite element method

Parallel computing

Continuum damage

Non-local approach

@&#ABSTRACT@&#


                  This paper presents an efficient method to implement a damage law within an explicit time-integration scheme, in an open-source object-oriented finite-element framework. The hybrid object/vector design of the framework and implementation choices are detailed in the special case of non-local continuum damage constitutive laws. The computationally demanding aspect of such constitutive laws requires efficient algorithms, capable of using High Performance Computing (HPC) clusters. The performance of our approach is demonstrated on a numerically and physically challenging 3D dynamic brittle-fragmentation test case. An almost perfect scalability is achieved on parallel computations. The global dynamics and energy terms are in good agreement with classical cohesive models’ predictions.
               

@&#INTRODUCTION@&#

Understanding the different mechanisms involved in the fracture of brittle materials under dynamic loading, such as crack branching, or the transition between different types of crack propagation (trans/intra-granular) is key in the design of new materials. A way to study these mechanisms is by the use of numerical methods. Many numerical approaches can be found in the literature, such as peridynamics [1,2], eigenerosion [3], or finite-element methods with additions to represent a discontinuity like cohesive models [4], the eXtended Finite-Element Method (X-FEM) [5], or continuum damage with localization limiters such as delayed damage [6], second gradient [7] or non-local integral [8].

In the context of this paper, the continuum damage with non-local integral type limiters will be used due to its ease of implementation and the fact that it is well-established for at least static-fracture mechanics problems [8,9]. This method however is computationally demanding, since in the constitutive law a neighborhood of each material point has to be taken into account. Therefore, the use of parallelism in the implementation of such a method can decrease the execution times considerably. To the author׳s knowledge there are only pure C++ object-oriented or pure Fortran implementations for the explicit non-local method implementation as shown in [10] or [11]. Contrasting such single programming paradigm implementations, this paper will present a new code developed by the authors and named Akantu [12], that aims to combine the advantages of both views: the genericity and extensibility of the object-oriented paradigm of C++, and the vectorial efficiency present in Fortran. In this code we included parallelism capabilities with the idea of combining performance with ease of implementation of complex algorithms.

This paper is organized in three major sections. First it presents some reminders on the finite-element method, particularly in the context of non-local continuum damage. Second, it explains the implementation details in the case of library Akantu. Third, it presents a 3D fragmentation test-case that validates the method.

In this paper we will assume the case of continuum solid mechanics with an explicit time-integration scheme. If we consider a central difference scheme, the finite-element formulation can be reduced to the following equations that must be solved iteratively:
                           
                              (1)
                              
                                 M
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ¨
                                          
                                       
                                    
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       f
                                    
                                    
                                       
                                          
                                             ext
                                          
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                    
                                 
                                 −
                                 
                                    
                                       f
                                    
                                    
                                       
                                          
                                             int
                                          
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       u
                                    
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       u
                                    
                                    
                                       n
                                    
                                 
                                 +
                                 Δ
                                 t
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ̇
                                          
                                       
                                    
                                    
                                       n
                                    
                                 
                                 +
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 Δ
                                 
                                    
                                       t
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ¨
                                          
                                       
                                    
                                    
                                       n
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ̇
                                          
                                       
                                    
                                    
                                       n
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ̇
                                          
                                       
                                    
                                    
                                       n
                                    
                                 
                                 +
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 Δ
                                 t
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ¨
                                          
                                       
                                    
                                    
                                       n
                                    
                                 
                                 +
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 Δ
                                 t
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ¨
                                          
                                       
                                    
                                    
                                       n
                                       +
                                       1
                                    
                                 
                              
                           
                        
                     

In these equations, 
                           
                              
                                 u
                              
                              
                                 n
                              
                           
                        , 
                           
                              
                                 
                                    
                                       u
                                    
                                    
                                       ̇
                                    
                                 
                              
                              
                                 n
                              
                           
                         and 
                           
                              
                                 
                                    
                                       u
                                    
                                    
                                       ¨
                                    
                                 
                              
                              
                                 n
                              
                           
                         represent the approximations of the displacement, velocity and acceleration at a time t
                        
                           n
                        , 
                           M
                         is the mass matrix, and 
                           
                              
                                 f
                              
                              
                                 
                                    
                                       ext
                                    
                                    
                                       n
                                    
                                 
                              
                           
                        , 
                           
                              
                                 f
                              
                              
                                 
                                    
                                       int
                                    
                                    
                                       n
                                    
                                 
                              
                           
                         are the external and internal forces respectively. Finally, 
                           Δ
                           t
                         is the time step defined such that 
                           
                              
                                 t
                              
                              
                                 n
                                 +
                                 1
                              
                           
                           =
                           
                              
                                 t
                              
                              
                                 n
                              
                           
                           +
                           Δ
                           t
                        . In order to have a stable explicit time-integration, 
                           Δ
                           t
                         is submitted to the Courant–Friedrichs–Lewy condition [13].

Eqs. (2) and (3) are usually rewritten in a predictor/corrector way, which leads to a possible separation of a time iteration in four stages: prediction of the kinematic variables, computation of the new internal forces, resolution of the acceleration and correction of the kinematic variables.

In this formulation, the material׳s behavior is taken into account in the computation of the internal forces.

The forces are computed from the stress at each material point. Therefore, for all such points, the constitutive law has to be defined.

In the simplified case of a linear elastic and brittle material, isotropic damage can be represented by a scalar variable d, which varies from 0 to 1 for no damage to fully broken material respectively. The stress–strain relationship then becomes 
                           
                              
                                 σ
                                 =
                                 (
                                 1
                                 −
                                 d
                                 )
                                 C
                                 :
                                 ε
                              
                           
                        where 
                           σ
                         and 
                           ε
                         are the Cauchy stress and strain tensors, and 
                           C
                         is the elastic stiffness tensor. This formulation has been proven to lead to a localization of the strain-softening region [14].

As previously mentioned, there exists many localization limiters. In this paper, we will only consider the integral non-local approach. This approach consists in replacing a variable v in the constitutive law with its average 
                           
                              
                                 v
                              
                              
                                 nl
                              
                           
                         on the direct neighborhood (4). In continuum damage models this is usually done on a scalar variable that is used as a criterion for damage evolution.
                           
                              (4)
                              
                                 
                                    
                                       v
                                    
                                    
                                       nl
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       ∫
                                    
                                    
                                       N
                                    
                                 
                                 α
                                 (
                                 x
                                 ,
                                 ω
                                 )
                                 v
                                 (
                                 ω
                                 )
                                 
                                 d
                                 ω
                              
                           
                        where N is the neighborhood of interest and 
                           α
                           (
                           x
                           ,
                           ω
                           )
                         is the weight function defined as
                           
                              (5)
                              
                                 α
                                 (
                                 x
                                 ,
                                 ω
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             α
                                          
                                          
                                             o
                                          
                                       
                                       (
                                       ∥
                                       x
                                       −
                                       ω
                                       ∥
                                       )
                                    
                                    
                                       
                                          
                                             ∫
                                          
                                          
                                             N
                                          
                                       
                                       
                                          
                                             α
                                          
                                          
                                             o
                                          
                                       
                                       (
                                       ∥
                                       x
                                       −
                                       η
                                       ∥
                                       )
                                       
                                       d
                                       η
                                    
                                 
                              
                           
                        
                     

The non-normalized actual weight function α
                        
                           o
                         can have different expressions [15]. One that is commonly used is the bell-shaped function (6).
                           
                              (6)
                              
                                 
                                    
                                       α
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 r
                                 )
                                 =
                                 {
                                 
                                    
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      1
                                                      −
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     r
                                                                  
                                                                  
                                                                     2
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     R
                                                                  
                                                                  
                                                                     2
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   )
                                                
                                                
                                                   2
                                                
                                             
                                          
                                          
                                             for
                                             
                                             r
                                             ≤
                                             R
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In this weight function, R defines the radius of the sphere N. In some cases it can be related to a material parameter, but in most cases R is an internal parameter that has to be chosen carefully to get meaningful results.

To completely define the damage model, we still have to define an evolution law for the damage d. Many evolution laws can be found in the literature. For the purposes of this paper, we will use a simple isotropic damage evolution based on an energy criterion [16,17].
                           
                              (7)
                              
                                 Y
                                 =
                                 
                                    
                                       
                                          1
                                       
                                       
                                          2
                                       
                                    
                                 
                                 ε
                                 :
                                 C
                                 :
                                 ε
                              
                           
                        
                        
                           
                              (8)
                              
                                 F
                                 =
                                 Y
                                 −
                                 
                                    
                                       Y
                                    
                                    
                                       d
                                    
                                 
                                 −
                                 Sd
                              
                           
                        
                        
                           
                              (9)
                              
                                 d
                                 =
                                 {
                                 
                                    
                                       
                                          
                                             min
                                             (
                                             
                                                
                                                   
                                                      
                                                         Y
                                                         −
                                                         
                                                            
                                                               Y
                                                            
                                                            
                                                               d
                                                            
                                                         
                                                      
                                                      
                                                         S
                                                      
                                                   
                                                
                                                ,
                                                
                                                1
                                             
                                             )
                                          
                                          
                                             if
                                             
                                             F
                                             >
                                             0
                                          
                                       
                                       
                                          
                                             unchanged
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In this formulation Y is the strain energy release rate, Y
                        
                           d
                         is the rupture criterion and S is the damage energy. The non-local version of this damage evolution law is constructed by averaging the energy Y.

We implemented an efficient general purpose finite-element library called Akantu [12]. As a demonstration of the possibilities of this library, we implemented in it the model presented in the previous section. This open-source object-oriented library distinguishes itself from other finite-element codes by its hybrid object/vector architecture. It uses the object-oriented view for “high-level” algorithms. This abstraction endows the code with properties such as re-usability, genericity, and ease-of-extension. But for “low-level” processes, such as loops on elements, nodes or material points, the mechanisms of object-oriented programming such are virtual calls can be slow. Consequently, in Akantu the choice was made to code these critical loops in a vectorial way, i.e. similar to a C or Fortran manner. This hybrid implementation style uses the advantages of both the object-oriented and the procedural programming paradigms. To understand better this hybrid view, Fig. 1
                         presents the different representations of a mesh in the case of the three paradigms, 1(a) the object-oriented view where every part of the mesh is an object, (b) the vectorial view where the mesh exists virtually through the vectors storing its data, and finally (c) the hybrid that mixes both views.

To achieve better performance, we developed parallel computation capabilities in Akantu. This parallelism is based on a regular domain decomposition method and message-passing communications. The mesh is split in order to balance the number of elements per processor – since the computation is proportional to this number – and to reduce the size of the interface between processors since the amount of communication is linked to this size [18]. In addition to this mesh partitioning, Akantu uses a layer of ghost elements to define the communication scheme as shown in Fig. 2
                        . For an explicit time-integration scheme, as previously indicated, Eqs. (1)–(3) can be rewritten in four stages: prediction, computation of internal forces, resolution of the acceleration, and correction. In the cases where ghost elements are used, the parallelism appears only in the computation of internal forces as described in Algorithm 1. The three other stages are done locally on each processor by simple iterations on all nodes to conserve the contiguity of the data in memory. 
                           Algorithm 1
                           Parallel computation of internal forces.
                                 
                                    •
                                    evaluation of non-ghost elements stresses

starting synchronization of ghost elements stresses (dark brown arrows in Fig. 2)

assembling non-ghost elements contributions to the internal forces

finishing the communications

assembling ghost elements contributions to internal forces

In this algorithm, the communications that are marked by arrows are overlapped with the assembly of forces for local elements. This is important because, by making the choice of having ghost elements instead of the more commonly used shared nodes, extra computations are involved but simpler communications are needed. The internal forces are computed for each ghost element, as many times as an element is shared. The advantage of using ghost elements is that it simplifies most of the parallel algorithms, since most of the computations are element-based. A direct example of this is our implementation of non-local damage.

For the integral non-localization it has been shown in Section 2.2 that the stresses computation needs to take into account a neighborhood. In the case of Eq. (6) this neighborhood is a sphere of radius R. This implies the ability to identify the neighbors of a given material point, which can be done by pre-computing the neighbors׳ list for each point. For this, we use a regular spacial grid to accelerate the search of the neighbors, which is an algorithm fast enough for a spatial search that is done only once at the initialization step. Once the pairs of neighbors are determined, the associated weights can be computed. Depending on the type of weight function used, updates of the weights could be performed during the simulation.

After completion of these steps, everything is in place to compute the internal forces based on a non-local variable. For the computation of internal forces, only the part concerning the evaluation of the stress is then modified. In fact, the variable on which the damage depends has to be computed and averaged before the damage, and therefore the stress, can be computed. In the case of the damage law used in this paper (7), this variable is Y.

In the parallel version of the code, we need to add new layers of ghost elements, in order to have enough information to average a variable on the border elements (see Fig. 3
                        ). Since we pre-compute the neighbors, the corresponding communications scheme is also pre-computed.

These additional ghost elements need to be synchronized during the computation of the stresses in order to compute the correct averages of the non-local variable. This modifies the first step of Algorithm 1. The changes in the algorithm are presented in Algorithm 2. We wrote this algorithm to non-localize any state variable of a given constitutive law even if in this paper we present only the example of a damage law. In the description of the algorithm we are using the notations of Eq. (4). 
                           Algorithm 2
                           Parallel computation of internal forces with non-local contributions.
                                 
                                    •
                                    computation of the local variable v on the non-ghost elements

starting synchronization of v for ghost and extra ghost elements (light orange arrows in Fig. 3)

integration of non-ghost elements contributions to 
                                          
                                             
                                                v
                                             
                                             
                                                nl
                                             
                                          
                                        the non-local variable

finishing the communication of v
                                    

integration of all the ghost elements contributions to the 
                                          
                                             
                                                v
                                             
                                             
                                                nl
                                             
                                          
                                       
                                    

evaluation of non-ghost elements stresses based on 
                                          
                                             
                                                v
                                             
                                             
                                                nl
                                             
                                          
                                       
                                    

starting synchronization of ghost element stresses (dark brown arrows in Fig. 3)

assembling non-ghost element contributions to the internal forces

finishing the communications

assembling ghost element contributions to the internal forces

Here again the communications are shown with arrows and are overlapped with computations on the local elements. To simplify the constitutive laws code, the communications and the averaging are always performed, even if there is no damage. This choice should not impact the performances since the communications are overlapped. Updating the neighbor list would be more expensive. The verification and the efficiency of this algorithm and our implementation will be discussed in the next section.

Basic validity tests were performed by Wolff [19], using our code Akantu with a different damage law. A mesh convergence study was conducted and a Nooru-Mohamed [20] test was simulated. In [19], it was also shown that the damage patterns are not mesh dependent. Material parameters were explored to see their influence on the crack patterns and crack velocities. Therefore in this section the simulations will be focused on the parallelism performance. In order to check the approach for the non-local continuum damage implementation in parallel, and to assess its efficiency, we will use a fragmentation test presented by Levy in [21], in which a cohesive element approach (also called discrete approach) was used. The results obtained by Levy give information during the simulation that can be used as a benchmark. Relevant quantities include the number of fragments as a function of strain rate, and the various energy terms. Even if the cohesive element method suffers from mesh dependency, the predictions obtained with this method are in good agreement with experiments [22,23]. Furthermore the cohesive element method has been shown to be in good agreement with energy based model predicting fragment size [24].

The fragmentation text presented by Levy consists of a 3D dome exposed to an explosive loading. The parameters for this test have been taken from [21]. Because of the problem׳s symmetries, we can simulate only a quarter of the dome (see Fig. 4
                        ). The normal displacements are blocked on each flat face of the quarter dome and a velocity 
                           
                              
                                 v
                              
                              
                                 0
                              
                           
                           (
                           x
                           )
                           =
                           
                              
                                 
                                    
                                       ε
                                    
                                    
                                       ̇
                                    
                                 
                              
                              
                                 0
                              
                           
                           x
                         is initially set. The material used is an aluminum oxide, 
                           
                              
                                 Al
                              
                              
                                 2
                              
                           
                           
                              
                                 O
                              
                              
                                 3
                              
                           
                         99.5%. This material is characterized by its Young׳s modulus 
                           E
                           =
                           370
                           
                           MPa
                        , density ρ=3900kg/m3, and Poisson ratio ν=0.22. The damage law is defined by a uniform distribution of Y
                        
                           d
                         between 94kJ/m3 and 103.4kJ/m3, S=757.6kJ/m3 and R=0.1mm. The non-constant values for Y
                        
                           d
                         correspond to an introduction of defects. The parameters Y
                        
                           d
                         and S are computed from the critical stress 
                           
                              
                                 σ
                              
                              
                                 c
                              
                           
                           =
                           264
                           
                           MPa
                         and the fracture energy 
                           
                              
                                 G
                              
                              
                                 c
                              
                           
                           =
                           50
                           
                           N
                           /
                           m
                         as follows: 
                           
                              
                                 Y
                              
                              
                                 d
                              
                           
                           =
                           
                              
                                 σ
                              
                              
                                 c
                              
                              
                                 2
                              
                           
                           /
                           2
                           E
                         and 
                           S
                           =
                           
                              
                                 EG
                              
                              
                                 c
                              
                              
                                 2
                              
                           
                           /
                           2
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                           
                              
                                 σ
                              
                              
                                 c
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 Y
                              
                              
                                 d
                              
                           
                         
                        [17].

In order to have a sufficient number of neighbors in the radius of 0.1mm a fine mesh has to be used. These simulations have been run on a mesh with 1,460,670 linear tetrahedrons, which leads to an average of 14 neighbors per material point.

The simulations were performed on a Sandy Bridge cluster composed of 16-core nodes (2 octo-core processors) with 32GB of RAM. The nodes were interconnected with an Infiniband network. Up to 21 nodes were used.

@&#RESULTS@&#

In these simulations, we measured the kinetic, potential and dissipated energies, and the average execution time per time-step. The energies allowed us to check the computation׳s throughout the simulations for different numbers of cores. It is also a good indicator to check the simulation results. Fig. 5
                         shows the energies measured on 16 cores with 
                           
                              
                                 
                                    
                                       ε
                                    
                                    
                                       ̇
                                    
                                 
                              
                              
                                 0
                              
                           
                           =
                           
                              
                                 10
                              
                              
                                 3
                              
                           
                           /
                           s
                        . These energies are in close agreement with the ones measured by Levy ([21] Section 8.2.1). We start with kinetic energy in the system due to the initial velocity. This kinetic energy is transferred in potential energy, and once the potential energy reaches a critical limit locally, the material starts to damage hence to dissipate some of the stored potential energy. Furthermore, the total energy is conserved during the complete process. The energies for different number of processors were compared even if they are not shown here. Apart from some minor variations due to the random distribution of Y
                        
                           d
                        , they are close to each other. Fig. 8(a) shows the fracture map of the same simulation. Note that results are not symmetric due to the distribution of defects through the variations of Y
                        
                           d
                        . The fracture patterns leading to a formation of a few large fragments that go through the complete thickness are also consistent with the results obtained by Levy ([21] Section 8.2.2).


                        Fig. 8(b) corresponds to the same simulation with an initial strain rate of 
                           
                              
                                 
                                    
                                       ε
                                    
                                    
                                       ̇
                                    
                                 
                              
                              
                                 0
                              
                           
                           =
                           3
                           ×
                           
                              
                                 10
                              
                              
                                 3
                              
                           
                           /
                           s
                        . In this case the fragments that are formed are spread evenly on the thickness and the surface. The number of fragments is clearly larger as predicted from theoretical models [25,26]. Furthermore, as commented by Levy [21], when the strain rate is increased the shape of the fragments should change from large fragments that cross the complete section to roughly equiaxed small fragments in the thickness. The corresponding energies are shown in Fig. 6
                        . In this case the initial velocity is three times higher, which implies that nine times more energy is injected in the dome. All this energy cannot be converted into potential energy and therefore induces severe damage in the dome while it expands. The almost constant kinetic and potential energies observed after the damaging process comes from the fact that the created fragments move freely by conserving their velocity. No contact between fragments is considered. The two dominating energy terms are the kinetic and dissipated energy, which is coherent to the dynamic regime of fragmentation [25,27]. The dynamic fragmentation process appears thus more sensitive to global dynamics and energy exchanges than to local to crack paths, which are mesh dependent with the cohesive-element approach.

For the scalability check we measured the execution time of a step by averaging the time required for the 1000 first time steps. In order to have enough damage in these first steps the simulations were run with 
                           
                              
                                 
                                    
                                       ε
                                    
                                    
                                       ̇
                                    
                                 
                              
                              
                                 0
                              
                           
                           =
                           3.5
                           ×
                           
                              
                                 10
                              
                              
                                 3
                              
                           
                           /
                           s
                        . These times are shown in Fig. 7
                        . They are plotted in a logarithmic scale, since in the case of perfect scalability, 
                           t
                           (
                           n
                           )
                           =
                           t
                           (
                           1
                           )
                           /
                           n
                         with n being the number of cores. 
                     

To determine how close we are to perfect scalability, we fit our results with the following function: 
                           t
                           (
                           n
                           )
                           =
                           a
                           /
                           
                              
                                 n
                              
                              
                                 b
                              
                           
                        . In a perfect case, 
                           a
                           =
                           t
                           (
                           1
                           )
                         and b=1. We ran two sets of simulations, an effective non-local one with a radius of 0.1mm, and a control simulation with a radius of 0mm.

The control simulation tests the parallelism of the code with no non-localization. The fit gives b=0.968, which means that the library itself gives results almost perfectly scalable. If we consider the non-localization, scalability increases to b=0.997, but the overall time is higher. This higher time is due to additional computations, which also explain the improvement of the scalability since the overlap of the communications can be higher. These results were obtained not by fitting all the data, but only for a number of cores higher than 8. The reason is that there are two distinct trends from 1 to 8 cores and for 8 or more cores. The fitting of the first part gives a=2.07s and b=0.914, which means an overall lower execution time and less scalability. In this paper, we focused on the trend for more than 8 cores, since this part is the one that helps a user predict the execution time of simulations. The change of behavior seems to be linked to the change from 1 to more processors. This has been observed on other tests, not shown here, on a cluster composed of bi-hexa core nodes. Since Akantu is demanding in memory bandwidth, this change of trend can be linked to Non-Uniform Memory Access (NUMA) effects on one processor, which become less important once the data are accessed by cores of different processors.

@&#CONCLUSION@&#

In this paper, we presented a new finite-element code, Akantu. We explained how a non-local continuum damage law has been implemented in an efficient and straightforward way by using parallel capabilities. Akantu׳s hybrid object/vector view adds even more efficiency to these algorithms. The performance of this implementation has been illustrated on a 3D test case for which near-perfect scalability was achieved. The model was verified with simulations of dynamic fragmentation of a ceramic spherical structure. The dissipated energy and number of fragments increased with applied velocity as predicted by theoretical models. Also the fragments shapes were found to be in agreement with predictions obtained with the cohesive element approach.

@&#ACKNOWLEDGMENT@&#

The authors would like to thank Guillaume Anciaux for discussion on the code׳s design, and Marion Chambart and Cyprien Wolff for their participation in discussions about non-local damage.

This research is supported by the European Research Council ERCstg 
                  UFO-240332.

@&#REFERENCES@&#

