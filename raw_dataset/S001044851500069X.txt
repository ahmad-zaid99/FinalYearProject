@&#MAIN-TITLE@&#Robust polyhedral Minkowski sums with GPU implementation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We compute Minkowski sum boundaries of two input polyhedra.


                        
                        
                           
                           Sum polygons from convolution are created, subdivided, and traversed for boundary construction.


                        
                        
                           
                           The algorithm is robustly implemented on CPU and GPU both.


                        
                        
                           
                           The performance on GPU is orders-of-magnitude higher than previous works.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Minkowski sums

Robust computational geometry

GPU algorithms

@&#ABSTRACT@&#


                  We present a Minkowski sum algorithm for polyhedra based on convolution. We develop robust CPU and GPU implementations, using our ACP strategy to eliminate degeneracy and to enforce a user-specified backward error bound. We test the programs on 45 inputs with an error bound of 
                        1
                        
                           
                              0
                           
                           
                              −
                              8
                           
                        
                     . The CPU program outperforms prior work, including non-robust programs. The GPU program using 2688 CUDA cores exhibits a median speedup factor of 36, which increases to 68 on the 6 hardest tests. For example, it computes a Minkowski sum with a million features in 20 seconds.
               

@&#INTRODUCTION@&#

Minkowski sums are a core computational geometry concept with applications in solid modeling, packing, assembly, and robotics. The Minkowski sum of point sets 
                        A
                      and 
                        B
                      is
                        
                           
                              A
                              ⊕
                              B
                              =
                              
                                 {
                                 a
                                 +
                                 b
                                 ∣
                                 a
                                 ∈
                                 A
                                 ∧
                                 b
                                 ∈
                                 B
                                 }
                              
                              .
                           
                        
                      If 
                        A
                      and 
                        B
                      are polyhedra, 
                        A
                        ⊕
                        B
                      is a polyhedron. Fig. 1
                      shows a star 
                        A
                     , a tetrahedron 
                        B
                     , and 
                        A
                        ⊕
                        B
                     . Minkowski sums facilitate contact analysis. Let 
                        −
                        A
                        +
                        t
                      denote 
                        A
                      reflected around the origin and translated by 
                        t
                     . The polyhedra 
                        −
                        A
                        +
                        t
                      and 
                        B
                      overlap if 
                        t
                      is in the interior of 
                        A
                        ⊕
                        B
                      and touch if 
                        t
                      is on its boundary. In Fig. 1, the snapshots show 
                        −
                        A
                        +
                        
                           
                              t
                           
                           
                              i
                           
                        
                      and 
                        B
                      at three 
                        
                           
                              t
                           
                           
                              i
                           
                        
                      on the boundary of 
                        A
                        ⊕
                        B
                     . A vertex of 
                        A
                      touches a facet of 
                        B
                      at 
                        
                           
                              t
                           
                           
                              1
                           
                        
                     , two edges touch at 
                        
                           
                              t
                           
                           
                              2
                           
                        
                     , and both cases occur at 
                        
                           
                              t
                           
                           
                              3
                           
                        
                     . Configurations where one pair of features touch, such as 
                        
                           
                              t
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              t
                           
                           
                              2
                           
                        
                     , are in the interior of boundary facets, whereas configurations where two pairs touch, such as 
                        
                           
                              t
                           
                           
                              3
                           
                        
                      are on their edges.

The most efficient approach to Minkowski sum computation uses Kaul and Rossignac’s convolution  [1]. Our prior algorithm using that convolution  [2] is the first robust implementation of any convolution algorithm for general polyhedra (Section  2). We present an improved algorithm that is faster and that uses less memory (Section  3). The computational bottleneck in convolution algorithms is finding which facets intersect. We present a novel kd-tree algorithm that finds all intersecting pairs in a set of geometric objects without splitting objects and without using a hash table to avoid duplicate tests. The memory bottleneck is the arrangement of the convolution. We present a novel technique for discarding a large portion that does not contribute to the Minkowski sum boundary.

We implement our algorithm robustly, using our ACP strategy  [3] to eliminate degeneracy and to enforce a user-specified backward error bound (Section  4). Appendix describes a GPU implementation. We tested both programs on 45 pairs of polyhedra with an error bound of 
                        1
                        
                           
                              0
                           
                           
                              −
                              8
                           
                        
                      (Section  5). The CPU program outperforms prior work, including non-robust programs. The GPU program using 2688 CUDA cores exhibits a median speedup factor of 36, which increases to 68 on the 6 hardest tests. For example, it computes a Minkowski sum with a million features in 20 s.

The main approaches to computing Minkowski sums of polyhedra are convex decomposition and convolution.

The first approach decomposes the polyhedra into convex components, computes the Minkowski sums of the components with a specialized algorithm  [4], and returns their union. This approach is inefficient because a polyhedron with 
                        r
                      reflex edges can have 
                        Ω
                        
                           (
                           
                              
                                 r
                              
                              
                                 2
                              
                           
                           )
                        
                      convex pieces, so an input with 
                        n
                      edges can entail a union of 
                        Ω
                        
                           (
                           
                              
                                 n
                              
                              
                                 4
                              
                           
                           )
                        
                      component Minkowski sums. Hachenberger  [5] provides an exact implementation of this algorithm. The program is very slow  [6,7,2]. Varadhan and Manocha  [8] reduce the constant factor by computing the union approximately yet with the correct topology, using a volumetric grid. They observe that the approach remains slow.

The second approach computes a set of facets, called a convolution, that is a superset of the boundary of 
                        A
                        ⊕
                        B
                     . A facet 
                        f
                      of the arrangement of these facets bounds 
                        A
                        ⊕
                        B
                      if 
                        −
                        A
                        +
                        t
                        ∩
                        B
                        ≠
                        0̸
                      and 
                        −
                        A
                        +
                        
                           
                              t
                           
                           
                              ′
                           
                        
                        ∩
                        B
                        =
                        0̸
                      for arbitrary 
                        t
                        ∈
                        c
                      and 
                        
                           
                              t
                           
                           
                              ′
                           
                        
                        ∈
                        
                           
                              c
                           
                           
                              ′
                           
                        
                      in the (open 3D) cells 
                        c
                      and 
                        
                           
                              c
                           
                           
                              ′
                           
                        
                      on either side of 
                        f
                     .

The kinetic convolution  [9,10] is defined using an assignment of a set of outward normals to each boundary point of a polyhedron. A facet is assigned its normal 
                        n
                     . An edge with incident facet normals 
                        
                           
                              n
                           
                           
                              1
                           
                        
                      and 
                        
                           
                              n
                           
                           
                              2
                           
                        
                      is assigned the arc 
                        
                           
                              n
                           
                           
                              1
                           
                        
                        
                           
                              n
                           
                           
                              2
                           
                        
                      on the Gauss sphere. A vertex is assigned the interior of the spherical polygon defined by the arcs of the incident edges. Features from 
                        A
                      and 
                        B
                      are compatible if they have a common normal. The kinetic convolution is the set of Minkowski sums of compatible pairs. The 2D version of the convolution has a winding number property that determines if cell 
                        c
                        ∈
                        A
                        ⊕
                        B
                     . This property does not hold for general polyhedra  [10].

We illustrate these concepts with 
                        A
                      a sphere and with 
                        B
                      a hollow box that contains a solid tetrahedron (Fig. 2
                     ). The cells that comprise the Minkowski sum are drawn in yellow. The sphere overlaps the box in the outer cell and overlaps the tetrahedron in the inner cell.

Lien  [11] provides a non-robust implementation of a kinetic convolution algorithm. He computes the 2D arrangement of each facet of the convolution defined by the other facets, groups the faces of these arrangements into polygonal surfaces, and uses intersection tests to identify those surfaces that bound the Minkowski sum. There is no error bound. The output facets can intersect, whereas the Minkowski sum is a simple polyhedron, so applications that rely on this property may fail.

Fogel and Halperin  [4] compute the Minkowski sum of two convex polyhedra. The kinetic convolution forms a single surface that bounds the Minkowski sum, so there is no need to compute an arrangement. Barki, Denis, and Dupont  [7] compute the Minkowski sum of a general polyhedron and a convex polyhedron. They compute a subset of the kinetic convolution that works for this special case. The rest of the algorithm is similar to Lien’s  [11]. Both Fogel and Halperin and Barki et al. provide exact implementations.

Campen and Kobbelt  [6] use the kinetic convolution to compute the outer boundary of the Minkowski sum. The algorithm has limited applicability because inner boundaries are common, e.g. for polyhedra with inner cavities, in part layout, and in mechanical design. They provide an exact implementation via a prior technique  [12] that requires them to use planes as geometric primitives and to define vertices as intersection points of three planes. The vertex accuracy is 
                        1
                        
                           
                              0
                           
                           
                              −
                              5
                           
                        
                      even though the plane accuracy is 
                        1
                        
                           
                              0
                           
                           
                              −
                              16
                           
                        
                      (IEEE double). Converting the Minkowski sum to a boundary representation can cause facets to intersect.

Kaul and Rossignac  [1] define a subset of the kinetic convolution, which we call the convex convolution, that is still a superset of the boundary of 
                        A
                        ⊕
                        B
                     . The set of normals at a boundary point 
                        p
                        ∈
                        A
                      is replaced by the subset corresponding to the convex closure of 
                        A
                      in a neighborhood of 
                        p
                     . No normals are assigned to concave edges and fewer normals (possibly none) are assigned to vertices with concave incident edges. In Fig. 2, the convex convolution has fewer facets than does the kinetic convolution yet is still a subset of the Minkowski sum boundary.

We  [2] developed a robust implementation of a convex convolution algorithm. The data structures are incompatible with distributed computation. The memory footprint is larger than the output size. The robustness technique requires custom logic for every type of degenerate input, and its error is not bounded.

Li and McMains  [13] approximate the outer boundary of the Minkowski sum using the convex convolution, voxelization, and the GPU. The accuracy is limited by the volumetric resolution: the reported results have a resolution of 10243, which yields a 
                        1
                        
                           
                              0
                           
                           
                              −
                              3
                           
                        
                      error. Increasing the resolution incurs a cubic running time penalty and is limited by the GPU memory size.


                     Fig. 3
                      summarizes our Minkowski sum algorithm. The inputs are polyhedra with triangular facets with outward oriented normals. Step 1 constructs the convex convolution. Step 2 intersects its facets. Step 3 computes the arrangements defined by the intersection edges. Step 4 identifies the faces of the arrangements that comprise the Minkowski sum boundary. Step 5 triangulates the boundary facets via monotone decomposition.

Although our algorithm has the same structure as our prior algorithm  [2], we employ novel techniques that reduce memory usage and that enable distributed computation. We describe the algorithm briefly and discuss the innovations in detail. We can assume that the inputs are in general position because of our robustness technique (Section  4). This assumption simplifies the algorithm and the presentation.

Step 1 of the algorithm constructs the convex convolution of 
                           A
                         and 
                           B
                        . Its facets are triangles and parallelograms because the facets of 
                           A
                         and 
                           B
                         are triangles. We identify the pairs of features with shared normals using a binary spatial partition of the Gauss sphere  [14]. Although the kinetic convolution can be computed in an output sensitive manner  [10], we do not attempt output sensitive computation of the convex convolution because the running time of our algorithm is negligible.

Step 2 of the algorithm constructs the intersection edges of the convolution, which we call FF-edges. One endpoint of each FF-edge is the intersection point of a convolution edge and a facet, which we call an EF-vertex. The other endpoint is also an EF-vertex or is a convolution vertex. In Fig. 4
                        , facet 
                           s
                           =
                           
                              
                                 v
                              
                              
                                 1
                              
                           
                           
                              
                                 v
                              
                              
                                 2
                              
                           
                           
                              
                                 v
                              
                              
                                 3
                              
                           
                           
                              
                                 v
                              
                              
                                 4
                              
                           
                         intersects facets 
                           
                              {
                              r
                              ,
                              u
                              ,
                              v
                              ,
                              w
                              }
                           
                         and forms EF-vertices 
                           
                              {
                              
                                 
                                    v
                                 
                                 
                                    5
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    6
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    7
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    8
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    9
                                 
                              
                              }
                           
                         and FF-edges 
                           
                              {
                              
                                 
                                    v
                                 
                                 
                                    4
                                 
                              
                              
                                 
                                    v
                                 
                                 
                                    5
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    5
                                 
                              
                              
                                 
                                    v
                                 
                                 
                                    6
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    6
                                 
                              
                              
                                 
                                    v
                                 
                                 
                                    7
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    8
                                 
                              
                              
                                 
                                    v
                                 
                                 
                                    9
                                 
                              
                              }
                           
                        .

Testing a pair of facets for intersection and if so constructing their FF-edge are constant-time operations. The key to an efficient algorithm is to test as few non-intersecting pairs as possible. Since an output sensitive algorithm is not available, we construct a kd-tree for the facets and test the pairs that share a leaf. The drawback of kd-trees is that two facets can share multiple leafs if some splitting planes intersect them both. Prior work uses hash tables to detect duplicate pairs, but constructing hash tables on the GPU requires a large amount of temporary storage because the required space is proportional to the number of lookups, not the number of entries  [15]. For example, our helix+helix example generates 72 M facet pairs which would occupy about 1 GB temporary storage. We have developed a novel type of kd-tree that solves this problem.

Each facet 
                           p
                         is labeled with a bit vector 
                           l
                           
                              (
                              p
                              )
                           
                           =
                           0
                        . We construct a kd-tree for the labeled facets. If the splitting plane at depth 
                           d
                         intersects 
                           p
                        , 
                           p
                         is assigned to the left subtree and the right subtree is assigned a copy of 
                           p
                         the 
                           d
                        th bit of whose label is set to one. If not, 
                           p
                         is assigned to one subtree. A leaf is generated if a maximum depth or a minimum number of facets is reached. Fig. 5
                         shows an example in which facets 
                           p
                         and 
                           q
                         are inserted into a kd-tree with root 
                           
                              
                                 n
                              
                              
                                 0
                              
                           
                        , depth-1 nodes 
                           
                              
                                 n
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                        , and leafs 
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 n
                              
                              
                                 6
                              
                           
                        . When 
                           p
                         is split at 
                           d
                           =
                           1
                         by the dashed vertical line, it is assigned to 
                           
                              
                                 n
                              
                              
                                 5
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 6
                              
                           
                         with labels 10 and 11. In a leaf, facets 
                           p
                         and 
                           q
                         are tested for intersection if 
                           l
                           
                              (
                              p
                              )
                           
                           ∧
                           l
                           
                              (
                              q
                              )
                           
                           =
                           0
                         (the bit-wise conjunction). In our example, 
                           p
                         and 
                           q
                         appear in leafs 
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                        , 
                           
                              
                                 n
                              
                              
                                 5
                              
                           
                        , and 
                           
                              
                                 n
                              
                              
                                 6
                              
                           
                        , but are only tested in 
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                         because 
                           l
                           
                              (
                              p
                              )
                           
                           ∧
                           l
                           
                              (
                              q
                              )
                           
                         is 10 in 
                           
                              
                                 n
                              
                              
                                 5
                              
                           
                         and is 11 in 
                           
                              
                                 n
                              
                              
                                 6
                              
                           
                        .

No pair is tested twice because 
                           l
                           
                              (
                              p
                              )
                           
                           ∧
                           l
                           
                              (
                              q
                              )
                           
                         can equal zero only in the leftmost leaf that contains 
                           p
                         and 
                           q
                        . Any other leaf that contains 
                           p
                         and 
                           q
                         has a common ancestor with the leftmost leaf at some depth 
                           d
                        . The 
                           d
                        th bits of 
                           l
                           
                              (
                              p
                              )
                           
                         and 
                           l
                           
                              (
                              q
                              )
                           
                         equal one in the other leaf because 
                           p
                         and 
                           q
                         were assigned to both subtrees at depth 
                           d
                         and the other leaf is in the right subtree.

Every intersecting pair is tested because 
                           l
                           
                              (
                              p
                              )
                           
                           ∧
                           l
                           
                              (
                              q
                              )
                           
                           =
                           0
                         in their leftmost leaf. If not, the leftmost leaf would be in the right subtree of some ancestor and 
                           p
                         and 
                           q
                         would be assigned to both of its subtrees. Since 
                           p
                         and 
                           q
                         intersect, no splitting plane separates them, so they would share a leaf in the left subtree. This leaf would be to the left of the leftmost leaf.

Step 3 of the algorithm computes the arrangement of each facet defined by its FF-edges. The arrangement consists of faces bounded by polygonal loops. We split the edges of the facet at their EF-vertices and split its FF-edges at their intersection points, which we call FFF-vertices. We form the loops by traversing the sub-edges. We compute their nesting order, which defines the faces, via ray casting in the plane of the facet. In Fig. 4(b), FF-edges 
                           
                              
                                 v
                              
                              
                                 6
                              
                           
                           
                              
                                 v
                              
                              
                                 7
                              
                           
                         and 
                           
                              
                                 v
                              
                              
                                 8
                              
                           
                           
                              
                                 v
                              
                              
                                 9
                              
                           
                         intersect at FFF-vertex 
                           
                              
                                 v
                              
                              
                                 10
                              
                           
                         and the faces are numbered 1–4.

Step 4 of the algorithm identifies the faces of the facet arrangements that bound the Minkowski sum. Only some faces are candidates. Of the four faces that share a sub-edge of an FF-edge, the two faces on the outward normal sides of both facets are candidates. If two or more faces share a sub-edge of a convolution edge, two of them are candidates based on a geometric test  [1]. The candidates define polyhedral surfaces. A surface contributes to the Minkowski sum boundary if it is closed and 
                           −
                           A
                           +
                           t
                         does not overlap 
                           B
                         for an arbitrary vertex 
                           t
                           =
                           b
                           −
                           a
                         of the surface, except that 
                           a
                         touches 
                           b
                        .

The CPU program assigns the candidate faces to surfaces by breadth-first traversal of the face adjacency graph. This algorithm is suboptimal for the GPU because the running time is proportional to the graph diameter independently of the number of processors. Instead, we compute the surfaces in parallel with the union-find algorithm whose time complexity is nearly proportional to 
                           e
                           /
                           p
                         for 
                           e
                         edges and 
                           p
                         processors. Each face is initialized to a singleton set. In each cycle, each face is assigned a process that merges its set with those of its graph neighbors.

A cell is an outer or inner boundary if by itself it represents a bounded or unbounded polyhedron. To classify a cell, take the vertex with maximum 
                           z
                         and its outgoing edge with smallest obtuse angle with the 
                           z
                        -axis. Because neighboring edges have larger angle, the two incident faces slope downward from this edge. If the edge is convex, the exterior is above the edge and unbounded, and the cell is outer. If the edge is reflex, the interior is above the edge and unbounded, and the cell is inner. We assign an inner boundary to its cell by intersecting a ray through one of its vertices with the outer boundaries and selecting the closest one that is intersected an odd number of times.

The Minkowski sum boundary is typically a small subset of the arrangement of the convolution. The rest of the arrangement, called the blocked portion, is in the Minkowski sum interior. Storing the blocked portion makes the memory footprint of the program far exceed the output size, which inhibits distributed computation. We discard most blocked vertices and never compute most blocked sub-edges and faces.

The facets of the convolution are oriented so that the polyhedra 
                           −
                           A
                           +
                           t
                         and 
                           B
                         intersect for 
                           t
                         in a neighborhood of a facet on the negative side of its normal. Since this neighborhood is blocked, we can discard the part of the convolution that it contains without losing any part of the Minkowski sum boundary.

We use three tests for being blocked. (1) Let 
                           e
                           =
                           
                              
                                 v
                              
                              
                                 0
                              
                           
                           
                              
                                 v
                              
                              
                                 k
                              
                           
                         have tangent 
                           u
                           =
                           
                              
                                 v
                              
                              
                                 k
                              
                           
                           −
                           
                              
                                 v
                              
                              
                                 0
                              
                           
                         and contain vertices 
                           
                              
                                 v
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 v
                              
                              
                                 k
                                 −
                                 1
                              
                           
                         sorted along 
                           e
                         (Fig. 6
                        ). The contained 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         are EF-vertices for a convolution edge and are FFF-vertices for an FF-edge. Each 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         is the intersection point of 
                           e
                         with a facet 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                         with normal 
                           
                              
                                 n
                              
                              
                                 i
                              
                           
                        . If 
                           
                              
                                 n
                              
                              
                                 i
                              
                           
                           ⋅
                           u
                           >
                           0
                        , the intersection of 
                           
                              
                                 v
                              
                              
                                 0
                              
                           
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         with a neighborhood of 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         is in the interior of 
                           A
                           ⊕
                           B
                         due to 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        , so the sub-edge 
                           
                              
                                 v
                              
                              
                                 i
                                 −
                                 1
                              
                           
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         is blocked. Likewise, 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           
                              
                                 v
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         is blocked if 
                           
                              
                                 n
                              
                              
                                 i
                              
                           
                           ⋅
                           u
                           <
                           0
                        . The only non-blocked sub-edge in our example is 
                           
                              
                                 v
                              
                              
                                 2
                              
                           
                           
                              
                                 v
                              
                              
                                 3
                              
                           
                        . (2) If both incident sub-edges of 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         are blocked, 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         is blocked. (3) If 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         is a blocked EF-vertex, the sub-edge 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           
                              
                                 v
                              
                              
                                 f
                              
                           
                         of the incident FF-edge 
                           f
                         is blocked.

We reduce the memory footprint by dividing the facets into groups prior to edge intersection and merging the groups after discarding blocked vertices. We form groups of approximately equal size by constructing a kd-tree for the facet centroids. The facets whose centroids share a leaf are the primary members of a group. We ensure that a group contains all the facets that intersect its primary members by including the facets that intersect the bounding box of its primary members. For each group, we construct FF-edges for the primary members that intersect other members, construct FFF-vertices for the intersecting pairs of FF-edges, and discard the blocked vertices. After merging the group data, we form the sub-edges and the faces.

The goal of robustness is to implement an algorithm in a manner that guarantees an accurate output for every input. The output of a computational geometry program can have combinatorial and geometric components. In our case, these are the combinatorial structure of the Minkowski sum and the coordinates of its vertices. One error metric, called the forward error, is the distance between the output and the exact answer. Euclidean distance is a fine metric for geometric error, but we are unaware of a useful metric for combinatorial error. Moreover, the forward error conflates the quality of the algorithm, which is what we wish to measure, with the condition of the problem, which is beyond our control. Consequently, numerical analysis eschews forward error in favor of backward error: the minimum distance from the input to an alternative input for which the output is the exact answer. The backward error models computational error identically to measurement error in the input. It models combinatorial and geometric error in the same manner.

One robustness strategy  [16], called exact computational geometry (ECG), is to compute combinatorial structure exactly. Since the control logic is expressed in terms of predicates, polynomials whose signs are interpreted as truth values, it suffices to evaluate predicates exactly. Exact evaluation is accelerated by first attempting to resolve the sign with error-bounded floating point arithmetic. This approach works poorly for degenerate predicates, that is predicates whose value is zero. The first problem is that exact evaluation of degenerate predicates is slow because floating point evaluation necessarily fails. The impact on overall running time is large because degenerate predicates are common in real-world inputs, due to symmetry, to design constraints, and to convention. The second problem is that degeneracy creates a third branch at every point in the control logic. These branches are typically ignored in theoretical analysis because they contribute nothing fundamental to the algorithm. Yet they must be handled by a robust implementation.

A second robustness strategy  [17], called controlled perturbation (CP), eliminates degenerate predicates by adding a random perturbation in 
                        
                           [
                           −
                           δ
                           ,
                           δ
                           ]
                        
                      to each input parameter. The algorithm is executed with error-bounded floating point predicate evaluation. If all the predicates are resolved, the output is returned; otherwise, the algorithm is rerun. Since every predicate is correct in the final run, the combinatorial structure is correct and the backward error is bounded by the final 
                        δ
                     . CP avoids the slowness of ECG because most predicates are resolved after even a tiny input perturbation. Whereas ECG forces the program to handle degenerate predicates, CP allows the program to ignore them, since they cannot occur in the final run.

The problem with CP is that a large 
                        δ
                      is required to resolve a singular predicate (zero value and zero gradient), in particular 
                        1
                        
                           
                              0
                           
                           
                              −
                              5
                           
                        
                      for Minkowski sums of polyhedra  [2]. We  [3] solve this problem with a variant of CP, called adaptive controlled perturbation (ACP), in which 
                        δ
                      is user-specified and predicates are evaluated exactly on the perturbed input. We evaluate predicates in floating point interval arithmetic. If the interval does not contain zero, the sign is resolved. Otherwise, we re-evaluate in extended precision interval arithmetic, starting with quad-double and doubling the precision until the sign is resolved or until a maximum precision 
                        p
                      is exceeded. Exceeding 
                        p
                      indicates that the predicate is degenerate or nearly degenerate for the perturbed input. We change the random seed and double 
                        p
                      to handle both cases, and restart the algorithm.

The CPU implementation of the ACP strategy is straightforward. The coordinates of the vertices of 
                        A
                      and 
                        B
                      are the input parameters, hence are perturbed. The coordinates of the other vertices are defined parameters. These vertices store their coordinates as floating point intervals and also store pointers to their defining vertices. A convolution vertex points to its 
                        A
                      and 
                        B
                      vertices. An EF-vertex points to its convolution edge and facet. An FFF-vertex points to its three facets. ACP uses these pointers to increase the precision of a vertex by recursively increasing the precision of its defining vertices then recomputing the intervals of its coordinates. Precision is increased solely when a predicate cannot be resolved in floating point and is decreased immediately to avoid storage of extended precision data. The GPU version of ACP is described in the Appendix.

@&#RESULTS@&#

We tested our programs on nine polyhedra with 30 to 37,000 triangular facets (Fig. 7
                     ). We computed the Minkowski sums of all 45 pairs of polyhedra. The 9 duplicated pairs have many nearly degenerate predicates after the input perturbation because the convolution facets of the unperturbed pairs are duplicated. The other 36 pairs have few nearly degenerate predicates. Fig. 8
                      shows ten of the Minkowski sums.

We scaled the input to the unit box. We set 
                        δ
                        =
                        1
                        
                           
                              0
                           
                           
                              −
                              8
                           
                        
                      because this backward error is negligible in applications, yet is large enough that floating point interval arithmetic resolves almost all the predicates. We initialized 
                        p
                      to 848 bit precision. We never encountered a restart.


                     Table 1
                      summarizes the results. The complexity of a polyhedron or a convolution is its total number of vertices, edges, and facets. For an arrangement or a Minkowski sum, the complexity also includes the number of cell boundaries and cells. The CPU tests are on one core of an Intel Core 2 Duo. The GPU tests are on a 3.5 GHz i7 CPU and a GeForce Titan graphics card with 2688 CUDA cores and 6 GB onboard memory.

The complexity of the convolution is linear in the sum of the complexities of the polyhedra, as 
                        c
                        /
                        
                           (
                           a
                           +
                           b
                           )
                        
                      is between 1 and 143 with a median value of 7. The arrangements have the same complexity as the convolution, as 
                        s
                        /
                        c
                      is between 1 and 6 with a median value of 2. Discarding blocked elements sharply reduces the complexity of the arrangements: the median reduction is 74% overall and is 93% for the six largest Minkowski sums. There is little room for further reducing the arrangements, as 
                        m
                        /
                        c
                      is between 1 and 15 with a median value of 3.

We estimated the benefit of the convex convolution by computing the kinetic convolution for 40 pairs. The kinetic convolution is 7–32 times larger, so the convex convolution saves us at least this factor in running time and in memory footprint. We expect a similar ratio on the 5 largest pairs, but our 
                        
                           
                              n
                           
                           
                              2
                           
                        
                      kinetic convolution algorithm is too slow to compute them.

The GPU program exhibits a median speedup of 36 relative to the CPU program. The median speedup increases to 68 on the six pairs with the largest Minkowski sums. The running times and memory footprints of these pairs are one to two orders of magnitude larger than those of the other 39 pairs.


                     Table 2
                      shows the memory usage and running time for the six largest Minkowski sums with 2, 4, and 8 data groups. A blank entry indicates that the memory footprint exceeds the GPU memory size. The memory savings is sublinear because of the non-primary members, which comprise 10%–20% of each group. Also, some blocked elements cannot be detected until the groups are merged because the relevant tests cross group boundaries. We could reduce the memory footprint by discarding blocked elements after each group is merged into the step 4 input. The running time increases with the number of groups because FF-edges and FFF-vertices involving non-primary members of groups are computed redundantly. We could remove the redundancy by caching the data in a hash map.

We compare our CPU program to the published running times for prior programs adjusted for processor speed, except that we timed Hachenberger’s  [5] exact convex decomposition  [2]. Hachenberger’s program took 2000–4000 times longer than our program on small tests, 10,000–100,000 times longer on medium tests, and aborted or did not terminate after several hours on the other tests. Our program is 30 times faster than Varadhan and Manocha’s  [8] approximate convex decomposition on their hardest test, grate1/grate2.

Our program is several times faster than Lien’s  [11] non-robust convolution algorithm. His running times on his two largest examples, knot/bull and knot/inner ear, are 755 s and 921 s, versus 174 s and 130 s for our program. He does not test duplicated pairs, which are the most challenging cases. Our program is over 100 times faster than Barki et al.’s  [7] exact Minkowski sums of a convex polyhedron and a general polyhedron. For example, their running times for knot/sphere and grate2/sphere are 172 s and 280 s, versus 1 s for our program. We accurately compute the full Minkowski sum 6 times faster than Campen and Kobbelt  [6] compute the outer boundary with low precision. Their web server
                           1
                        
                        
                           1
                           
                              http://www.graphics.rwth-aachen.de/webbsp/.
                         returns a “memory or time exceeded” message on our six largest examples and on some others. Finally, our program is twice as fast as our prior program  [2].

Our GPU program computes 
                           1
                           ⊕
                           6
                         and 
                           1
                           ⊕
                           7
                         10 times faster than Li and McMains’s GPU program  [13], after adjusting for GPU speed. Our error is 
                           1
                           
                              
                                 0
                              
                              
                                 −
                                 8
                              
                           
                         and is under our control, while theirs is 
                           1
                           
                              
                                 0
                              
                              
                                 −
                                 3
                              
                           
                         and is governed by the GPU memory capacity.

@&#DISCUSSION@&#

We have presented a convolution algorithm for Minkowski sums of polyhedra with robust CPU and GPU implementations. The algorithm contains several innovations that support distributed computation. The computational bottleneck is finding the intersecting pairs of facets. We enabled a distributed algorithm by creating a novel type of kd-tree that eliminates duplicate entries without using global memory. The memory bottleneck is the arrangements of the facets of the convolution. We removed this bottleneck by processing the facets in groups and by removing most of the blocked geometry. We solved the robustness problem, which is the primary implementation challenge for computational geometry algorithms, using our ACP strategy. We conclude with plans for future work.

One research direction is to develop a multi-core CPU implementation. The obvious approach is to assign a core to each group in steps 2 and 3, which dominate the running time, but this approach is memory bound for four or more cores. A second research direction is to distribute steps 2 and 3 over multiple GPU’s. We can easily assign the groups from our current algorithm to multiple GPU’s, but we need to control the cost of data communication.

A third challenge is to compute the swept volume of a polyhedron over a spatial path. The swept volume can be approximated by constructing facets, computing their arrangements, and extracting cell boundaries  [6]. The inputs are large because many facets are required for accurate approximation. The algorithms and GPU programs that we developed for Minkowski sums should solve these problems.

@&#ACKNOWLEDGMENTS@&#

Kyung is supported by the Basic Science Research Program through the National Research Foundation of Korea funded by the Ministry of Science, ICT and Future Planning (NRF-2013R1A1A2011733). Sacks is supported by NSF grant CCF-0904832. Milenkovic is supported by NSF grant CCF-0904707.

We describe the GPU implementation at the requisite level of detail for an experienced GPU programmer to reproduce it. The pseudo-code of the main algorithm is in Fig. A.9
                     .


                     Data structures. A vertex has single float coordinates and is represented by an index into an array 
                        V
                     . An edge consists of tail and head vertices, an incident facet, and emin and ccw values (explained below), and is represented by an index into arrays 
                        
                           
                              E
                           
                           
                              i
                           
                        
                     . A facet consists of vertices, edges, and an outward normal, and is represented by an index into arrays 
                        
                           
                              F
                           
                           
                              i
                           
                        
                     . The data structures are initialized with the polyhedra 
                        A
                      and 
                        B
                     .


                     Convolution. We use one thread per vertex of 
                        A
                      to find the facets of 
                        B
                      with which it forms convolution facets, and vice versa. We use one thread per convex edge of 
                        A
                      to find the convex edges of 
                        B
                      with which it forms facets. We store the feature pairs contiguously in an array FP using atomic operations for synchronization. Since these operations are slow, we form groups of 
                        m
                        =
                        256
                      threads, store the output of each group in local shared memory, and flush the output to FP using an atomic operation to find the start index. We use one thread per FP entry to create an array VV of the pairs of indices 
                        
                           (
                           a
                           ,
                           b
                           )
                        
                      of the vertices 
                        
                           
                              V
                           
                           
                              a
                           
                        
                        ⊕
                        
                           
                              V
                           
                           
                              b
                           
                        
                      of the facets. We sort VV lexicographically, remove the duplicates, and add vertices to 
                        V
                      for the remaining pairs. We use one thread per FP entry.

We create an array with an entry 
                        
                           (
                           e
                           ,
                           a
                           ,
                           b
                           )
                        
                      for every convolution edge 
                        e
                      with 
                        a
                      and 
                        b
                      the smaller and larger of its vertex indices. We sort the array lexicographically by 
                        
                           (
                           a
                           ,
                           b
                           )
                        
                     . Each segment with identical 
                        
                           (
                           a
                           ,
                           b
                           )
                        
                      entries defines a set of equivalent edges in distinct facets. We set the emin fields of the edges to the minimum edge index of the set. We sort the edges in counterclockwise order around 
                        b
                        −
                        a
                      and set the ccw field of each edge to the index of its successor in this order if the edge is from 
                        a
                      to 
                        b
                     , and to the index of its predecessor otherwise.


                     Groups. When the set of facets is too large to be processed on the GPU, it is divided into groups, the groups are processed, and the results are merged after removing blocked entities. We place the indices of the facets in an array 
                        P
                     , compute their centroids, and place their coordinates in arrays 
                        
                           
                              C
                           
                           
                              0
                           
                        
                     , 
                        
                           
                              C
                           
                           
                              1
                           
                        
                     , and 
                        
                           
                              C
                           
                           
                              2
                           
                        
                     . We store the group ids in an array 
                        G
                     , all the entries of which initially are set to 0. Let 
                        C
                        =
                        
                           
                              C
                           
                           
                              0
                           
                        
                     . We sort the five arrays in increasing order of 
                        
                           (
                           G
                           ,
                           C
                           )
                        
                      and then compute the medians of the groups by scanning 
                        G
                      and 
                        C
                     . We split the current groups using thread 
                        i
                      to set 
                        G
                        
                           [
                           i
                           ]
                        
                        ←
                        2
                        G
                        
                           [
                           i
                           ]
                        
                      if 
                        C
                        
                           [
                           i
                           ]
                        
                      is less than the median of 
                        G
                        
                           [
                           i
                           ]
                        
                      and 
                        G
                        
                           [
                           i
                           ]
                        
                        ←
                        2
                        G
                        
                           [
                           i
                           ]
                        
                        +
                        1
                      otherwise. We repeat this, cycling 
                        C
                        =
                        
                           
                              C
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              C
                           
                           
                              2
                           
                        
                        ,
                        
                           
                              C
                           
                           
                              0
                           
                        
                        ,
                        .
                     . until we obtain the requested number of groups. We create arrays 
                        
                           
                              P
                           
                           
                              i
                           
                        
                      of the facet indices of the primary members of the groups by scanning 
                        P
                      and 
                        G
                     . We use one thread for each facet in 
                        
                           
                              P
                           
                           
                              i
                           
                        
                      to test if it intersects the bounding box of other group 
                        i
                     , and add it to 
                        
                           
                              P
                           
                           
                              i
                           
                        
                      if so. The pseudocode of this procedure is given in Fig. A.10
                     .

The next three paragraphs discuss FF-edge creation, FFF-vertex creation, and blocked geometry within a group. The following paragraph explains how the group data is merged.


                     FF-edges. We construct a kd-tree of facets with a prior GPU algorithm  [18], but we do not split facets that intersect cutting planes. Leaf node data are stored in an array of leaf facets LP, an array of leaf IDs LL, and an array of bit vectors LB. We generate a duplicate-free array PP of all 
                        P
                      pairs (see Fig. A.11
                     ). Let 
                        
                           
                              N
                           
                           
                              s
                              t
                           
                        
                      be an array containing the indices of start entries in LP for groups and 
                        
                           
                              N
                           
                           
                              n
                           
                        
                      be an array containing the leaf sizes. We assign 
                        
                           
                              1
                           
                           
                              2
                           
                        
                        
                           
                              N
                           
                           
                              n
                           
                        
                        
                           [
                           l
                           ]
                        
                        
                           (
                           
                              
                                 N
                              
                              
                                 n
                              
                           
                           
                              [
                              l
                              ]
                           
                           −
                           1
                           )
                        
                      threads for each leaf 
                        l
                      to enumerate pairs. Each thread 
                        i
                      maps its index 
                        i
                      to 
                        
                           (
                           a
                           ,
                           b
                           )
                        
                     , an entry of the upper triangular matrix of size 
                        
                           
                              N
                           
                           
                              n
                           
                        
                        
                           [
                           l
                           ]
                        
                     , which is then added by 
                        
                           
                              N
                           
                           
                              s
                              t
                           
                        
                        
                           [
                           l
                           ]
                        
                      to make indices of the input arrays. Then, we insert the facet pair 
                        
                           (
                           L
                           P
                           
                              [
                              a
                              ]
                           
                           ,
                           L
                           P
                           
                              [
                              b
                              ]
                           
                           )
                        
                      to PP, if 
                        
                           (
                           a
                           ,
                           b
                           )
                        
                      passes the bit vector test 
                        L
                        B
                        
                           [
                           a
                           ]
                        
                        ∧
                        L
                        B
                        
                           [
                           b
                           ]
                        
                        =
                        0
                      and the oriented bounding box test.

We use one thread per pair to generate an array of all 
                        
                           (
                           e
                           ,
                           p
                           )
                        
                      pairs with 
                        p
                      one facet of a PP pair and 
                        e
                      an edge of the other facet. We set 
                        e
                      to the emin of the edge. We sort the array, remove duplicate entries, and assign each entry 
                        
                           (
                           e
                           ,
                           p
                           )
                        
                      to a thread that checks if 
                        e
                      intersects 
                        p
                     . If so, an EF-vertex is created by adding 
                        
                           (
                           e
                           ,
                           p
                           )
                        
                      to an array 
                        
                           
                              
                                 EF
                              
                           
                           
                              g
                           
                        
                      and adding the intersection point to 
                        V
                     . For each pair in PP with two 
                        
                           
                              
                                 EF
                              
                           
                           
                              g
                           
                        
                      entries (or one entry and a shared vertex), a thread creates an FF-edge by adding the pair to an array 
                        
                           
                              
                                 FF
                              
                           
                           
                              g
                           
                        
                      and updating the 
                        
                           
                              E
                           
                           
                              i
                           
                        
                     . Fig. A.12
                      shows the procedure of computing facet pair intersection in pseudocode.


                     FFF-vertices
                  

We sort 
                        
                           
                              
                                 FF
                              
                           
                           
                              g
                           
                        
                      in lexicographic order of intersecting facets. For each array segment of length 
                        k
                      with the same first facet 
                        s
                     , we use 
                        
                           
                              1
                           
                           
                              2
                           
                        
                        k
                        
                           (
                           k
                           −
                           1
                           )
                        
                      threads to generate FF-edge pairs on the facet 
                        s
                      into EE. For each FF-edge pair, 
                        
                           (
                           
                              (
                              s
                              ,
                              a
                              )
                           
                           ,
                           
                              (
                              s
                              ,
                              b
                              )
                           
                           )
                        
                      in EE, a thread test intersection of the two FF-edges, and make a triple 
                        
                           (
                           s
                           ,
                           a
                           ,
                           b
                           )
                        
                      for 
                        a
                        <
                        b
                     , if they intersect. The triple is added to the array 
                        
                           
                              
                                 FFF
                              
                           
                           
                              g
                           
                        
                     , and its intersection point to 
                        V
                        V
                     . The pseudo code is in Fig. A.13
                     .


                     Blocked geometry. We form an array 
                        L
                      of pairs 
                        
                           (
                           e
                           ,
                           v
                           )
                        
                      with 
                        e
                      an edge and 
                        v
                      a vertex. An EF-vertex forms one pair with its convolution edge. An FFF-vertex forms three pairs with its three FF-edges. We use one thread per pair to compute the projection of 
                        v
                      along 
                        e
                     , 
                        d
                        =
                        v
                        ⋅
                        
                           (
                           h
                           −
                           t
                           )
                        
                      where 
                        t
                      and 
                        h
                      are the end points of 
                        e
                     . We sort 
                        L
                      in 
                        d
                      order. We use one thread per pair to compute an array 
                        S
                      of the signs of 
                        n
                        ⋅
                        
                           (
                           h
                           −
                           t
                           )
                        
                      where 
                        n
                      is the normal of the facet that 
                        e
                      intersects at 
                        v
                     .

We compute an array 
                        B
                      in which 
                        
                           
                              b
                           
                           
                              i
                           
                        
                        =
                        1
                      if 
                        
                           
                              v
                           
                           
                              i
                           
                        
                      is blocked. Initially, 
                        B
                        =
                        0
                     . One thread per 
                        L
                      pair sets 
                        
                           
                              b
                           
                           
                              i
                           
                        
                        =
                        1
                      if 
                        
                           
                              e
                           
                           
                              i
                           
                        
                        =
                        
                           
                              e
                           
                           
                              i
                              +
                              1
                           
                        
                      and 
                        
                           
                              s
                           
                           
                              i
                           
                        
                        =
                        
                           
                              s
                           
                           
                              i
                              +
                              1
                           
                        
                        =
                        1
                      or if 
                        
                           
                              e
                           
                           
                              i
                           
                        
                        =
                        
                           
                              e
                           
                           
                              i
                              −
                              1
                           
                        
                      and 
                        
                           
                              s
                           
                           
                              i
                           
                        
                        =
                        
                           
                              s
                           
                           
                              i
                              −
                              1
                           
                        
                        =
                        −
                        1
                     . Next, one thread per 
                        L
                      pair sets 
                        
                           
                              b
                           
                           
                              i
                           
                        
                        =
                        1
                      if 
                        
                           
                              e
                           
                           
                              i
                           
                        
                        =
                        
                           
                              e
                           
                           
                              i
                              +
                              1
                           
                        
                     , 
                        
                           
                              s
                           
                           
                              i
                           
                        
                        =
                        1
                     , and 
                        
                           
                              b
                           
                           
                              i
                              +
                              1
                           
                        
                        =
                        1
                      or if 
                        
                           
                              e
                           
                           
                              i
                           
                        
                        =
                        
                           
                              e
                           
                           
                              i
                              −
                              1
                           
                        
                     , 
                        
                           
                              s
                           
                           
                              i
                           
                        
                        =
                        −
                        1
                     , and 
                        
                           
                              b
                           
                           
                              i
                              −
                              1
                           
                        
                        =
                        1
                     . A blocked FFF-vertex is deleted. An FF-edge with no FFF-vertices on it is deleted if one of its vertices is blocked. A blocked EF-vertex is deleted unless it is incident to an FF-edge, as it may be needed to recompute a FFF-vertex, as explained in the ACP paragraph. Fig. A.14
                      shows the pseudocode of removing blocked vertices and edges.


                     Merging. Let 
                        
                           
                              
                                 FF
                              
                           
                           
                              g
                           
                        
                     , 
                        
                           
                              
                                 EF
                              
                           
                           
                              g
                           
                        
                     , and 
                        
                           
                              
                                 FFF
                              
                           
                           
                              g
                           
                        
                      be the output of group 
                        g
                     . We append each 
                        
                           
                              
                                 EF
                              
                           
                           
                              g
                           
                        
                      to the global EF and add its start index to the EF-vertex indices in 
                        
                           
                              
                                 FF
                              
                           
                           
                              g
                           
                        
                     . We append each 
                        
                           
                              
                                 FF
                              
                           
                           
                              g
                           
                        
                      to the global FF and add its start index to the FF-edge indices in 
                        
                           
                              
                                 FFF
                              
                           
                           
                              g
                           
                        
                     . We append each 
                        
                           
                              
                                 FFF
                              
                           
                           
                              g
                           
                        
                      to the global FFF. We sort FFF and remove duplicates, sort FF, remove duplicates, and update FFF. We sort EF, remove duplicates, and update FF. We update the indices with GPU prefix sum and sorting operations.


                     Sub-edges. We use one thread per vertex to create the sub-edges of the emin edges. For 
                        e
                        =
                        
                           
                              v
                           
                           
                              0
                           
                        
                        
                           
                              v
                           
                           
                              k
                           
                        
                      with remaining vertices 
                        
                           
                              v
                           
                           
                              1
                           
                        
                        ,
                        …
                        ,
                        
                           
                              v
                           
                           
                              k
                              −
                              1
                           
                        
                     , 
                        
                           
                              v
                           
                           
                              i
                           
                        
                        
                           
                              v
                           
                           
                              i
                              +
                              1
                           
                        
                      is a sub-edge if 
                        
                           
                              s
                           
                           
                              i
                           
                        
                        >
                        0
                      and 
                        
                           
                              s
                           
                           
                              i
                              +
                              1
                           
                        
                        <
                        0
                     . We use one thread per emin sub-edge to create equivalent sub-edges for the rest of its edge set, and to set the emin and ccw fields.

We set the next field of each sub-edge 
                        
                           
                              v
                           
                           
                              i
                           
                        
                        
                           
                              v
                           
                           
                              j
                           
                        
                      to the next sub-edge 
                        
                           
                              v
                           
                           
                              j
                           
                        
                        
                           
                              v
                           
                           
                              k
                           
                        
                      in counterclockwise order around the normal of the facet of 
                        
                           
                              v
                           
                           
                              i
                           
                        
                        
                           
                              v
                           
                           
                              j
                           
                        
                     . If this sub-edge is blocked (so it was not created), next is set to null. We form an array 
                        T
                      of triples 
                        
                           (
                           p
                           ,
                           f
                           ,
                           e
                           )
                        
                      for every sub-edge 
                        e
                        =
                        t
                        h
                      incident to facet 
                        f
                      and for 
                        p
                        =
                        t
                        ,
                        h
                     . We sort 
                        T
                      by 
                        
                           (
                           p
                           ,
                           f
                           )
                        
                     , which segments it into groups consisting of the sub-edges of a face that are incident to a vertex. We use one thread per group to set the next fields. The computation depends on whether 
                        p
                      is a vertex of 
                        f
                     , a boundary EF-vertex, an interior EF-vertex, or an FFF-vertex (Fig. 4(b)). The groups for each of these four cases need to be adjacent in 
                        T
                      to prevent execution flow divergence among adjacent threads. We negate 
                        f
                      if 
                        p
                      is an EF-vertex on its boundary. Sorting 
                        T
                      places these vertices first, the facet vertices next, the interior EF-vertices next, and the FFF-vertices last.


                     Faces. We use a thread to generate the sub-edge loop of a given sub-edge by following next fields until it returns to that sub-edge or encounters a null next field. In the first case, the loop id of every sub-edge in the loop is set to its smallest sub-edge index and this id is recorded in an array 
                        H
                     . Using one thread per sub-edge would generate every loop once for each of its sub-edges. We reduce the redundancy by repeatedly running one thread for every fifth sub-edge whose loop id is null until none is found. In practice, the first iteration finds most of the loops. Even if multiple threads traces the same loop, synchronization is unnecessary, because they set the same loop id for the edges in the loop.

We sort 
                        H
                     , remove duplicates, and use one thread per loop id to classify the loops as outer or inner boundaries. For 
                        
                           
                              v
                           
                           
                              j
                           
                        
                      the vertex with the largest 
                        z
                      component, a loop is an outer boundary if the sub-edges 
                        
                           
                              v
                           
                           
                              i
                           
                        
                        
                           
                              v
                           
                           
                              j
                           
                        
                      and 
                        
                           
                              v
                           
                           
                              j
                           
                        
                        
                           
                              v
                           
                           
                              k
                           
                        
                      form a convex angle. We generate a face for each outer boundary. We assign each inner boundary to its face by intersecting a ray through one of its vertices with the outer boundaries and selecting the closest one. We choose a pair of two vertices, each from inner- and outer-boundaries not obscured by any edges, and create new edges connecting them to make a single boundary of the face.


                     Cell boundaries. We implement the union-find algorithm for generating the cell boundaries using arrays 
                        P
                      and 
                        M
                      with one entry per face including unsubdivided facets (see Fig. A.15
                     ). The 
                        P
                      entry of a face is its parent face in the tree that represents its set. The 
                        M
                      entry is true if this set might be a closed surface. Initially, every 
                        P
                        
                           [
                           i
                           ]
                        
                      is set to 
                        i
                      so that every face is in a singleton set, and 
                        M
                      is true. We use one thread per face to merge its set with the sets of the adjacent faces along its edges. The adjacent face along an edge 
                        e
                      is the incident face of e.ccw. If no face is adjacent along an edge, the 
                        M
                      entry of the root of the 
                        f
                      set is set to false. Merging is done in the standard manner and the 
                        M
                      entry of the union is set to the conjunction of the 
                        M
                      entries of the merged sets. We iterate this process until every pair of adjacent faces is in the same set. A synchronization error can occur if two threads try to set the same entry, but it is corrected by the next iteration. To lower the chance of synchronization errors, we merge the set with a larger root id to the other set with a smaller root id. In practice, the first iteration finds all the boundaries with no errors.


                     Minkowski sum. As described in step 4 of Section  3, we classify the boundaries as outer and inner, form cells, assign inner boundaries to cells, and identify the free cells using our GPU version of a prior collision detection algorithm  [19].


                     ACP. In the CPU version of ACP, a predicate throws an exception if it is ambiguous at the current precision. A controller catches the exception, increases the precision, and retries the predicate. This approach is impractical on the GPU. Moreover, the ACP library uses an initial precision of double float, whereas single float is much faster on the GPU. The GPU version of ACP evaluates a predicate on a sequence of arguments, using stages instead of exceptions to increase precision. Stage 1 evaluates in single float, records the signs for the unambiguous elements in the sequence, and forms a second sequence from the ambiguous elements. Stage 2 increases the precision of the second sequence to double float and reevaluates the predicate in double float. Stage 3 evaluates the third sequence in quad-double  [20]. In the extremely rare cases where ambiguous predicates remain, the GPU passes them to the CPU for evaluation using MPFR  [21].

@&#REFERENCES@&#

