@&#MAIN-TITLE@&#A geometric reasoning approach to hierarchical representation for B-rep model retrieval

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Hierarchy of B-rep model is generated by geometric reasoning automatically.


                        
                        
                           
                           This shape descriptor eases global and partial retrieval at level of detail.


                        
                        
                           
                           Interactive prototype system gives why and how similar features are matched.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Geometric reasoning

Hierarchical representation

Solid model retrieval

@&#ABSTRACT@&#


                  3D solid model similarity is dependency of many intelligent design applications, such as design reuse, part management, case-based reasoning, and cost estimation. Matching and comparing its intrinsic boundary representation (B-rep) is a critical issue to retrieval. In this paper, we proposed a geometric reasoning approach to generate hierarchy for B-rep model retrieval. We extracted the winged-edge data structure to support series algorithms for underlying geometric reasoning, which is mainly composed of 3 steps to build hierarchy: partitioning, assembling and simplifying. This hierarchical representation is featured with level of detail 
                        
                           (
                           L
                           O
                           D
                           )
                        
                      retaining geometric and topological information which is proved to be efficient in both global and partial retrieval. Our approach is based on the standard for the exchange of product information 
                        
                           (
                           S
                           T
                           E
                           P
                           )
                        
                     , which is suitable for data exchange between heterogeneous CAD systems. The result of case studies from prototype implementation demonstrates its effectiveness and efficiency.
               

@&#BACKGROUND@&#

3D solid models are extensively used in Computer Aided Design and there is notably increasing requirements of their retrieval. Designers benefit from design reuse, in which they copy–paste an ideal source model or partial of it instead of re-designing from scratch. Finding the ideal model with specific feature distribution from design repositories, however, costs time and energy. Industrial companies implement Product Data Management (PDM) systems to reduce duplication, but how to identify two same models by different names is still challenging. Case-Based Reasoning (CBR) is another important application, which is regarded as the learning technique from past experience to benefit future design. It is formalized as 
                           4
                           R
                           s
                         in terms of Retrieval, Reuse, Revise and Retain  [1]. The cost of manufacturing parts is usually related with their form features of Digital Mock Ups (DMU), which makes cost estimation available. For example, machining parts of similarity may share similar path planing. With all these applications depending on content similarity of solid models, retrieving their internal representation is thus to be emerging.

Early studies treat the solid model as a polygon soap to implement algorithms of general shape retrieval, such as View based  [2,3], Reeb Graph based  [4,5], Shape distribution based  [6,7] and Skeleton based  [8,9] methods, to name but a few. Detailed review can be found in  [10,11]. The general shape approach is ineffective to be directly used in solid model retrieval  [12]. Unlike triangle meshes, most engineering parts are composed of simple regular faces (plane, cylindrical faces, etc.) yet contain rich design semantics with complex feature distribution or topology variant. Small changes of topology may significantly alter similarity among models  [13]. Two different solid models with complex feature distributions possibly share similar shape distribution statistical curves  [14]. As a result, retrieval for manufacturing classification is also an open research challenge  [15]. However, combinations of multi-approaches are reported of better performance  [16–18], and it is a good idea to introduce general shape retrieval algorithms to enhance solid model retrieval.

Previous researches also evaluate similarity of solid model with its external design features. These semantic features, like hole, boss, slot, etc., are extracted from the native file format pre-defined in specific CAD systems  [19] or custom-defined in feature templates interactively  [20]. Though semantic intuition of external design features simplifies a design process for users, it has limitation in content-based retrieval. On the one hand, different CAD systems probably organize variant feature definitions. A “cylinder” can be marked up as extrude or sweep in different CAD platforms. On the other hand, customized work flow can be adopted by users to design the same model, which result in different historical feature dependency graphs. Consequently, though external design feature approaches are natural to engineering experience, dependency on feature categories make it hard to fully automatic retrieval between heterogeneous systems.

Boundary representation (B-rep) is a unique internal scheme of solid model. It precisely organizes face-edge topology and geometric information that can be stored in the form of face adjacent graph (FAG); see Fig. 1
                        . FAG is independent to both users and CAD systems and hence it is suitable for cross-platform retrieval. Some studies focusing on local topology correspondence of FAG adopt the inexact match method   [21,22]. Other studies treat FAG as a whole at a global scale. Since sub-graph isomorphism is an NP-complete problem, improved graph matching algorithms are proposed  [23,24]. All of these studies treat FAG in one resolution and focus on the matching process. A multi-resolution descriptor, however, is also preferred in both global and partial retrieval  [25] since features in level of detail (LOD) is essential to avoid sensitiveness of small features reported in the topology-based method  [26]. In practical use, the LOD matching would be more preferable to support “explorable” or “iterative” search because designers only need to build a less detailed model as a search query.

Previous studies of geometric reasoning approaches explore feature volumes to get a shape descriptor in LOD. Chu  [27] defines additive and subtractive form features to get a feature adjacent graph, which is limited by feature volume constructed by sweeping a face along a direction. Cheng  [28] considered concave features by negative feature decomposition, which is suitable for machining parts specifically.

In summary, it has not been studied how to abstract the neutral format B-rep model into multi-resolutions by reasoning about intrinsic FAG, and how to retrieve the hierarchy based on both geometry and topology in LOD, which would require new algorithms to summarize multi-layer distributed similarities instead of conventional one-layer criteria.

This work specifically focuses on the geometric reasoning approach to a hierarchical structure for B-rep model retrieval. Research goals are as follows.
                           
                              •
                              Define a geometric reasoning mechanism that is independent of any CAD systems or design history, to associate low-level B-rep information and high-level form features.

Propose a hierarchical descriptor which organizes geometric and topological information of B-rep models with multi-resolution, to supply retrieval with efficiency and effectiveness.

Design and implement coarse-to-fine matching and comparison algorithms to validate global/partial retrieval, with user-friendly feedback to explain why and how two hierarchies are matched with relation to form features.


                        Fig. 2
                         illustrates the framework of our solution. The hierarchical partition graph (HPG) is a shape descriptor which is a hyper-graph composed of a tree of resolution level and an adjacent graph. The geometric reasoning procedure listed on the left side is adopted to map the intrinsic property of B-rep model to build an HPG. This process is further divided into two stages: low-level geometric reasoning and high-level geometric reasoning respectively. While the former contains edge recognition, seed detection, faces clustering into partition, and unit hierarchy building inside each partition, the latter reasons about the partition adjacent graph (PAG), recursively records parent of each node and simplifies PAG to HPG. As plotted on the right side, retrieval includes matching, comparing and ranking HPG similarity between the descriptor of query model and that of candidates indexed in design repository. This is ensured by weighted sub-graph isomorphism, where weights take geometric proportion in/between each resolution into account, preserving local/global topology consistency respectively. A shape distribution 
                           
                              (
                              D
                              2
                              )
                           
                         algorithm is used to get geometric similarity of matched pairs. All of these processes are automatic by design without user interaction.

The rest of this paper is organized as follows. Notions of HPG and related definitions are introduced in Section  2. Section  3 provides algorithms for the geometric reasoning approach from B-rep to HPG. Weighted sub-graph isomorphism algorithms are presented in Section  4. While implementation and results are given in Section  5 to confirm our approach, Section  6 concludes the present work and a discussion is given for future study.

Though B-rep does not contain high-level form feature information, it contains low-level features such as orientations of edges and faces, and edge-face adjacency in the form of winged-edge data structure  [29], which supplies a basis of reasoning to track left/right faces with oriented edges. Visually, concave edges on the B-rep model show that “there are features nearby”. Essentially, these edges supply mapping between low-level topologies and high-level form features. Following this idea, the B-rep model could seem to be a set of features or face clusters which “grow” at “seed” from base faces to new ones. Fig. 3
                         illustrates related notions.


                        
                           Definition 1
                           Seed


                           Let seed 
                                 
                                    (
                                    S
                                    )
                                 
                               be a set of connected edges that divide two sets of adjacent faces 
                                 
                                    
                                       F
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       F
                                    
                                    
                                       2
                                    
                                 
                              , where 
                                 
                                    
                                       F
                                    
                                    
                                       1
                                    
                                 
                                 ∩
                                 
                                    
                                       F
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 ⊘
                                 ,
                                 
                                    
                                       F
                                    
                                    
                                       1
                                    
                                 
                                 ∪
                                 
                                    
                                       F
                                    
                                    
                                       2
                                    
                                 
                                 ≠
                                 ⊘
                              .


                        
                           Definition 2
                           Growth


                           Growth 
                                 
                                    (
                                    G
                                    )
                                 
                               is an oriented operation based on the winged-edge data structure by querying winged face(s) at one side for another, crossing orientation of seed, from the query side to another.


                        
                           Definition 3
                           Partition


                           A partition 
                                 
                                    (
                                    P
                                    )
                                 
                               is a maximum set of faces of one semantic part of B-rep model 
                                 B
                              , where 
                                 
                                    {
                                    B
                                    ∣
                                    
                                       
                                          ∑
                                       
                                       
                                          m
                                       
                                    
                                    
                                       
                                          P
                                       
                                       
                                          m
                                       
                                    
                                    =
                                    B
                                    ,
                                    m
                                    ⩾
                                    1
                                    }
                                 
                               and semantic here is that faces of 
                                 P
                               share coherent concave/convex adjacency.

For example, there are two partitions at the buttom left view of Fig. 3. Each partition shares the same convex property in terms of adjacent edges joined between faces in that partition. 
                           Definition 4
                           Partition Seed


                           Partition Seed (PS) is a proper subset of 
                                 S
                              , on condition that undirected graph 
                                 G
                               of vertices of PS edges is the Eulerian circuit.

Intuitively, faces on the same side of oriented PS belong to the same partition; see Fig. 3. Note that edge orientation (dashed arrow) on the left wing is used to drive orientations of partition seed (closed dark solid arrows) to a uniform direction. To describe connections between partitions, we defined two categories of PS: single-face closed (SC) and multi-faces closed (MC). While the former means PS is inside a single face, the latter means there are multiple faces joining at PS, say MC is composed of outer-boundary edges. To distinguish concave/convex properties of these joints, SC and MC are further divided into concave/convex versions, say, SCV, SCX and MCV, MCX. The algorithm of concave/convex detection is given in Section  3.1. Moreover, multi-faces open convex (MOX) is defined for partition nearby open concave edges. MOX means the boundary of newly-grown faces of open seed. Since this boundary is closed and there are multiple faces around MOX, it is classified in the category of MC; see Fig. 4
                        .

Based on these minimum definitions, we could see a B-rep model as a group of partitions each of which is bounded by one or many PS. While SC means one partition “belongs to” or located at the inner boundary of a base face, MC preserve the “connect with” relationship, say, multi-faces in one partition should be used together to query adjacent faces of another partition. We further abstracted these two relationships as connection properties of PS as follows:
                           
                              •
                              “Parent–children” relationship between two 
                                    P
                                  connected with SC.

“Sibling” relationship between two 
                                    P
                                  connected with MC.

Since every PS is shared by a partition pair “
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           –
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        ”, we further introduced 
                           
                              
                                 L
                              
                              
                                 m
                              
                              
                                 p
                                 1
                                 –
                                 p
                                 2
                              
                           
                         as level of PS in terms of 
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        , and 
                           
                              
                                 L
                              
                              
                                 n
                              
                              
                                 p
                                 2
                                 –
                                 p
                                 1
                              
                           
                         as level of PS in terms of 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                           ,
                           
                           m
                           ,
                           n
                           =
                           0
                           ,
                           1
                           ,
                           2
                        . If PS is MC, which means “
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           –
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        ” are “siblings” and share the same level, then 
                           
                              
                                 L
                              
                              
                                 m
                              
                              
                                 p
                                 1
                                 –
                                 p
                                 2
                              
                           
                           =
                           
                              
                                 L
                              
                              
                                 n
                              
                              
                                 p
                                 2
                                 –
                                 p
                                 1
                              
                           
                           =
                           1
                        , else PS is SC, which represents the “parent–children” relationship, in which case 0 is given to level of “parent” 
                           P
                         and 2 to that of “child” 
                           P
                        , respectively. This can be summarized as: 
                           
                              (1)
                              
                                 
                                    
                                       L
                                    
                                    
                                       m
                                    
                                    
                                       p
                                       1
                                       –
                                       p
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       L
                                    
                                    
                                       n
                                    
                                    
                                       p
                                       2
                                       –
                                       p
                                       1
                                    
                                 
                                 =
                                 2
                                 .
                              
                           
                        
                     

In each 
                           P
                         symbol 
                           
                              
                                 L
                              
                              
                                 m
                              
                           
                         is named for short. Furthermore, master boot partition seed (MBPS) of each partition is defined as PS of maximum 
                           
                              
                                 L
                              
                              
                                 m
                              
                           
                        . Besides, a partition is called the 
                           
                              
                                 L
                              
                              
                                 m
                              
                           
                         partition if its MBPS is 
                           
                              
                                 L
                              
                              
                                 m
                              
                           
                        . These notions are mentioned in Section  3.5 where high-level reasoning based on PS is discussed.

Each partition captures unit coherent form feature of B-rep model. To bridge the gap between the low-level face/edge and the high-level partition, the sub-graphs of FAG are extracted to describe the partition property. In practice, these sub-FAG may still have considerable complexity especially when its partition contains a large amount of faces. To solve this problem, the notion of segmentation is defined at middle level that simplifies sub-FAG to a tree-like hierarchical structure.
                           Definition 5
                           Segmentation


                           Segmentation (SG) is a set of faces belonging to one semantic part of 
                                 P
                              , where 
                                 
                                    {
                                    P
                                    ∣
                                    
                                       
                                          ∑
                                       
                                       
                                          n
                                       
                                    
                                    
                                       
                                          
                                             SG
                                          
                                       
                                       
                                          n
                                       
                                    
                                    =
                                    P
                                    ,
                                    
                                    n
                                    ⩾
                                    1
                                    }
                                 
                               and semantic here is that 
                                 
                                    
                                       
                                          SG
                                       
                                    
                                    
                                       n
                                    
                                 
                               is one-step growth based on 
                                 
                                    
                                       
                                          SG
                                       
                                    
                                    
                                       n
                                       −
                                       1
                                    
                                 
                               which is originated from MBPS.

Based on the winged-edge data structure, one side of faces of MBPS that intersect with 
                           
                              
                                 P
                              
                              
                                 m
                              
                           
                         is selected as its first “back-end” 
                           
                              
                                 
                                    SG
                                 
                              
                              
                                 0
                              
                           
                        . Each growth returns the subsequent 
                           
                              
                                 
                                    SG
                                 
                              
                              
                                 n
                              
                           
                         per step until all faces of 
                           
                              
                                 P
                              
                              
                                 m
                              
                           
                         have been covered. Since the growth directions are coherence, all segments can be connected into a path graph to be stored as the property of 
                           
                              
                                 P
                              
                              
                                 m
                              
                           
                        . A detailed algorithm is given in Section  3.3. Since SG is a subset of 
                           P
                        , the tree structure is adopted to store this “parent–children” relationship and the adjacent graph to store the “sibling” relationship between SG. As illustrated in Fig. 5
                        , while 
                           
                              
                                 
                                    SG
                                 
                              
                              
                                 i
                              
                           
                         is linked with its “sibling” 
                           
                              
                                 
                                    SG
                                 
                              
                              
                                 j
                              
                           
                         by physical edges, dashed edges on the tree structure represent that SG belongs to 
                           P
                        . As of SG which has more than one faces, micro-level face adjacency is further stored as property of SG.

The whole B-rep model is composed of several partitions; thus the partition adjacent graph (PAG) is then built by linking nodes 
                           
                              
                                 P
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 P
                              
                              
                                 j
                              
                           
                         at their common PS.

The dark edge between the square node in Fig. 6
                         represents that two partitions are physically joined at PS. PAG provides a general adjacent relationship between partitions of B-rep model and it is simpler than FAG in terms of graph comparison. For models with complex structures however, it is essential to further simplify PAG to a more efficient data structure HPG. Algorithms will be given in Section  3.5.

The hierarchical partition graph (HPG) is a hyper-graph composed of a tree of resolution level (TR) and an adjacent graph (ADJ); see Fig. 7
                        . Circular grey nodes represent physical faces (one node per face), and white square nodes represent containers of faces. Dark solid lines in ADJ represent physical joint by edges; dashed lines in TR represent the “parent–children” relationship. Each cluster of ADJ is referenced by only one white square node in TR. For example, node 
                           
                              
                                 n
                              
                              
                                 11
                              
                           
                         of TR has children 
                           
                              
                                 n
                              
                              
                                 0
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                        ; at the same time, it references its ADJ containing two nodes 
                           
                              
                                 n
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                         and one edge 
                           
                              
                                 e
                              
                              
                                 0
                                 −
                                 3
                              
                           
                         as the edge property. With this coarse-to-fine structure, HPG preserves multi-resolutions determined by the depth of node on TR. For example, TR in Fig. 7 has a depth of 4. 
                           
                              
                                 n
                              
                              
                                 11
                              
                           
                         is of resolution level 0. It contains all faces of B-rep without consideration of feature detail; 
                           
                              
                                 n
                              
                              
                                 0
                              
                           
                         and 
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                         are of resolution level 1 since they are partitions further divided by partition seed. Following a “partition-segmentation-face” pattern, more details of local features are available as resolution level increases.

In summary, the HPG has following properties: 
                           
                              •
                              Global topology consistency: “parent–children” relationship between each resolution level of TR.

Local topology consistency: “sibling” relationship in each cluster of ADJ.

This section describes algorithms of geometric reasoning to construct HPG in practice. Discussion is based on STEP203 and geometric kernel of OpenCascade (OCC)  [30].

In Section  2.1, notions of SC and MC have been introduced. In this section they are calculated based on graph theory and OCC libraries. Fig. 8
                         provides flow chart of PS extraction. After the B-rep model has been read from the STEP file by 
                           
                              B
                           
                           -
                           
                              rep
                           
                           
                           
                              TopExp_Explorer
                           
                        , there are three main procedures distinguished by arrow type. While SC is built in the process of empty arrowheads, MC is calculated in the procedure of black arrowheads. Dashed arrow heads indicate the basic complementary process.

In the basic complementary process, dictionary-data-structure of Face-Edge map is built to simulate the function of winged-edge data structure, which is used to build growth iterator and to recognize the concave/convex edge list. While growth operation has been defined in Definition 2, the Face-Edge map is used to return one face by querying another and to support edge recognition described as follows.


                        Edge recognition. In OCC, elements of B-rep are defined as integrating both geometry and topology. Since vertex, edge and face have topology of point, curve and surface respectively, their orientations can be evaluated based on these topologies. While forward edge orientation means that its logical direction matches that of its curve, face orientation shows how face normal is aligned with its surface normal  [30]. This is useful to judge material side of B-rep model. Face material is defined by orientation of its edges. The side is determined by cross product between surface normal and edge derivative which equals its 3D curve derivative if the edge is forward and opposite, if reversed. In short, if an edge is forward then face material is on the left, or if reversed, it is on the right.

Based on these definitions, we calculated the concave/convex property on top of low-level winged-edge structure; see Fig. 9
                        . First material orientation is calculated on each face, which is cross product of positive face normal and edge orientation. Note that it is always at the left side of edge on its face. The sum of material orientations following the parallelogram law, is used to cross product to material orientation of one face to get master orientation (the long blank arrow). Finally, the convex edge is detected if master orientation and material orientation are the same. Alternatively, the concave edge has opposite orientations.

As of SC extraction, inner wires are evaluated on every single face. In the process of building MC, MCV and MCX candidates are prepared by closed cycle basis operation based on graph theory. These candidates are sub-graphs of vertex adjacent graph. In Definition 3, a partition is supposed to be a maximum set of faces with coherent concave/convex connections; some candidates split partitions however. For example, cases A and C in Fig. 10
                         divide one partition into two which have the same concave/convex property. To solve this problem, cross-section judgement is conducted as follows.


                        Cross-section judgement. To filter out cases A and C in Fig. 10, the linear equation is solved for cross-section judgement. First, for all 
                           
                              MCV
                           
                           /
                           
                              MCX
                           
                         candidates, material orientations 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 2
                              
                           
                         (grey dashed arrow) in terms of two winged faces intersecting at middle-point on each edge are calculated. Then the cross-section plane is created by these two vectors. Using this plane the intersecting point is calculated to build cross-section vector 
                           
                              
                                 
                                    
                                       c
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                         (black solid arrow). Since 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 
                                    
                                       c
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                         are in the same plane, 
                           
                              
                                 
                                    
                                       c
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                         can be determined by linear combination of 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 2
                              
                           
                         in their vector space. Let factors for 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 
                                    
                                       m
                                    
                                    →
                                 
                              
                              
                                 2
                              
                           
                         be 
                           
                              
                                 α
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 α
                              
                              
                                 2
                              
                           
                        ; then it meets 
                           A
                           ⋅
                           x
                           =
                           b
                         form.
                           
                              (2)
                              
                                 
                                    (
                                    
                                       
                                          
                                             
                                                m
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                m
                                             
                                             
                                                →
                                             
                                          
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 ⋅
                                 
                                    (
                                    
                                       
                                          
                                             
                                                
                                                   α
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   α
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       c
                                    
                                    
                                       →
                                    
                                 
                                 .
                              
                           
                         Both concave/convex properties and signs of factors 
                           
                              
                                 α
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 α
                              
                              
                                 2
                              
                           
                         are considered together to judge MCV and MCX. For concave cases, if signs of factors are all positive, it is not MCV. For convex cases, if signs of 
                           
                              
                                 α
                              
                              
                                 i
                              
                           
                           ,
                           
                           i
                           =
                           1
                           ,
                           2
                        , are all positive, it is not MCX.

Lastly, MOX is determined by reasoning about the rest of concave edges. See Fig. 11
                        ; dashed lines are candidate open-concave edges. After connecting these edges to build an edge adjacent graph, cluster operation is applied by fetching the connected components. These connected components are unclosed (dashed lines) but their newly-grown faces’ boundaries are ensured to be a closed subset of convex edge lists (black lines) which are stored as MOX. For cases that newly-grown faces collapse (cluster on the buttom), these faces are simply merged to get boundaries as MOX.

Algorithm 1 (Fig. 12
                        ) supplies a partitioning procedure based on PS of Definition 4. It returns set of partitions 
                           
                              {
                              p
                              }
                           
                         of a B-rep model 
                           B
                         in three main steps: initializing two partitions per seed, extending each 
                           p
                         the rest adjacent faces recursively, and merging adjacent many small 
                           p
                         into one large 
                           p
                        . Note that topology consistency is ensured by introducing 
                           p
                           s
                         as boundary conditions to prevent merge operation crossing 
                           p
                           s
                        ; see Fig. 13
                        .

For every partition, segments are then built with its MBPS. Algorithm 2 (Fig. 14
                        ) provides pseudo code of this procedure. Similar to the growth of Definition 2, the basic idea of this algorithm is that starting from MBPS, new segmentation 
                           s
                           
                              
                                 g
                              
                              
                                 
                                    new
                                 
                              
                           
                         is recursively grown based on previous segmentation, and the new seed 
                           p
                           
                              
                                 s
                              
                              
                                 
                                    new
                                 
                              
                           
                         is boundary of 
                           s
                           
                              
                                 g
                              
                              
                                 
                                    new
                                 
                              
                           
                         without contacting to 
                           p
                           
                              
                                 s
                              
                              
                                 
                                    old
                                 
                              
                           
                        .

The partition is then described by the tree structure, children nodes of which are segments. The sub-graph of FAG is stored as the attributed graph of property of tree node. See Figs. 5 and 13.

Previous sections give low-level geometric reasoning inside each partition. The rest sections present simplification of relationship between partitions at high level. First, PAG is built as the undirected graph. While each graph node represents partition, every edge stands for joint in the form of partition seed. In practice we checked whether two partitions share the same partition seed to link a graph edge, on which the level of seed is stored. The level of each partition (see Eq. (1) and later) is also stored on each graph node. Then we re-organized PAG to hierarchy based on the information of these levels.


                        HPG is built by reasoning about connection relationship between each adjacent partitions of PAG. Since PAG is a flattened undirected graph with only “sibling” relationship, yet a hierarchy is featured with the “parent–children” relationship, say, it is important to determine the “parent” of each node. Semantically, a partition is a relatively independent feature of B-rep model; then the parents of two or more partitions can be seen as a larger container of these features. Though there is not any form feature definition or classification in terms of geometry, there is underlying intrinsic connection property between partitions, the level of single face or multi-face seed (SC and MC). When the level of priority has been defined in Eq. (1), PAG is simplified to HPG based on the minimum information.

The basic idea of our approach is similar to the mesh simplification method. When different levels of partitions and their joints have been defined, partial graph edges are suppressed/un-suppressed subsequently to replace two partition nodes per step with a container node. “Parent–children” information is recorded at the same time.


                        Fig. 15
                         provides the framework of this high-level reasoning process. While black arrows indicate work flow from PAG to HPG crossing four modules, dashed arrows show how simplification module is called. In short, there are two main stages: reasoning about “parent” node information of every partition node in PAG, and assembling all nodes to build HPG with these “parent” information.


                        Initialization. In the initialization process, the dictionary data structure is adopted to store the property of nodes and edges on 
                           
                              PAG
                           
                           :
                           
                              G
                           
                           .
                           
                              edge
                           
                           
                              [
                              e
                              ]
                           
                           
                              [
                              ‘
                              
                                 supp_state
                              
                              ’
                              ]
                           
                           ←
                           0
                           ;
                           
                              G
                           
                           .
                           
                              node
                           
                           
                              [
                              n
                              ]
                           
                           
                              [
                              ‘
                              
                                 parent
                              
                              ’
                              ]
                           
                           ←
                           
                              None
                           
                           ;
                           
                              G
                           
                           .
                           
                              node
                           
                           
                              [
                              n
                              ]
                           
                           
                              [
                              ‘
                              
                                 children
                              
                              ’
                              ]
                           
                           ←
                           
                              [
                              
                              ]
                           
                        , where 
                           
                              G
                           
                           .
                           
                              edge
                           
                           
                              [
                              e
                              ]
                           
                         and 
                           
                              G
                           
                           .
                           
                              node
                           
                           
                              [
                              n
                              ]
                           
                         are dictionaries of 
                           
                              edge
                           
                           
                           e
                         and 
                           
                              node
                           
                           
                           n
                        , which contains key words (‘supp_state’, ‘parent’, ‘children’) to query the value of property. If an edge has its 
                           ‘
                           
                              supp_state
                           
                           ’
                           =
                           0
                        , it is un-suppressed that its adjacent nodes can be simplified by a container. Moreover, 
                           ‘
                           
                              geometry
                           
                           ’
                         property is also attached on each node and edge of PAG for assembling.


                        Basic simplification. In the basic simplification process, “base” node 
                           P
                           1
                         and “feature” node 
                           P
                           2
                         are simplified to 
                           P
                           3
                         per step following seed priority 
                           
                              
                                 L
                              
                              
                                 m
                              
                              
                                 P
                                 1
                                 –
                                 P
                                 2
                              
                           
                         in an order of 
                           
                              
                                 L
                              
                              
                                 0
                              
                           
                           →
                           
                              
                                 L
                              
                              
                                 1
                              
                           
                           →
                           
                              
                                 L
                              
                              
                                 2
                              
                           
                        . Fig. 16
                         illustrates this process, where centric black node is 
                           P
                           1
                        , and grey node represents 
                           P
                           2
                        . At each step, 
                           P
                           1
                         is maximum linked node and 
                           P
                           2
                         is one of its neighbours with minimum 
                           
                              
                                 L
                              
                              
                                 m
                              
                              
                                 P
                                 1
                                 –
                                 P
                                 2
                              
                           
                         and maximum 
                           
                              
                                 L
                              
                              
                                 n
                              
                              
                                 P
                                 2
                                 –
                                 P
                                 1
                              
                           
                        , say, if there is node pair of 
                           P
                           2
                         should be simplified first, 
                           P
                           2
                         is updated as 
                           P
                           1
                         and recursively search for new “
                           P
                           1
                           –
                           P
                           2
                        ” pair until all these conditions meet. Used seed is recorded at each step, as well as ‘parent’ and ‘children’ information: while 
                           P
                           3
                         is parent, 
                           P
                           1
                           ,
                           P
                           2
                         are children. In practice, new node 
                           P
                           3
                         is created if 
                           P
                           1
                           ,
                           P
                           2
                         have no ‘parent’, yet previous ‘parent’ is reused if this property exists. This is realized by the “Broadcasting” mechanism: every time a simplified pair “
                           P
                           1
                           –
                           P
                           2
                        ” is replaced by 
                           P
                           3
                        , ‘parent’ is not only stored on 
                           P
                           1
                           ,
                           P
                           2
                        , but is also ‘broadcasted’ to 
                           P
                           1
                        ’s neighbour of the same level as 
                           P
                           2
                        , where 
                           
                              
                                 L
                              
                              
                                 m
                              
                              
                                 P
                                 1
                                 −
                                 P
                                 
                                    neighbour
                                 
                              
                           
                           =
                           
                              
                                 L
                              
                              
                                 m
                              
                              
                                 P
                                 1
                                 –
                                 P
                                 2
                              
                           
                        . After 
                           P
                           3
                         has been linked to PAG, edges connected with 
                           P
                           1
                           ,
                           P
                           2
                         have been deleted.

Intuitively, if 
                           
                              
                                 L
                              
                              
                                 0
                              
                              
                                 P
                                 1
                                 –
                                 P
                                 2
                              
                           
                           <
                           
                              
                                 L
                              
                              
                                 2
                              
                              
                                 P
                                 2
                                 –
                                 P
                                 1
                              
                           
                        , an arrow can be drawn to represent the “growth direction” (on top-left of Fig. 16). If 
                           
                              
                                 L
                              
                              
                                 1
                              
                              
                                 P
                                 1
                                 –
                                 P
                                 2
                              
                           
                           =
                           =
                           
                              
                                 L
                              
                              
                                 2
                              
                              
                                 P
                                 2
                                 –
                                 P
                                 1
                              
                           
                        , the direction is further determined by comparing PS levels of adjacent partitions. Connecting these arrows provides a tree-like view, which is the reverse direction of simplification process.


                        Suppression/un-suppression. Basic simplification works on the simple B-rep model of tree-like structure yet cannot process complex patterns like symmetric or recursive pattern shown in Fig. 17
                        . For level-2 and level-1 patterns, partitions in the centre have two adjacent partitions. Both sides share the same level of MBPS in the central partition. This results in ambiguity of selecting simplification pair 
                           P
                           1
                           –
                           P
                           2
                        . Arrow directions also indicate this conflict. For the level-0 pattern, simplification pair 
                           P
                           1
                           –
                           P
                           2
                         failed to initialize since it recursively fetch new 
                           P
                           1
                           –
                           P
                           2
                         that should be simplified first. Arrow directions also show that it forms a closed directed graph. To solve these problems, conflict graph edges are suppressed/un-suppressed to process basic simplification hierarchically. See Fig. 15. The idea is to suppress conflict edges until their adjacent nodes have been simplified to container nodes. Then these container nodes are grouped under one ‘parent’ node when conflict edges are un-suppressed.

In suppression module, undirected 
                           
                              Level
                           
                           2
                           _
                           G
                        , 
                           
                              Level
                           
                           1
                           _
                           G
                        , and directed 
                           
                              Level
                           
                           0
                           _
                           G
                         (sub-graph with grey nodes in Fig. 17) are the sub-graphs of PAG. Numerical ‘supp_state’ of edge property is tracked to control simplification priority. If ‘supp_state’ of one edge 
                           >
                           0
                        , then vertex nodes of the edge can be simplified. First ‘supp_state’ of simple cycles of 
                           
                              Level
                           
                           0
                           _
                           G
                         is initialized to -2. Then ‘supp_state’ of clusters of 
                           
                              Level
                           
                           1
                           _
                           G
                         is set to −1 on condition that there are conflict edges one step outside leaf nodes. Finally, 
                           
                              Level
                           
                           2
                           _
                           G
                         are recursively suppressed by increase 1 on current maximum ‘supp_state’ of PAG, where edges are 1-step inside leaf nodes. In short, suppression module forms a hierarchical order 
                           
                              Level
                           
                           _
                           0
                           →
                           
                              Level
                           
                           _
                           1
                           →
                           
                              Level
                           
                           _
                           2
                        , and a reversed order is adopted in un-suppression module as follows.

In un-suppression module, first 
                           
                              Simplification_base
                           
                           
                              (
                              G
                              )
                           
                         is called by the 
                           
                              Unsupp_level
                           
                           2
                         function if there are edges meets 
                           ‘
                           
                              supp_state
                           
                           ’
                           =
                           =
                           0
                        . Then partial edges with current maximum ‘supp_state’ are filtered out to update its value with 1-current maximum ‘supp_state’. Recursion is performed by this function until current maximum ‘supp_state’ is decreased to 0. After that, Unsupp_level1 and Unsupp_level0 function update ‘supp_state’ of related edges to 0 and call 
                           
                              Simplification_base
                           
                           
                              (
                              G
                              )
                           
                         function, respectively. In summary, the suppression/un-suppression mechanism breaks whole PAG into many sub-graphs to call 
                           
                              Simplification_base
                           
                           
                              (
                              G
                              )
                           
                         functions locally, where edges are un-suppressed with 
                           ‘
                           
                              supp_state
                           
                           ’
                           =
                           =
                           0
                        . This mechanism eliminates growth conflict that it can process arbitrary type of PAG.


                        Assembling. The last assembling module is composed of two main functions: 
                           
                              BuildHierarchy
                           
                           
                              (
                              G
                              )
                           
                         and 
                           
                              BuildAdjacentGraph
                           
                           
                              (
                              G
                              )
                           
                        , which prepare a tree structure and an adjacent graph of node property respectively. While nodes of HPG are copied from simplified PAG, edges are built by checking ‘parent’, ‘children’ information stored on these nodes. Note that unit hierarchy is stored on each node of PAG, so does partition nodes on HPG. After the tree structure has been built, a Upload function is called to update ‘geometry’ property (geometric faces) of those container nodes created in the simplification process.

Then the adjacent graph of each none leaf node HPG is built by a depth-first iteration. Starting at root node of HPG, its children nodes are copied to ADJgraph. Edges of ADJgraph are then linked by checking physical connections between these children nodes. This process is recursively performed until leaf partition nodes whose ‘children’ property is empty. Therefore, HPG has all details from macro- to micro-scope, say, feature regions (partition containers) 
                           →
                         partitions 
                           →
                         segmentations 
                           →
                         faces; see Fig. 7.

Matching HPG is to find corresponding sub-regions of B-rep models in level of detail (LOD). It recursively checks current matched node whether there are more detailed feature distribution that can be matched. Given two HPG, the matching process is started at their root nodes which are matched by default. Then ADJgraph of root nodes is queried to match at a more precise level. The VF2 algorithm  [31] is adopted for sub-graph isomorphism to get the “best match”, which is realized by comparing similarity of different scenarios of correspondence. Given two ‘ADJgraph’ sharing the same topology, multiple scenarios of correspondence can be returned but it is not sufficient to determine the “best match” just with topology correspondence alone. To address this issue, geometric similarity is combined after each step of isomorphism, to select the “best match” with the highest score of sum of similarity, which is based on Eq. (4) of Section  4.2. Fig. 18
                         gives a minimum example to illustrate this operation.

To narrow down types of these scenarios, weight of edge is introduced to reduce a number of candidate nodes that can be matched. Since the edge of ‘ADJgrpah’ represents PS between two 
                           P
                        , the property is PS type in five categories which have been discussed: SCX, SCV, MCX, MCV and MOX. Weight is defined as 1 if two compatible edges are in the same category or 0 if not. Intuitively, this criterion requires matched pairs of nodes sharing the same type of connectivity. After best matched sub-graph of root’s ADJgraph has been found, a depth-first recursion is performed on each node of the sub-graph to get how its sub-feature distribution (ADJgraph) can be matched in a more detailed resolution level. Whole recursion stops until no more sub-graph can be matched or matching reaches leaf nodes of HPG.

Since HPG describes the B-rep model in the multi-resolution level, each resolution level is a description of similarity of two shapes. To summarize the total similarity, we introduced 
                           
                              
                                 ω
                              
                              
                                 
                                    out
                                 
                              
                           
                         to represent weight between each resolution level. Thus we have:
                           
                              (3)
                              
                                 
                                    
                                       S
                                    
                                    
                                       
                                          total
                                       
                                    
                                 
                                 =
                                 
                                    (
                                    1
                                    −
                                    σ
                                    )
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                    
                                       
                                          out
                                       
                                    
                                 
                                 ×
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                              
                           
                         where 
                           σ
                         represents the penalty factor measuring ratio between unmatched face areas and total face areas of two B-rep models. 
                           
                              
                                 ω
                              
                              
                                 i
                              
                              
                                 
                                    out
                                 
                              
                           
                         is the ratio between matched faces’ area of 
                           
                              
                                 i
                              
                              
                                 
                                    th
                                 
                              
                           
                         resolution level and total matched faces’ area of all resolution levels on condition that 
                           
                              
                                 ∑
                              
                              
                                 i
                              
                           
                           
                              
                                 ω
                              
                              
                                 i
                              
                              
                                 
                                    out
                                 
                              
                           
                           =
                           1
                        . 
                           
                              
                                 S
                              
                              
                                 
                                    total
                                 
                              
                           
                         is total similarity and 
                           
                              
                                 S
                              
                              
                                 i
                              
                           
                         is similarity of 
                           
                              
                                 i
                              
                              
                                 
                                    th
                                 
                              
                           
                         resolution level which can be formulated as: 
                           
                              (4)
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       ω
                                    
                                    
                                       j
                                    
                                    
                                       
                                          in
                                       
                                    
                                 
                                 ×
                                 D
                                 
                                    
                                       2
                                    
                                    
                                       
                                          sim
                                       
                                    
                                 
                              
                           
                         where 
                           
                              
                                 ω
                              
                              
                                 j
                              
                              
                                 
                                    in
                                 
                              
                           
                         is the ratio between matched faces’ area of 
                           
                              
                                 j
                              
                              
                                 
                                    th
                                 
                              
                           
                         node and total matched faces’ area of all nodes in the 
                           
                              
                                 i
                              
                              
                                 
                                    th
                                 
                              
                           
                         resolution level. 
                           D
                           
                              
                                 2
                              
                              
                                 
                                    sim
                                 
                              
                           
                         is similarity of matched pair of nodes. As of 
                           D
                           2
                         shape distribution and its similarity assessment, please refer to  [6].

Generally, while global matching is to retrieve a similar whole model, partial matching aims at finding local correspondence between two models. HPG supports both tasks for its level of detail. In global matching, whole HPG are stored, indexed and matched from its root. In partial matching, branches of HPG are processed separately and preserve references to whole HPG. With this method, the partial matching process can reuse the same algorithms of global matching. The only difference is that recursion begins at root of HPG branch. In practice, partial retrieval gets partial features on purpose of design reuse. These features are of notably complexity, say, they cover certain depths on HPG. To reduce search space, depth limitations should be considered in indexing branches of HPG. In this paper, we adopted the proposal that reusable branches are of crossing at least 3 depths  [20].

Time complexity in terms of sub-graph isomorphism is compared between HPG and FAG. Considering one-to-one mapping between two FAG, with a number of leaf nodes 
                           N
                        , it takes 
                           Θ
                           
                              (
                              
                                 
                                    N
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         of time complexity in the best case. In Fig. 19
                        , HPG of maximum depth is corresponding to the binary tree illustrated as “A”, other types of HPG cost more calculation steps since their TRs are less organized, e.g. “B” and “C”. Its time complexity of one-to-one mapping can be analyzed as follows: in case “A”, the depth of binary tree is 
                           
                              
                                 log
                              
                              
                                 2
                              
                           
                           N
                        . Given its root been matched by default, each ADJgraph with two nodes is of constant time complexity in matching since complexity of 
                           V
                           F
                           2
                         is 
                           Θ
                           
                              (
                              
                                 
                                    N
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         in the best case and 
                           Θ
                           
                              (
                              N
                              !
                              N
                              )
                           
                         in the worst case  [31]. Besides, there are 
                           
                              
                                 2
                              
                              
                                 i
                              
                           
                           −
                           1
                         number of ADJgraph in depth 
                           i
                         which requires a sub-graph isomorphism operation. The sum of these operations is 
                           
                              
                                 2
                              
                              
                                 0
                              
                           
                           +
                           
                              
                                 2
                              
                              
                                 1
                              
                           
                           +
                           ⋯
                           +
                           
                              
                                 2
                              
                              
                                 l
                                 o
                                 
                                    
                                       g
                                    
                                    
                                       2
                                    
                                 
                                 N
                                 −
                                 1
                              
                           
                           =
                           
                              
                                 1
                                 ⋅
                                 
                                    (
                                    1
                                    −
                                    
                                       
                                          2
                                       
                                       
                                          l
                                          o
                                          
                                             
                                                g
                                             
                                             
                                                2
                                             
                                          
                                          N
                                       
                                    
                                    )
                                 
                              
                              
                                 1
                                 −
                                 2
                              
                           
                           =
                           N
                        . Therefore the best case of HPG with binary tree costs time complexity of 
                           Θ
                           
                              (
                              N
                              )
                           
                        . Less organized cases, however, can be seen as reduction of clusters yet increasing of nodes complexity in certain clusters, which result in the increase of time complexity. For example, while time complexity of “A” is 
                           7
                           ×
                           4
                           =
                           28
                        , “B” costs 
                           
                              
                                 2
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 2
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 3
                              
                              
                                 2
                              
                           
                           +
                           
                              
                                 4
                              
                              
                                 2
                              
                           
                           =
                           33
                         operations at least, and “C” costs 
                           
                              
                                 8
                              
                              
                                 2
                              
                           
                           =
                           64
                         operations at least. Maximum complexity in the worst case is that all leaf nodes share the same root, where ADJgraph of root is FAG which has time complexity of 
                           Θ
                           
                              (
                              N
                              !
                              N
                              )
                           
                         at most. From the geometry point of view, the maximum complexity is obtained when the B-rep model is convex hull without any features. In summary, time complexity of HPG is reduced by its hierarchical structure and is better than that of sub-graph matching on FAG directly.

We implemented a prototype system to evaluate the efficiency and effectiveness of HPG for both global and partial retrieval. Our system works on hardware of Intel i3 CPU, 3 GB RAM and OS of Windows7 32 bit. While PythonOCC  [32] is adopted as geometric kernel, repository is composed of 101 STEP203 files sorted in 11 categories collected from National Design Repository  [33], TraceParts  [34], and our original data. As illustrated in Fig. 20
                        , main frame is composed of three panels: search key panel, option panel and repository browser, where 3d viewer is integrated to facilitate observing feature distribution and highlighting corresponding features in partial match mode. To analyse why and how two models are matched, we further provided a hierarchy view of HPG of selected model; see Figs. 26 and 27. Each node of HPG on top view is clickable, linked by its ADJgraph on the buttom left view and 
                           D
                           2
                         histogram on the buttom right view. This framework visualizes both topology and geometry interactively in a zoom-able user interface (ZUI), thus to be informative for designers who can navigate B-rep models and check retrieval results. All the interfaces, data structures and algorithms were built on the pythonxy scientific package  [35] in python language.


                        Fig. 21
                         provides a real example of global search for similar functional design using a ‘polymer slot’ as the key model. System returns similar models ranked by their similarities (see ‘
                           <
                           
                              Sim
                           
                           =
                           >
                        ’ on the figure). While returned models of higher similarities are mainly of the same category as the key model, those of lower scores are in irrelevant categories. As this feature is important in the information retrieval system, we further performed Precision–Recall Analysis and take comparison between our approach (HPG) and former methods. Fig. 22
                         gives Precision–Recall curves (P–R) of shape distribution (D2)  [6] and inexact matching based on the face adjacent graph (FAG)  [21]. These two typical content-based retrieval methods focus on geometry and local topology respectively. P–R of HPG is above 
                           D
                           2
                         and FAG thus to be of better effectiveness. The main reason is that HPG not only captures geometric distribution with 
                           D
                           2
                         histogram, but also considers both global and local topology. Essentially, its lowest resolution level corresponds to 
                           D
                           2
                         comparison, weighted sub-graph isomorphism gives exact match to driven further comparison in higher resolution level, penalty factor in Formula (3) efficiently filter out candidate models with similar 
                           D
                           2
                         yet dissimilar topology at lower resolution level.

Time estimation and similarity matrix of our approach are also visualized in Figs. 23 and 24
                        
                         respectively. Though the query time is not very fast, better result could be expected in practical deployment by using static language such as C++/Java instead of python dynamic language adopted in this initial prototype. Given that high-level precision–recall performance yet relatively low-level increase of time complexity, the HPG approach is of both effectiveness and efficiency in terms of “online” retrieval. Indexing time of HPG ranges from a few seconds to a few minutes, depending on complexity of features. Since it is at “offline” stage, it does not hurt the “online” retrieval performance at all.

For evaluating partial retrieval, faces of query model are selected by choosing the HPG branch. It is used to compare with partial HPG stored in repository. These partial HPGs are automatically split from global HPG on the condition that their depths are at least 3  [20]. Fig. 25
                         provides a real example of partial retrieval for socket feature. This feature is a selected branch rooted at node “83” by navigating HPG and observing highlighted features interactively; see Fig. 26.
                     

The matched parts are also highlighted, which ease examination of correspondence. With the support of “Show hierarchy”, users can further dive into its HPG and get why and how two partial features are matched. As shown in Fig. 27,  highlighted partial HPG is corresponding to the highlighted partial features of second returned model 
                           096
                           ∼
                           812
                           .
                           p
                           r
                           t
                         in repository browser. These two partial features are matched since they share common partial HPG (highlight on top view), the same local topology (ADJgraph on lower left view) and similar shape distribution (lower right view). Furthermore, topology and geometry at each higher resolution level are also matched that their partial hierarchy are summarized to be of high similarity. Compared with the previous feature defined method which requires feature-category prepared interactively or semi-interactively, the HPG approach is efficient, fully automatic and does not depend on the definition of specific form features. After feature segmentation, the compatibility of feature boundaries between the copied source feature and the target base model is essential in design reuse. Since edges between branches of HPG are corresponding to feature boundaries, seed-wire defined in this paper can be seen as the boundary condition in design reuse. Consequently, HPG is of adaptation and effectiveness for reuse oriented partial retrieval.

In this paper, we proposed a geometric reasoning approach to integrate both topology and geometry information into a hierarchy. It is suitable for processing neutral STEP203 format to ease multi-resolution B-rep model retrieval. Due to its level of detail, it reduces the cost of sub-graph isomorphism yet increases discrimination of comparison. The proposed internal and external weights capture intrinsic geometry proportion thus to be self-organized. Results show the effectiveness and efficiency of our shape descriptor HPG. This technique also has limitations. While the 
                        D
                        2
                      approach works for any shape with or without non-manifold, the HPG depends on consistent closed B-rep models without non-manifold. The FAG method needs less indexing time but HPG requires additional steps for geometric reasoning and graph abstraction based on FAG. Actually, HPG integrates FAG and 
                        D
                        2
                     . While the former provides reasoning foundation, the latter is used to find the “best match”, to progress to finer detailed step in matching stage, and to be the basis of integrating distributed similarities at each resolution level.

The proposed hierarchical structures may also be introduced in various knowledge intensive or resource critical applications, such as solid model analysis, knowledge-integration, distributed storage and network transformation, etc. Specifically, seed-wire retains underlying correlation between feature segmentation, which is the boundary condition of design reuse task, say, partial shape in copy–paste operation could be knowledge integrated, validated and transformed by seed-wire. We would like to further investigate in this application to ease design reuse.

There are several aspects to explore and to improve our method in the future: first, reducing topology influence of small fillets and chamfers. Currently we pre-processed these small blend features with a simple suppression algorithm to retain the similarity factor between both versions. Second, free-form surfaces are of low discrimination by the shape distribution method  [36]. Interpreting curvature distribution for comparison needs to be considered separately. As of multi-body solid model which usually represents the assembly mechanism, we do not suggest to directly use our method. Since the assembly mechanism is designed on purpose of kinematic function  [37], and kinematic information is more important that should be extracted and described explicitly. Lastly, even though our hierarchy reduces computational complexity in LOD, large scale pattern features are corresponding to lots of child partitions that still increase the time complexity of isomorphism considerably. To address this issue, grouping detected patterns  [38] and position distribution  [16] are possible solutions.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to thank Chuipin Kong and Lu Zhang for implementation of part of this work. Thanks also go to Grant No. 60903111 from National Natural Science Foundation of China for partial funding of this work. They appreciate valuable advices from reviewers and helpful comments from editors on improving this paper.

@&#REFERENCES@&#

