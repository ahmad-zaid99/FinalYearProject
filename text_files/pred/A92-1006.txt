 The Joyce text generation system was developped part of the software design environment Ulysses (Korelsky and Ulysses Staff 1988; Rosenthal et al 1988) Ulysses includes a graphical environment for the design of secure, distributed software systems. As a tool in the user interface, Joyce generates twc different types of texts about software designs: The texts Joyce generates are specifically conceived o as written texts. For example, if a designer reads the desig] annotation generated by Joyce and notices that the secu rity level of a component has been entered wrong, the] the error can be corrected by clicking at the name of th component in the text window and accessing the appro priate menu. Note that the structures of the two texts are quite different: while the Host text is structured according to more abstract categories such as design structure and functionality, the Black Box text follows the path of the insecure flow through the component. Joyce consists of three separate modules, which perform distinct tasks and access their own knowledge bases (Figure 5). Usually, the different tasks of text generation are divided among two modules (planning and realization), rather than three. For example, McKeown's TEXT (McKeown 1985) performs the tasks that Joyce classifies as sentence planning as part of the realization process, whereas Meteer's SPOKESMAN (Meteer 1989) classifies them as part of text planning. (See (Meteer 1990, p.23sq) for a useful summary of the terminological issues'.) In this paper, &quot;text planning&quot; will always be used in the narrow sense of &quot;content selection and organization&quot;. Rosner divides the realization component into two parts, the &quot;generator kernel&quot; and the &quot;generator front end&quot;. The linguistic planning tasks should, however, be clearly separated from the textual planning tasks: while the linguistic planning tasks are languagedependent, the textual planning tasks appear not to be2. In Joyce, the Deep-Syntactic Representation encodes syntactic structure but not linear order (see Section 6 for details). Thus, if multi-lingual generation is desired, text planning and sentence planning ought to be performed by distinct components. While the current implementations of Joyce do not allow for parallel execution, the incremental processing of parallel computing tasks on a serial machine is also advantageous, as is argued in the WIP project (Wahlster et al 1991; Harbusch et al 1991)3. In the Joyce system, the text planner cedes control to the sentence planner as soon as the text planner has defined a proposition. Once the sentence planner has constructed the DSyntR of a complete sentence, it sends it to the realizer which generates the English sentence. Thus, the first sentence is output by Joyce shortly after the text generator is invoked; text continues to be output approximately at reading speed. Throughout the system, processing is message-driven in the sense of (McDonald et al 1987): control lies in the input, which is used to construct the next level of representation. Prior to the design of the text planning component of Joyce, several existing approaches were studied. Since the structure of the descriptive text (Figure 2) does not mirror the structure of the domain, Paris's &quot;procedural strategy&quot; (Paris and McKeown 1987) cannot be used in general. Hovy's RST-based planner (Hovy 1988) assumes that content selection has already been performed, contrary to the situation in the Ulysses application; furthermore, there are efficiency problems in a pure STRIPS-like planning paradigm. In (Kittredge et al 1991), we argue that planning certain types of texts - such as reports and descriptions - requires domain-specific knowledge about how to communicate in that domain. For example, in describing secure system designs 3Incrementality within the realizer has little practical benefit when the realizer is reasonably fast; its study is mainly motivated by psycholinguistic considerations. In the flow analyzer text, the security levels of the components need not be communicated at all, but if a component (other than the final component of the path) downgrades information, it must be stated whether and why the component is secure. We have developed a &quot;schema language&quot; for easy representation of DCK, called DICKENS (DomaIn Communication Knowledge ENcoding Schemas). During execution, each schema is associated with a particular subset of the domain representation, which is called the focus (in the sense of McKeown's &quot;global focus&quot;). In addition to the focus, which limits the domain representation from which information can be communicated, a theme can be set which determines information structure within individual propositions. In addition, two further special commands were found to be necessary in order to perform text planning: This type of revision is different from the revision discussed in (Gabriel 1988) and (Meteer 1991). Instead of being templates that limit the structure of the text to certain preconceived types, the schemas are now an explicit and compact representation of domain communication knowledge. It has two main tasks: first, it chooses lexical and syntactic realizations by consulting the Conceptual/English dictionary; second, it determines sentence scope by merging the DSyntR of individual propositions. Each proposition is mapped into the DSyntR of a clause (i.e., its root is a verb). For example, The low-level Address Register and the multilevel Locator are data-bases (from the Host text in Figure 2) is significantly better than the four clauses from which it was formed: The Address Register is a data-base. To date, the issue of sentence scoping has always been dealt with at a pre-linguistic, conceptual level (e.g. However, different languages have different syntactic means of combining clauses; clause combining must refer to the specific linguistic resources of the target language. Therefore, in Joyce the task is performed by the sentence planner rather than the text planner'. Joyce performs the following syntactic clausecombining operations: Relative clause formation, adjectival attachment (the process by which an adjective from a copula-construction is embedded in an NP), and conjunction. Conjunction includes multiple conjunctions of more than one clause, and may lead to elision of repeated sentence elements (&quot;conjunction reduction&quot;). The stylistic constraints are constraints against the sentence becoming too long (an upper bound on the number of clauses that can be combined into one sentence), and a constraint on recursive embedding of relative clauses. The text planner can send a special message, called conceptual-break, to the sentence planner. If none of the clause combination strategies work, or if stylistic heuristics interfere, or if the incoming proposition is a conceptual-break, the current DSyntR is sent to the realizer and the new DSyntR becomes the current one. The linguistic component is based on Meaning-Text Theory (MTT) (Mel'euk 1988), and is a reimplementation (in Lisp) of Polguere's Prolog implementation of a Meaning-Text model for English (Iordanskaja et al 1988; Iordanskaja et al 1991). While linguistic realizers based on other theories coulc have been used, this MTT-based approach offers the following advantages:
As an example, consider the sample text in Figure 4. The texts that explain insecure flow are generated by a set of eight schemas, one of which i shown in Figure 7. focus is a pointer maintained by the text planner which refers to the global focus (currently the component Black Box, represented by pointer #<COMPONENT Black Box>), while get-information and entry-port are functions provided by the underlying application program. The text planner sends an insecure-flow proposition to the sentence planner, which translates it into a DSyntR tree (which represents the clause In the Black Box an insecure flow occurs) and returns control to the text planner. The text planner then proceeds to the next :make-proposition command, and sends the proposition shown in Figure 8 to the sentence planner. When the sentence planner re
ceives the enter proposition, it translates it into the DSyntR tree shown in Figure 9, which could be expressed as the clause information enters the Black Box through P6. This fails (since the two clauses have different verbs and different actants), so the current DSyntR is sent to the realizer, which prints out the first sentence. Control is returned to the text planner, which processes the third :make-propos it ion command and sends the appropriate proposition to the sentence planner. It then attempts to combine the new clause with the &quot;current DSyntR&quot;, first using the adjectival attachment strategy. It then returns control to the text planner, since another clause could be merged with the current DSyntR. The only effect of this schema is to send a conceptual-break message to the sentence planner, which thereupon sends its current DSyntR to the realizer. The last command of the schema first shifts the (global) focus to next-component, which is the next component traversed by the insecure flow. The effect of this function is to combine two successive send propositions into a single, new one, so that two clauses such as the Analyzer sends the information to the Incrementor and the Incrementor sends the information to the Formater yield the Analyzer sends the information to the Formater through the Incrementor. It must therefore be performed by the text planner, and not the sentence planner. Porting is an important way to evaluate complete applied text generation systems, since there is no canonical set of tasks that such a system must be able to perform and on which it can be tested. (Realization components, on the other hand, can be tested for their syntactic and perhaps lexical coverage.) The &quot;flow analyzer&quot; heuristic tool was added later to the system, and the completely different type of text it required was a first successful test of Joyce and its text planner in particular.